
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model brand
 * 
 */
export type brand = $Result.DefaultSelection<Prisma.$brandPayload>
/**
 * Model subbrand
 * 
 */
export type subbrand = $Result.DefaultSelection<Prisma.$subbrandPayload>
/**
 * Model store
 * 
 */
export type store = $Result.DefaultSelection<Prisma.$storePayload>
/**
 * Model channel
 * 
 */
export type channel = $Result.DefaultSelection<Prisma.$channelPayload>
/**
 * Model category
 * 
 */
export type category = $Result.DefaultSelection<Prisma.$categoryPayload>
/**
 * Model product
 * 
 */
export type product = $Result.DefaultSelection<Prisma.$productPayload>
/**
 * Model optiongroup
 * 
 */
export type optiongroup = $Result.DefaultSelection<Prisma.$optiongroupPayload>
/**
 * Model item
 * 
 */
export type item = $Result.DefaultSelection<Prisma.$itemPayload>
/**
 * Model customer
 * 
 */
export type customer = $Result.DefaultSelection<Prisma.$customerPayload>
/**
 * Model sale
 * 
 */
export type sale = $Result.DefaultSelection<Prisma.$salePayload>
/**
 * Model productsale
 * 
 */
export type productsale = $Result.DefaultSelection<Prisma.$productsalePayload>
/**
 * Model itemproductsale
 * 
 */
export type itemproductsale = $Result.DefaultSelection<Prisma.$itemproductsalePayload>
/**
 * Model itemitemproductsale
 * 
 */
export type itemitemproductsale = $Result.DefaultSelection<Prisma.$itemitemproductsalePayload>
/**
 * Model deliverysale
 * 
 */
export type deliverysale = $Result.DefaultSelection<Prisma.$deliverysalePayload>
/**
 * Model deliveryaddress
 * 
 */
export type deliveryaddress = $Result.DefaultSelection<Prisma.$deliveryaddressPayload>
/**
 * Model paymenttype
 * 
 */
export type paymenttype = $Result.DefaultSelection<Prisma.$paymenttypePayload>
/**
 * Model payment
 * 
 */
export type payment = $Result.DefaultSelection<Prisma.$paymentPayload>
/**
 * Model coupon
 * 
 */
export type coupon = $Result.DefaultSelection<Prisma.$couponPayload>
/**
 * Model couponsale
 * 
 */
export type couponsale = $Result.DefaultSelection<Prisma.$couponsalePayload>

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Brands
 * const brands = await prisma.brand.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Brands
   * const brands = await prisma.brand.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.brand`: Exposes CRUD operations for the **brand** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Brands
    * const brands = await prisma.brand.findMany()
    * ```
    */
  get brand(): Prisma.brandDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.subbrand`: Exposes CRUD operations for the **subbrand** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Subbrands
    * const subbrands = await prisma.subbrand.findMany()
    * ```
    */
  get subbrand(): Prisma.subbrandDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.store`: Exposes CRUD operations for the **store** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Stores
    * const stores = await prisma.store.findMany()
    * ```
    */
  get store(): Prisma.storeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.channel`: Exposes CRUD operations for the **channel** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Channels
    * const channels = await prisma.channel.findMany()
    * ```
    */
  get channel(): Prisma.channelDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.category`: Exposes CRUD operations for the **category** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Categories
    * const categories = await prisma.category.findMany()
    * ```
    */
  get category(): Prisma.categoryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.product`: Exposes CRUD operations for the **product** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Products
    * const products = await prisma.product.findMany()
    * ```
    */
  get product(): Prisma.productDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.optiongroup`: Exposes CRUD operations for the **optiongroup** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Optiongroups
    * const optiongroups = await prisma.optiongroup.findMany()
    * ```
    */
  get optiongroup(): Prisma.optiongroupDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.item`: Exposes CRUD operations for the **item** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Items
    * const items = await prisma.item.findMany()
    * ```
    */
  get item(): Prisma.itemDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.customer`: Exposes CRUD operations for the **customer** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Customers
    * const customers = await prisma.customer.findMany()
    * ```
    */
  get customer(): Prisma.customerDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.sale`: Exposes CRUD operations for the **sale** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Sales
    * const sales = await prisma.sale.findMany()
    * ```
    */
  get sale(): Prisma.saleDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.productsale`: Exposes CRUD operations for the **productsale** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Productsales
    * const productsales = await prisma.productsale.findMany()
    * ```
    */
  get productsale(): Prisma.productsaleDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.itemproductsale`: Exposes CRUD operations for the **itemproductsale** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Itemproductsales
    * const itemproductsales = await prisma.itemproductsale.findMany()
    * ```
    */
  get itemproductsale(): Prisma.itemproductsaleDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.itemitemproductsale`: Exposes CRUD operations for the **itemitemproductsale** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Itemitemproductsales
    * const itemitemproductsales = await prisma.itemitemproductsale.findMany()
    * ```
    */
  get itemitemproductsale(): Prisma.itemitemproductsaleDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.deliverysale`: Exposes CRUD operations for the **deliverysale** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Deliverysales
    * const deliverysales = await prisma.deliverysale.findMany()
    * ```
    */
  get deliverysale(): Prisma.deliverysaleDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.deliveryaddress`: Exposes CRUD operations for the **deliveryaddress** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Deliveryaddresses
    * const deliveryaddresses = await prisma.deliveryaddress.findMany()
    * ```
    */
  get deliveryaddress(): Prisma.deliveryaddressDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.paymenttype`: Exposes CRUD operations for the **paymenttype** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Paymenttypes
    * const paymenttypes = await prisma.paymenttype.findMany()
    * ```
    */
  get paymenttype(): Prisma.paymenttypeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.payment`: Exposes CRUD operations for the **payment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Payments
    * const payments = await prisma.payment.findMany()
    * ```
    */
  get payment(): Prisma.paymentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.coupon`: Exposes CRUD operations for the **coupon** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Coupons
    * const coupons = await prisma.coupon.findMany()
    * ```
    */
  get coupon(): Prisma.couponDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.couponsale`: Exposes CRUD operations for the **couponsale** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Couponsales
    * const couponsales = await prisma.couponsale.findMany()
    * ```
    */
  get couponsale(): Prisma.couponsaleDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.12.0
   * Query Engine version: 8047c96bbd92db98a2abc7c9323ce77c02c89dbc
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    brand: 'brand',
    subbrand: 'subbrand',
    store: 'store',
    channel: 'channel',
    category: 'category',
    product: 'product',
    optiongroup: 'optiongroup',
    item: 'item',
    customer: 'customer',
    sale: 'sale',
    productsale: 'productsale',
    itemproductsale: 'itemproductsale',
    itemitemproductsale: 'itemitemproductsale',
    deliverysale: 'deliverysale',
    deliveryaddress: 'deliveryaddress',
    paymenttype: 'paymenttype',
    payment: 'payment',
    coupon: 'coupon',
    couponsale: 'couponsale'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "brand" | "subbrand" | "store" | "channel" | "category" | "product" | "optiongroup" | "item" | "customer" | "sale" | "productsale" | "itemproductsale" | "itemitemproductsale" | "deliverysale" | "deliveryaddress" | "paymenttype" | "payment" | "coupon" | "couponsale"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      brand: {
        payload: Prisma.$brandPayload<ExtArgs>
        fields: Prisma.brandFieldRefs
        operations: {
          findUnique: {
            args: Prisma.brandFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$brandPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.brandFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$brandPayload>
          }
          findFirst: {
            args: Prisma.brandFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$brandPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.brandFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$brandPayload>
          }
          findMany: {
            args: Prisma.brandFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$brandPayload>[]
          }
          create: {
            args: Prisma.brandCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$brandPayload>
          }
          createMany: {
            args: Prisma.brandCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.brandCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$brandPayload>[]
          }
          delete: {
            args: Prisma.brandDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$brandPayload>
          }
          update: {
            args: Prisma.brandUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$brandPayload>
          }
          deleteMany: {
            args: Prisma.brandDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.brandUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.brandUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$brandPayload>[]
          }
          upsert: {
            args: Prisma.brandUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$brandPayload>
          }
          aggregate: {
            args: Prisma.BrandAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBrand>
          }
          groupBy: {
            args: Prisma.brandGroupByArgs<ExtArgs>
            result: $Utils.Optional<BrandGroupByOutputType>[]
          }
          count: {
            args: Prisma.brandCountArgs<ExtArgs>
            result: $Utils.Optional<BrandCountAggregateOutputType> | number
          }
        }
      }
      subbrand: {
        payload: Prisma.$subbrandPayload<ExtArgs>
        fields: Prisma.subbrandFieldRefs
        operations: {
          findUnique: {
            args: Prisma.subbrandFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$subbrandPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.subbrandFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$subbrandPayload>
          }
          findFirst: {
            args: Prisma.subbrandFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$subbrandPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.subbrandFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$subbrandPayload>
          }
          findMany: {
            args: Prisma.subbrandFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$subbrandPayload>[]
          }
          create: {
            args: Prisma.subbrandCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$subbrandPayload>
          }
          createMany: {
            args: Prisma.subbrandCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.subbrandCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$subbrandPayload>[]
          }
          delete: {
            args: Prisma.subbrandDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$subbrandPayload>
          }
          update: {
            args: Prisma.subbrandUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$subbrandPayload>
          }
          deleteMany: {
            args: Prisma.subbrandDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.subbrandUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.subbrandUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$subbrandPayload>[]
          }
          upsert: {
            args: Prisma.subbrandUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$subbrandPayload>
          }
          aggregate: {
            args: Prisma.SubbrandAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSubbrand>
          }
          groupBy: {
            args: Prisma.subbrandGroupByArgs<ExtArgs>
            result: $Utils.Optional<SubbrandGroupByOutputType>[]
          }
          count: {
            args: Prisma.subbrandCountArgs<ExtArgs>
            result: $Utils.Optional<SubbrandCountAggregateOutputType> | number
          }
        }
      }
      store: {
        payload: Prisma.$storePayload<ExtArgs>
        fields: Prisma.storeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.storeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$storePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.storeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$storePayload>
          }
          findFirst: {
            args: Prisma.storeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$storePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.storeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$storePayload>
          }
          findMany: {
            args: Prisma.storeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$storePayload>[]
          }
          create: {
            args: Prisma.storeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$storePayload>
          }
          createMany: {
            args: Prisma.storeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.storeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$storePayload>[]
          }
          delete: {
            args: Prisma.storeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$storePayload>
          }
          update: {
            args: Prisma.storeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$storePayload>
          }
          deleteMany: {
            args: Prisma.storeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.storeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.storeUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$storePayload>[]
          }
          upsert: {
            args: Prisma.storeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$storePayload>
          }
          aggregate: {
            args: Prisma.StoreAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStore>
          }
          groupBy: {
            args: Prisma.storeGroupByArgs<ExtArgs>
            result: $Utils.Optional<StoreGroupByOutputType>[]
          }
          count: {
            args: Prisma.storeCountArgs<ExtArgs>
            result: $Utils.Optional<StoreCountAggregateOutputType> | number
          }
        }
      }
      channel: {
        payload: Prisma.$channelPayload<ExtArgs>
        fields: Prisma.channelFieldRefs
        operations: {
          findUnique: {
            args: Prisma.channelFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$channelPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.channelFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$channelPayload>
          }
          findFirst: {
            args: Prisma.channelFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$channelPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.channelFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$channelPayload>
          }
          findMany: {
            args: Prisma.channelFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$channelPayload>[]
          }
          create: {
            args: Prisma.channelCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$channelPayload>
          }
          createMany: {
            args: Prisma.channelCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.channelCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$channelPayload>[]
          }
          delete: {
            args: Prisma.channelDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$channelPayload>
          }
          update: {
            args: Prisma.channelUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$channelPayload>
          }
          deleteMany: {
            args: Prisma.channelDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.channelUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.channelUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$channelPayload>[]
          }
          upsert: {
            args: Prisma.channelUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$channelPayload>
          }
          aggregate: {
            args: Prisma.ChannelAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateChannel>
          }
          groupBy: {
            args: Prisma.channelGroupByArgs<ExtArgs>
            result: $Utils.Optional<ChannelGroupByOutputType>[]
          }
          count: {
            args: Prisma.channelCountArgs<ExtArgs>
            result: $Utils.Optional<ChannelCountAggregateOutputType> | number
          }
        }
      }
      category: {
        payload: Prisma.$categoryPayload<ExtArgs>
        fields: Prisma.categoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.categoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$categoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.categoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$categoryPayload>
          }
          findFirst: {
            args: Prisma.categoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$categoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.categoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$categoryPayload>
          }
          findMany: {
            args: Prisma.categoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$categoryPayload>[]
          }
          create: {
            args: Prisma.categoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$categoryPayload>
          }
          createMany: {
            args: Prisma.categoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.categoryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$categoryPayload>[]
          }
          delete: {
            args: Prisma.categoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$categoryPayload>
          }
          update: {
            args: Prisma.categoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$categoryPayload>
          }
          deleteMany: {
            args: Prisma.categoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.categoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.categoryUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$categoryPayload>[]
          }
          upsert: {
            args: Prisma.categoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$categoryPayload>
          }
          aggregate: {
            args: Prisma.CategoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCategory>
          }
          groupBy: {
            args: Prisma.categoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<CategoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.categoryCountArgs<ExtArgs>
            result: $Utils.Optional<CategoryCountAggregateOutputType> | number
          }
        }
      }
      product: {
        payload: Prisma.$productPayload<ExtArgs>
        fields: Prisma.productFieldRefs
        operations: {
          findUnique: {
            args: Prisma.productFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$productPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.productFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$productPayload>
          }
          findFirst: {
            args: Prisma.productFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$productPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.productFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$productPayload>
          }
          findMany: {
            args: Prisma.productFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$productPayload>[]
          }
          create: {
            args: Prisma.productCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$productPayload>
          }
          createMany: {
            args: Prisma.productCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.productCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$productPayload>[]
          }
          delete: {
            args: Prisma.productDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$productPayload>
          }
          update: {
            args: Prisma.productUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$productPayload>
          }
          deleteMany: {
            args: Prisma.productDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.productUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.productUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$productPayload>[]
          }
          upsert: {
            args: Prisma.productUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$productPayload>
          }
          aggregate: {
            args: Prisma.ProductAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProduct>
          }
          groupBy: {
            args: Prisma.productGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProductGroupByOutputType>[]
          }
          count: {
            args: Prisma.productCountArgs<ExtArgs>
            result: $Utils.Optional<ProductCountAggregateOutputType> | number
          }
        }
      }
      optiongroup: {
        payload: Prisma.$optiongroupPayload<ExtArgs>
        fields: Prisma.optiongroupFieldRefs
        operations: {
          findUnique: {
            args: Prisma.optiongroupFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$optiongroupPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.optiongroupFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$optiongroupPayload>
          }
          findFirst: {
            args: Prisma.optiongroupFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$optiongroupPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.optiongroupFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$optiongroupPayload>
          }
          findMany: {
            args: Prisma.optiongroupFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$optiongroupPayload>[]
          }
          create: {
            args: Prisma.optiongroupCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$optiongroupPayload>
          }
          createMany: {
            args: Prisma.optiongroupCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.optiongroupCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$optiongroupPayload>[]
          }
          delete: {
            args: Prisma.optiongroupDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$optiongroupPayload>
          }
          update: {
            args: Prisma.optiongroupUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$optiongroupPayload>
          }
          deleteMany: {
            args: Prisma.optiongroupDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.optiongroupUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.optiongroupUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$optiongroupPayload>[]
          }
          upsert: {
            args: Prisma.optiongroupUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$optiongroupPayload>
          }
          aggregate: {
            args: Prisma.OptiongroupAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOptiongroup>
          }
          groupBy: {
            args: Prisma.optiongroupGroupByArgs<ExtArgs>
            result: $Utils.Optional<OptiongroupGroupByOutputType>[]
          }
          count: {
            args: Prisma.optiongroupCountArgs<ExtArgs>
            result: $Utils.Optional<OptiongroupCountAggregateOutputType> | number
          }
        }
      }
      item: {
        payload: Prisma.$itemPayload<ExtArgs>
        fields: Prisma.itemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.itemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$itemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.itemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$itemPayload>
          }
          findFirst: {
            args: Prisma.itemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$itemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.itemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$itemPayload>
          }
          findMany: {
            args: Prisma.itemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$itemPayload>[]
          }
          create: {
            args: Prisma.itemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$itemPayload>
          }
          createMany: {
            args: Prisma.itemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.itemCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$itemPayload>[]
          }
          delete: {
            args: Prisma.itemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$itemPayload>
          }
          update: {
            args: Prisma.itemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$itemPayload>
          }
          deleteMany: {
            args: Prisma.itemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.itemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.itemUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$itemPayload>[]
          }
          upsert: {
            args: Prisma.itemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$itemPayload>
          }
          aggregate: {
            args: Prisma.ItemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateItem>
          }
          groupBy: {
            args: Prisma.itemGroupByArgs<ExtArgs>
            result: $Utils.Optional<ItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.itemCountArgs<ExtArgs>
            result: $Utils.Optional<ItemCountAggregateOutputType> | number
          }
        }
      }
      customer: {
        payload: Prisma.$customerPayload<ExtArgs>
        fields: Prisma.customerFieldRefs
        operations: {
          findUnique: {
            args: Prisma.customerFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$customerPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.customerFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$customerPayload>
          }
          findFirst: {
            args: Prisma.customerFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$customerPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.customerFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$customerPayload>
          }
          findMany: {
            args: Prisma.customerFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$customerPayload>[]
          }
          create: {
            args: Prisma.customerCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$customerPayload>
          }
          createMany: {
            args: Prisma.customerCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.customerCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$customerPayload>[]
          }
          delete: {
            args: Prisma.customerDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$customerPayload>
          }
          update: {
            args: Prisma.customerUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$customerPayload>
          }
          deleteMany: {
            args: Prisma.customerDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.customerUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.customerUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$customerPayload>[]
          }
          upsert: {
            args: Prisma.customerUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$customerPayload>
          }
          aggregate: {
            args: Prisma.CustomerAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCustomer>
          }
          groupBy: {
            args: Prisma.customerGroupByArgs<ExtArgs>
            result: $Utils.Optional<CustomerGroupByOutputType>[]
          }
          count: {
            args: Prisma.customerCountArgs<ExtArgs>
            result: $Utils.Optional<CustomerCountAggregateOutputType> | number
          }
        }
      }
      sale: {
        payload: Prisma.$salePayload<ExtArgs>
        fields: Prisma.saleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.saleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$salePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.saleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$salePayload>
          }
          findFirst: {
            args: Prisma.saleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$salePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.saleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$salePayload>
          }
          findMany: {
            args: Prisma.saleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$salePayload>[]
          }
          create: {
            args: Prisma.saleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$salePayload>
          }
          createMany: {
            args: Prisma.saleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.saleCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$salePayload>[]
          }
          delete: {
            args: Prisma.saleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$salePayload>
          }
          update: {
            args: Prisma.saleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$salePayload>
          }
          deleteMany: {
            args: Prisma.saleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.saleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.saleUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$salePayload>[]
          }
          upsert: {
            args: Prisma.saleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$salePayload>
          }
          aggregate: {
            args: Prisma.SaleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSale>
          }
          groupBy: {
            args: Prisma.saleGroupByArgs<ExtArgs>
            result: $Utils.Optional<SaleGroupByOutputType>[]
          }
          count: {
            args: Prisma.saleCountArgs<ExtArgs>
            result: $Utils.Optional<SaleCountAggregateOutputType> | number
          }
        }
      }
      productsale: {
        payload: Prisma.$productsalePayload<ExtArgs>
        fields: Prisma.productsaleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.productsaleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$productsalePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.productsaleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$productsalePayload>
          }
          findFirst: {
            args: Prisma.productsaleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$productsalePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.productsaleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$productsalePayload>
          }
          findMany: {
            args: Prisma.productsaleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$productsalePayload>[]
          }
          create: {
            args: Prisma.productsaleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$productsalePayload>
          }
          createMany: {
            args: Prisma.productsaleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.productsaleCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$productsalePayload>[]
          }
          delete: {
            args: Prisma.productsaleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$productsalePayload>
          }
          update: {
            args: Prisma.productsaleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$productsalePayload>
          }
          deleteMany: {
            args: Prisma.productsaleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.productsaleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.productsaleUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$productsalePayload>[]
          }
          upsert: {
            args: Prisma.productsaleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$productsalePayload>
          }
          aggregate: {
            args: Prisma.ProductsaleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProductsale>
          }
          groupBy: {
            args: Prisma.productsaleGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProductsaleGroupByOutputType>[]
          }
          count: {
            args: Prisma.productsaleCountArgs<ExtArgs>
            result: $Utils.Optional<ProductsaleCountAggregateOutputType> | number
          }
        }
      }
      itemproductsale: {
        payload: Prisma.$itemproductsalePayload<ExtArgs>
        fields: Prisma.itemproductsaleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.itemproductsaleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$itemproductsalePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.itemproductsaleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$itemproductsalePayload>
          }
          findFirst: {
            args: Prisma.itemproductsaleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$itemproductsalePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.itemproductsaleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$itemproductsalePayload>
          }
          findMany: {
            args: Prisma.itemproductsaleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$itemproductsalePayload>[]
          }
          create: {
            args: Prisma.itemproductsaleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$itemproductsalePayload>
          }
          createMany: {
            args: Prisma.itemproductsaleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.itemproductsaleCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$itemproductsalePayload>[]
          }
          delete: {
            args: Prisma.itemproductsaleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$itemproductsalePayload>
          }
          update: {
            args: Prisma.itemproductsaleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$itemproductsalePayload>
          }
          deleteMany: {
            args: Prisma.itemproductsaleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.itemproductsaleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.itemproductsaleUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$itemproductsalePayload>[]
          }
          upsert: {
            args: Prisma.itemproductsaleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$itemproductsalePayload>
          }
          aggregate: {
            args: Prisma.ItemproductsaleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateItemproductsale>
          }
          groupBy: {
            args: Prisma.itemproductsaleGroupByArgs<ExtArgs>
            result: $Utils.Optional<ItemproductsaleGroupByOutputType>[]
          }
          count: {
            args: Prisma.itemproductsaleCountArgs<ExtArgs>
            result: $Utils.Optional<ItemproductsaleCountAggregateOutputType> | number
          }
        }
      }
      itemitemproductsale: {
        payload: Prisma.$itemitemproductsalePayload<ExtArgs>
        fields: Prisma.itemitemproductsaleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.itemitemproductsaleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$itemitemproductsalePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.itemitemproductsaleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$itemitemproductsalePayload>
          }
          findFirst: {
            args: Prisma.itemitemproductsaleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$itemitemproductsalePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.itemitemproductsaleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$itemitemproductsalePayload>
          }
          findMany: {
            args: Prisma.itemitemproductsaleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$itemitemproductsalePayload>[]
          }
          create: {
            args: Prisma.itemitemproductsaleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$itemitemproductsalePayload>
          }
          createMany: {
            args: Prisma.itemitemproductsaleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.itemitemproductsaleCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$itemitemproductsalePayload>[]
          }
          delete: {
            args: Prisma.itemitemproductsaleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$itemitemproductsalePayload>
          }
          update: {
            args: Prisma.itemitemproductsaleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$itemitemproductsalePayload>
          }
          deleteMany: {
            args: Prisma.itemitemproductsaleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.itemitemproductsaleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.itemitemproductsaleUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$itemitemproductsalePayload>[]
          }
          upsert: {
            args: Prisma.itemitemproductsaleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$itemitemproductsalePayload>
          }
          aggregate: {
            args: Prisma.ItemitemproductsaleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateItemitemproductsale>
          }
          groupBy: {
            args: Prisma.itemitemproductsaleGroupByArgs<ExtArgs>
            result: $Utils.Optional<ItemitemproductsaleGroupByOutputType>[]
          }
          count: {
            args: Prisma.itemitemproductsaleCountArgs<ExtArgs>
            result: $Utils.Optional<ItemitemproductsaleCountAggregateOutputType> | number
          }
        }
      }
      deliverysale: {
        payload: Prisma.$deliverysalePayload<ExtArgs>
        fields: Prisma.deliverysaleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.deliverysaleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$deliverysalePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.deliverysaleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$deliverysalePayload>
          }
          findFirst: {
            args: Prisma.deliverysaleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$deliverysalePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.deliverysaleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$deliverysalePayload>
          }
          findMany: {
            args: Prisma.deliverysaleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$deliverysalePayload>[]
          }
          create: {
            args: Prisma.deliverysaleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$deliverysalePayload>
          }
          createMany: {
            args: Prisma.deliverysaleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.deliverysaleCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$deliverysalePayload>[]
          }
          delete: {
            args: Prisma.deliverysaleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$deliverysalePayload>
          }
          update: {
            args: Prisma.deliverysaleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$deliverysalePayload>
          }
          deleteMany: {
            args: Prisma.deliverysaleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.deliverysaleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.deliverysaleUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$deliverysalePayload>[]
          }
          upsert: {
            args: Prisma.deliverysaleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$deliverysalePayload>
          }
          aggregate: {
            args: Prisma.DeliverysaleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDeliverysale>
          }
          groupBy: {
            args: Prisma.deliverysaleGroupByArgs<ExtArgs>
            result: $Utils.Optional<DeliverysaleGroupByOutputType>[]
          }
          count: {
            args: Prisma.deliverysaleCountArgs<ExtArgs>
            result: $Utils.Optional<DeliverysaleCountAggregateOutputType> | number
          }
        }
      }
      deliveryaddress: {
        payload: Prisma.$deliveryaddressPayload<ExtArgs>
        fields: Prisma.deliveryaddressFieldRefs
        operations: {
          findUnique: {
            args: Prisma.deliveryaddressFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$deliveryaddressPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.deliveryaddressFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$deliveryaddressPayload>
          }
          findFirst: {
            args: Prisma.deliveryaddressFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$deliveryaddressPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.deliveryaddressFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$deliveryaddressPayload>
          }
          findMany: {
            args: Prisma.deliveryaddressFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$deliveryaddressPayload>[]
          }
          create: {
            args: Prisma.deliveryaddressCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$deliveryaddressPayload>
          }
          createMany: {
            args: Prisma.deliveryaddressCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.deliveryaddressCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$deliveryaddressPayload>[]
          }
          delete: {
            args: Prisma.deliveryaddressDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$deliveryaddressPayload>
          }
          update: {
            args: Prisma.deliveryaddressUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$deliveryaddressPayload>
          }
          deleteMany: {
            args: Prisma.deliveryaddressDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.deliveryaddressUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.deliveryaddressUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$deliveryaddressPayload>[]
          }
          upsert: {
            args: Prisma.deliveryaddressUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$deliveryaddressPayload>
          }
          aggregate: {
            args: Prisma.DeliveryaddressAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDeliveryaddress>
          }
          groupBy: {
            args: Prisma.deliveryaddressGroupByArgs<ExtArgs>
            result: $Utils.Optional<DeliveryaddressGroupByOutputType>[]
          }
          count: {
            args: Prisma.deliveryaddressCountArgs<ExtArgs>
            result: $Utils.Optional<DeliveryaddressCountAggregateOutputType> | number
          }
        }
      }
      paymenttype: {
        payload: Prisma.$paymenttypePayload<ExtArgs>
        fields: Prisma.paymenttypeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.paymenttypeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$paymenttypePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.paymenttypeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$paymenttypePayload>
          }
          findFirst: {
            args: Prisma.paymenttypeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$paymenttypePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.paymenttypeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$paymenttypePayload>
          }
          findMany: {
            args: Prisma.paymenttypeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$paymenttypePayload>[]
          }
          create: {
            args: Prisma.paymenttypeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$paymenttypePayload>
          }
          createMany: {
            args: Prisma.paymenttypeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.paymenttypeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$paymenttypePayload>[]
          }
          delete: {
            args: Prisma.paymenttypeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$paymenttypePayload>
          }
          update: {
            args: Prisma.paymenttypeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$paymenttypePayload>
          }
          deleteMany: {
            args: Prisma.paymenttypeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.paymenttypeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.paymenttypeUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$paymenttypePayload>[]
          }
          upsert: {
            args: Prisma.paymenttypeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$paymenttypePayload>
          }
          aggregate: {
            args: Prisma.PaymenttypeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePaymenttype>
          }
          groupBy: {
            args: Prisma.paymenttypeGroupByArgs<ExtArgs>
            result: $Utils.Optional<PaymenttypeGroupByOutputType>[]
          }
          count: {
            args: Prisma.paymenttypeCountArgs<ExtArgs>
            result: $Utils.Optional<PaymenttypeCountAggregateOutputType> | number
          }
        }
      }
      payment: {
        payload: Prisma.$paymentPayload<ExtArgs>
        fields: Prisma.paymentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.paymentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$paymentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.paymentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$paymentPayload>
          }
          findFirst: {
            args: Prisma.paymentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$paymentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.paymentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$paymentPayload>
          }
          findMany: {
            args: Prisma.paymentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$paymentPayload>[]
          }
          create: {
            args: Prisma.paymentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$paymentPayload>
          }
          createMany: {
            args: Prisma.paymentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.paymentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$paymentPayload>[]
          }
          delete: {
            args: Prisma.paymentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$paymentPayload>
          }
          update: {
            args: Prisma.paymentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$paymentPayload>
          }
          deleteMany: {
            args: Prisma.paymentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.paymentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.paymentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$paymentPayload>[]
          }
          upsert: {
            args: Prisma.paymentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$paymentPayload>
          }
          aggregate: {
            args: Prisma.PaymentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePayment>
          }
          groupBy: {
            args: Prisma.paymentGroupByArgs<ExtArgs>
            result: $Utils.Optional<PaymentGroupByOutputType>[]
          }
          count: {
            args: Prisma.paymentCountArgs<ExtArgs>
            result: $Utils.Optional<PaymentCountAggregateOutputType> | number
          }
        }
      }
      coupon: {
        payload: Prisma.$couponPayload<ExtArgs>
        fields: Prisma.couponFieldRefs
        operations: {
          findUnique: {
            args: Prisma.couponFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$couponPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.couponFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$couponPayload>
          }
          findFirst: {
            args: Prisma.couponFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$couponPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.couponFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$couponPayload>
          }
          findMany: {
            args: Prisma.couponFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$couponPayload>[]
          }
          create: {
            args: Prisma.couponCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$couponPayload>
          }
          createMany: {
            args: Prisma.couponCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.couponCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$couponPayload>[]
          }
          delete: {
            args: Prisma.couponDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$couponPayload>
          }
          update: {
            args: Prisma.couponUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$couponPayload>
          }
          deleteMany: {
            args: Prisma.couponDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.couponUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.couponUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$couponPayload>[]
          }
          upsert: {
            args: Prisma.couponUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$couponPayload>
          }
          aggregate: {
            args: Prisma.CouponAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCoupon>
          }
          groupBy: {
            args: Prisma.couponGroupByArgs<ExtArgs>
            result: $Utils.Optional<CouponGroupByOutputType>[]
          }
          count: {
            args: Prisma.couponCountArgs<ExtArgs>
            result: $Utils.Optional<CouponCountAggregateOutputType> | number
          }
        }
      }
      couponsale: {
        payload: Prisma.$couponsalePayload<ExtArgs>
        fields: Prisma.couponsaleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.couponsaleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$couponsalePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.couponsaleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$couponsalePayload>
          }
          findFirst: {
            args: Prisma.couponsaleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$couponsalePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.couponsaleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$couponsalePayload>
          }
          findMany: {
            args: Prisma.couponsaleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$couponsalePayload>[]
          }
          create: {
            args: Prisma.couponsaleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$couponsalePayload>
          }
          createMany: {
            args: Prisma.couponsaleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.couponsaleCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$couponsalePayload>[]
          }
          delete: {
            args: Prisma.couponsaleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$couponsalePayload>
          }
          update: {
            args: Prisma.couponsaleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$couponsalePayload>
          }
          deleteMany: {
            args: Prisma.couponsaleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.couponsaleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.couponsaleUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$couponsalePayload>[]
          }
          upsert: {
            args: Prisma.couponsaleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$couponsalePayload>
          }
          aggregate: {
            args: Prisma.CouponsaleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCouponsale>
          }
          groupBy: {
            args: Prisma.couponsaleGroupByArgs<ExtArgs>
            result: $Utils.Optional<CouponsaleGroupByOutputType>[]
          }
          count: {
            args: Prisma.couponsaleCountArgs<ExtArgs>
            result: $Utils.Optional<CouponsaleCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    brand?: brandOmit
    subbrand?: subbrandOmit
    store?: storeOmit
    channel?: channelOmit
    category?: categoryOmit
    product?: productOmit
    optiongroup?: optiongroupOmit
    item?: itemOmit
    customer?: customerOmit
    sale?: saleOmit
    productsale?: productsaleOmit
    itemproductsale?: itemproductsaleOmit
    itemitemproductsale?: itemitemproductsaleOmit
    deliverysale?: deliverysaleOmit
    deliveryaddress?: deliveryaddressOmit
    paymenttype?: paymenttypeOmit
    payment?: paymentOmit
    coupon?: couponOmit
    couponsale?: couponsaleOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type BrandCountOutputType
   */

  export type BrandCountOutputType = {
    subbrands: number
    stores: number
    channels: number
    categories: number
    products: number
    optiongroups: number
    items: number
    paymenttypes: number
    coupons: number
  }

  export type BrandCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    subbrands?: boolean | BrandCountOutputTypeCountSubbrandsArgs
    stores?: boolean | BrandCountOutputTypeCountStoresArgs
    channels?: boolean | BrandCountOutputTypeCountChannelsArgs
    categories?: boolean | BrandCountOutputTypeCountCategoriesArgs
    products?: boolean | BrandCountOutputTypeCountProductsArgs
    optiongroups?: boolean | BrandCountOutputTypeCountOptiongroupsArgs
    items?: boolean | BrandCountOutputTypeCountItemsArgs
    paymenttypes?: boolean | BrandCountOutputTypeCountPaymenttypesArgs
    coupons?: boolean | BrandCountOutputTypeCountCouponsArgs
  }

  // Custom InputTypes
  /**
   * BrandCountOutputType without action
   */
  export type BrandCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BrandCountOutputType
     */
    select?: BrandCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * BrandCountOutputType without action
   */
  export type BrandCountOutputTypeCountSubbrandsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: subbrandWhereInput
  }

  /**
   * BrandCountOutputType without action
   */
  export type BrandCountOutputTypeCountStoresArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: storeWhereInput
  }

  /**
   * BrandCountOutputType without action
   */
  export type BrandCountOutputTypeCountChannelsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: channelWhereInput
  }

  /**
   * BrandCountOutputType without action
   */
  export type BrandCountOutputTypeCountCategoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: categoryWhereInput
  }

  /**
   * BrandCountOutputType without action
   */
  export type BrandCountOutputTypeCountProductsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: productWhereInput
  }

  /**
   * BrandCountOutputType without action
   */
  export type BrandCountOutputTypeCountOptiongroupsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: optiongroupWhereInput
  }

  /**
   * BrandCountOutputType without action
   */
  export type BrandCountOutputTypeCountItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: itemWhereInput
  }

  /**
   * BrandCountOutputType without action
   */
  export type BrandCountOutputTypeCountPaymenttypesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: paymenttypeWhereInput
  }

  /**
   * BrandCountOutputType without action
   */
  export type BrandCountOutputTypeCountCouponsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: couponWhereInput
  }


  /**
   * Count Type SubbrandCountOutputType
   */

  export type SubbrandCountOutputType = {
    stores: number
    categories: number
    products: number
    optiongroups: number
    items: number
    customers: number
    sales: number
  }

  export type SubbrandCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    stores?: boolean | SubbrandCountOutputTypeCountStoresArgs
    categories?: boolean | SubbrandCountOutputTypeCountCategoriesArgs
    products?: boolean | SubbrandCountOutputTypeCountProductsArgs
    optiongroups?: boolean | SubbrandCountOutputTypeCountOptiongroupsArgs
    items?: boolean | SubbrandCountOutputTypeCountItemsArgs
    customers?: boolean | SubbrandCountOutputTypeCountCustomersArgs
    sales?: boolean | SubbrandCountOutputTypeCountSalesArgs
  }

  // Custom InputTypes
  /**
   * SubbrandCountOutputType without action
   */
  export type SubbrandCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubbrandCountOutputType
     */
    select?: SubbrandCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SubbrandCountOutputType without action
   */
  export type SubbrandCountOutputTypeCountStoresArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: storeWhereInput
  }

  /**
   * SubbrandCountOutputType without action
   */
  export type SubbrandCountOutputTypeCountCategoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: categoryWhereInput
  }

  /**
   * SubbrandCountOutputType without action
   */
  export type SubbrandCountOutputTypeCountProductsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: productWhereInput
  }

  /**
   * SubbrandCountOutputType without action
   */
  export type SubbrandCountOutputTypeCountOptiongroupsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: optiongroupWhereInput
  }

  /**
   * SubbrandCountOutputType without action
   */
  export type SubbrandCountOutputTypeCountItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: itemWhereInput
  }

  /**
   * SubbrandCountOutputType without action
   */
  export type SubbrandCountOutputTypeCountCustomersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: customerWhereInput
  }

  /**
   * SubbrandCountOutputType without action
   */
  export type SubbrandCountOutputTypeCountSalesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: saleWhereInput
  }


  /**
   * Count Type StoreCountOutputType
   */

  export type StoreCountOutputType = {
    customers: number
    sales: number
  }

  export type StoreCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customers?: boolean | StoreCountOutputTypeCountCustomersArgs
    sales?: boolean | StoreCountOutputTypeCountSalesArgs
  }

  // Custom InputTypes
  /**
   * StoreCountOutputType without action
   */
  export type StoreCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoreCountOutputType
     */
    select?: StoreCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * StoreCountOutputType without action
   */
  export type StoreCountOutputTypeCountCustomersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: customerWhereInput
  }

  /**
   * StoreCountOutputType without action
   */
  export type StoreCountOutputTypeCountSalesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: saleWhereInput
  }


  /**
   * Count Type ChannelCountOutputType
   */

  export type ChannelCountOutputType = {
    sales: number
  }

  export type ChannelCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sales?: boolean | ChannelCountOutputTypeCountSalesArgs
  }

  // Custom InputTypes
  /**
   * ChannelCountOutputType without action
   */
  export type ChannelCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChannelCountOutputType
     */
    select?: ChannelCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ChannelCountOutputType without action
   */
  export type ChannelCountOutputTypeCountSalesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: saleWhereInput
  }


  /**
   * Count Type CategoryCountOutputType
   */

  export type CategoryCountOutputType = {
    products: number
    optiongroups: number
    items: number
  }

  export type CategoryCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    products?: boolean | CategoryCountOutputTypeCountProductsArgs
    optiongroups?: boolean | CategoryCountOutputTypeCountOptiongroupsArgs
    items?: boolean | CategoryCountOutputTypeCountItemsArgs
  }

  // Custom InputTypes
  /**
   * CategoryCountOutputType without action
   */
  export type CategoryCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CategoryCountOutputType
     */
    select?: CategoryCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CategoryCountOutputType without action
   */
  export type CategoryCountOutputTypeCountProductsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: productWhereInput
  }

  /**
   * CategoryCountOutputType without action
   */
  export type CategoryCountOutputTypeCountOptiongroupsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: optiongroupWhereInput
  }

  /**
   * CategoryCountOutputType without action
   */
  export type CategoryCountOutputTypeCountItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: itemWhereInput
  }


  /**
   * Count Type ProductCountOutputType
   */

  export type ProductCountOutputType = {
    productsales: number
  }

  export type ProductCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    productsales?: boolean | ProductCountOutputTypeCountProductsalesArgs
  }

  // Custom InputTypes
  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCountOutputType
     */
    select?: ProductCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeCountProductsalesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: productsaleWhereInput
  }


  /**
   * Count Type OptiongroupCountOutputType
   */

  export type OptiongroupCountOutputType = {
    itemproductsales: number
    itemitemproductsales: number
  }

  export type OptiongroupCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    itemproductsales?: boolean | OptiongroupCountOutputTypeCountItemproductsalesArgs
    itemitemproductsales?: boolean | OptiongroupCountOutputTypeCountItemitemproductsalesArgs
  }

  // Custom InputTypes
  /**
   * OptiongroupCountOutputType without action
   */
  export type OptiongroupCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OptiongroupCountOutputType
     */
    select?: OptiongroupCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * OptiongroupCountOutputType without action
   */
  export type OptiongroupCountOutputTypeCountItemproductsalesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: itemproductsaleWhereInput
  }

  /**
   * OptiongroupCountOutputType without action
   */
  export type OptiongroupCountOutputTypeCountItemitemproductsalesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: itemitemproductsaleWhereInput
  }


  /**
   * Count Type ItemCountOutputType
   */

  export type ItemCountOutputType = {
    itemproductsales: number
    itemitemproductsales: number
  }

  export type ItemCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    itemproductsales?: boolean | ItemCountOutputTypeCountItemproductsalesArgs
    itemitemproductsales?: boolean | ItemCountOutputTypeCountItemitemproductsalesArgs
  }

  // Custom InputTypes
  /**
   * ItemCountOutputType without action
   */
  export type ItemCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemCountOutputType
     */
    select?: ItemCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ItemCountOutputType without action
   */
  export type ItemCountOutputTypeCountItemproductsalesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: itemproductsaleWhereInput
  }

  /**
   * ItemCountOutputType without action
   */
  export type ItemCountOutputTypeCountItemitemproductsalesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: itemitemproductsaleWhereInput
  }


  /**
   * Count Type CustomerCountOutputType
   */

  export type CustomerCountOutputType = {
    sales: number
  }

  export type CustomerCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sales?: boolean | CustomerCountOutputTypeCountSalesArgs
  }

  // Custom InputTypes
  /**
   * CustomerCountOutputType without action
   */
  export type CustomerCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerCountOutputType
     */
    select?: CustomerCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CustomerCountOutputType without action
   */
  export type CustomerCountOutputTypeCountSalesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: saleWhereInput
  }


  /**
   * Count Type SaleCountOutputType
   */

  export type SaleCountOutputType = {
    productsales: number
    deliverysales: number
    deliveryaddress: number
    payments: number
    couponsales: number
  }

  export type SaleCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    productsales?: boolean | SaleCountOutputTypeCountProductsalesArgs
    deliverysales?: boolean | SaleCountOutputTypeCountDeliverysalesArgs
    deliveryaddress?: boolean | SaleCountOutputTypeCountDeliveryaddressArgs
    payments?: boolean | SaleCountOutputTypeCountPaymentsArgs
    couponsales?: boolean | SaleCountOutputTypeCountCouponsalesArgs
  }

  // Custom InputTypes
  /**
   * SaleCountOutputType without action
   */
  export type SaleCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SaleCountOutputType
     */
    select?: SaleCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SaleCountOutputType without action
   */
  export type SaleCountOutputTypeCountProductsalesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: productsaleWhereInput
  }

  /**
   * SaleCountOutputType without action
   */
  export type SaleCountOutputTypeCountDeliverysalesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: deliverysaleWhereInput
  }

  /**
   * SaleCountOutputType without action
   */
  export type SaleCountOutputTypeCountDeliveryaddressArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: deliveryaddressWhereInput
  }

  /**
   * SaleCountOutputType without action
   */
  export type SaleCountOutputTypeCountPaymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: paymentWhereInput
  }

  /**
   * SaleCountOutputType without action
   */
  export type SaleCountOutputTypeCountCouponsalesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: couponsaleWhereInput
  }


  /**
   * Count Type ProductsaleCountOutputType
   */

  export type ProductsaleCountOutputType = {
    itemproductsales: number
  }

  export type ProductsaleCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    itemproductsales?: boolean | ProductsaleCountOutputTypeCountItemproductsalesArgs
  }

  // Custom InputTypes
  /**
   * ProductsaleCountOutputType without action
   */
  export type ProductsaleCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductsaleCountOutputType
     */
    select?: ProductsaleCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ProductsaleCountOutputType without action
   */
  export type ProductsaleCountOutputTypeCountItemproductsalesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: itemproductsaleWhereInput
  }


  /**
   * Count Type ItemproductsaleCountOutputType
   */

  export type ItemproductsaleCountOutputType = {
    itemitemproductsales: number
  }

  export type ItemproductsaleCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    itemitemproductsales?: boolean | ItemproductsaleCountOutputTypeCountItemitemproductsalesArgs
  }

  // Custom InputTypes
  /**
   * ItemproductsaleCountOutputType without action
   */
  export type ItemproductsaleCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemproductsaleCountOutputType
     */
    select?: ItemproductsaleCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ItemproductsaleCountOutputType without action
   */
  export type ItemproductsaleCountOutputTypeCountItemitemproductsalesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: itemitemproductsaleWhereInput
  }


  /**
   * Count Type DeliverysaleCountOutputType
   */

  export type DeliverysaleCountOutputType = {
    deliveryaddresses: number
  }

  export type DeliverysaleCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    deliveryaddresses?: boolean | DeliverysaleCountOutputTypeCountDeliveryaddressesArgs
  }

  // Custom InputTypes
  /**
   * DeliverysaleCountOutputType without action
   */
  export type DeliverysaleCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliverysaleCountOutputType
     */
    select?: DeliverysaleCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * DeliverysaleCountOutputType without action
   */
  export type DeliverysaleCountOutputTypeCountDeliveryaddressesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: deliveryaddressWhereInput
  }


  /**
   * Count Type PaymenttypeCountOutputType
   */

  export type PaymenttypeCountOutputType = {
    payments: number
  }

  export type PaymenttypeCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    payments?: boolean | PaymenttypeCountOutputTypeCountPaymentsArgs
  }

  // Custom InputTypes
  /**
   * PaymenttypeCountOutputType without action
   */
  export type PaymenttypeCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymenttypeCountOutputType
     */
    select?: PaymenttypeCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PaymenttypeCountOutputType without action
   */
  export type PaymenttypeCountOutputTypeCountPaymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: paymentWhereInput
  }


  /**
   * Count Type CouponCountOutputType
   */

  export type CouponCountOutputType = {
    couponsales: number
  }

  export type CouponCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    couponsales?: boolean | CouponCountOutputTypeCountCouponsalesArgs
  }

  // Custom InputTypes
  /**
   * CouponCountOutputType without action
   */
  export type CouponCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CouponCountOutputType
     */
    select?: CouponCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CouponCountOutputType without action
   */
  export type CouponCountOutputTypeCountCouponsalesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: couponsaleWhereInput
  }


  /**
   * Models
   */

  /**
   * Model brand
   */

  export type AggregateBrand = {
    _count: BrandCountAggregateOutputType | null
    _avg: BrandAvgAggregateOutputType | null
    _sum: BrandSumAggregateOutputType | null
    _min: BrandMinAggregateOutputType | null
    _max: BrandMaxAggregateOutputType | null
  }

  export type BrandAvgAggregateOutputType = {
    id: number | null
  }

  export type BrandSumAggregateOutputType = {
    id: number | null
  }

  export type BrandMinAggregateOutputType = {
    id: number | null
    name: string | null
    created_at: Date | null
  }

  export type BrandMaxAggregateOutputType = {
    id: number | null
    name: string | null
    created_at: Date | null
  }

  export type BrandCountAggregateOutputType = {
    id: number
    name: number
    created_at: number
    _all: number
  }


  export type BrandAvgAggregateInputType = {
    id?: true
  }

  export type BrandSumAggregateInputType = {
    id?: true
  }

  export type BrandMinAggregateInputType = {
    id?: true
    name?: true
    created_at?: true
  }

  export type BrandMaxAggregateInputType = {
    id?: true
    name?: true
    created_at?: true
  }

  export type BrandCountAggregateInputType = {
    id?: true
    name?: true
    created_at?: true
    _all?: true
  }

  export type BrandAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which brand to aggregate.
     */
    where?: brandWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of brands to fetch.
     */
    orderBy?: brandOrderByWithRelationInput | brandOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: brandWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` brands from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` brands.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned brands
    **/
    _count?: true | BrandCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BrandAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BrandSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BrandMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BrandMaxAggregateInputType
  }

  export type GetBrandAggregateType<T extends BrandAggregateArgs> = {
        [P in keyof T & keyof AggregateBrand]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBrand[P]>
      : GetScalarType<T[P], AggregateBrand[P]>
  }




  export type brandGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: brandWhereInput
    orderBy?: brandOrderByWithAggregationInput | brandOrderByWithAggregationInput[]
    by: BrandScalarFieldEnum[] | BrandScalarFieldEnum
    having?: brandScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BrandCountAggregateInputType | true
    _avg?: BrandAvgAggregateInputType
    _sum?: BrandSumAggregateInputType
    _min?: BrandMinAggregateInputType
    _max?: BrandMaxAggregateInputType
  }

  export type BrandGroupByOutputType = {
    id: number
    name: string
    created_at: Date | null
    _count: BrandCountAggregateOutputType | null
    _avg: BrandAvgAggregateOutputType | null
    _sum: BrandSumAggregateOutputType | null
    _min: BrandMinAggregateOutputType | null
    _max: BrandMaxAggregateOutputType | null
  }

  type GetBrandGroupByPayload<T extends brandGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BrandGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BrandGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BrandGroupByOutputType[P]>
            : GetScalarType<T[P], BrandGroupByOutputType[P]>
        }
      >
    >


  export type brandSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    created_at?: boolean
    subbrands?: boolean | brand$subbrandsArgs<ExtArgs>
    stores?: boolean | brand$storesArgs<ExtArgs>
    channels?: boolean | brand$channelsArgs<ExtArgs>
    categories?: boolean | brand$categoriesArgs<ExtArgs>
    products?: boolean | brand$productsArgs<ExtArgs>
    optiongroups?: boolean | brand$optiongroupsArgs<ExtArgs>
    items?: boolean | brand$itemsArgs<ExtArgs>
    paymenttypes?: boolean | brand$paymenttypesArgs<ExtArgs>
    coupons?: boolean | brand$couponsArgs<ExtArgs>
    _count?: boolean | BrandCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["brand"]>

  export type brandSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    created_at?: boolean
  }, ExtArgs["result"]["brand"]>

  export type brandSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    created_at?: boolean
  }, ExtArgs["result"]["brand"]>

  export type brandSelectScalar = {
    id?: boolean
    name?: boolean
    created_at?: boolean
  }

  export type brandOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "created_at", ExtArgs["result"]["brand"]>
  export type brandInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    subbrands?: boolean | brand$subbrandsArgs<ExtArgs>
    stores?: boolean | brand$storesArgs<ExtArgs>
    channels?: boolean | brand$channelsArgs<ExtArgs>
    categories?: boolean | brand$categoriesArgs<ExtArgs>
    products?: boolean | brand$productsArgs<ExtArgs>
    optiongroups?: boolean | brand$optiongroupsArgs<ExtArgs>
    items?: boolean | brand$itemsArgs<ExtArgs>
    paymenttypes?: boolean | brand$paymenttypesArgs<ExtArgs>
    coupons?: boolean | brand$couponsArgs<ExtArgs>
    _count?: boolean | BrandCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type brandIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type brandIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $brandPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "brand"
    objects: {
      subbrands: Prisma.$subbrandPayload<ExtArgs>[]
      stores: Prisma.$storePayload<ExtArgs>[]
      channels: Prisma.$channelPayload<ExtArgs>[]
      categories: Prisma.$categoryPayload<ExtArgs>[]
      products: Prisma.$productPayload<ExtArgs>[]
      optiongroups: Prisma.$optiongroupPayload<ExtArgs>[]
      items: Prisma.$itemPayload<ExtArgs>[]
      paymenttypes: Prisma.$paymenttypePayload<ExtArgs>[]
      coupons: Prisma.$couponPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      created_at: Date | null
    }, ExtArgs["result"]["brand"]>
    composites: {}
  }

  type brandGetPayload<S extends boolean | null | undefined | brandDefaultArgs> = $Result.GetResult<Prisma.$brandPayload, S>

  type brandCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<brandFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BrandCountAggregateInputType | true
    }

  export interface brandDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['brand'], meta: { name: 'brand' } }
    /**
     * Find zero or one Brand that matches the filter.
     * @param {brandFindUniqueArgs} args - Arguments to find a Brand
     * @example
     * // Get one Brand
     * const brand = await prisma.brand.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends brandFindUniqueArgs>(args: SelectSubset<T, brandFindUniqueArgs<ExtArgs>>): Prisma__brandClient<$Result.GetResult<Prisma.$brandPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Brand that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {brandFindUniqueOrThrowArgs} args - Arguments to find a Brand
     * @example
     * // Get one Brand
     * const brand = await prisma.brand.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends brandFindUniqueOrThrowArgs>(args: SelectSubset<T, brandFindUniqueOrThrowArgs<ExtArgs>>): Prisma__brandClient<$Result.GetResult<Prisma.$brandPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Brand that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {brandFindFirstArgs} args - Arguments to find a Brand
     * @example
     * // Get one Brand
     * const brand = await prisma.brand.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends brandFindFirstArgs>(args?: SelectSubset<T, brandFindFirstArgs<ExtArgs>>): Prisma__brandClient<$Result.GetResult<Prisma.$brandPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Brand that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {brandFindFirstOrThrowArgs} args - Arguments to find a Brand
     * @example
     * // Get one Brand
     * const brand = await prisma.brand.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends brandFindFirstOrThrowArgs>(args?: SelectSubset<T, brandFindFirstOrThrowArgs<ExtArgs>>): Prisma__brandClient<$Result.GetResult<Prisma.$brandPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Brands that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {brandFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Brands
     * const brands = await prisma.brand.findMany()
     * 
     * // Get first 10 Brands
     * const brands = await prisma.brand.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const brandWithIdOnly = await prisma.brand.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends brandFindManyArgs>(args?: SelectSubset<T, brandFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$brandPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Brand.
     * @param {brandCreateArgs} args - Arguments to create a Brand.
     * @example
     * // Create one Brand
     * const Brand = await prisma.brand.create({
     *   data: {
     *     // ... data to create a Brand
     *   }
     * })
     * 
     */
    create<T extends brandCreateArgs>(args: SelectSubset<T, brandCreateArgs<ExtArgs>>): Prisma__brandClient<$Result.GetResult<Prisma.$brandPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Brands.
     * @param {brandCreateManyArgs} args - Arguments to create many Brands.
     * @example
     * // Create many Brands
     * const brand = await prisma.brand.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends brandCreateManyArgs>(args?: SelectSubset<T, brandCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Brands and returns the data saved in the database.
     * @param {brandCreateManyAndReturnArgs} args - Arguments to create many Brands.
     * @example
     * // Create many Brands
     * const brand = await prisma.brand.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Brands and only return the `id`
     * const brandWithIdOnly = await prisma.brand.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends brandCreateManyAndReturnArgs>(args?: SelectSubset<T, brandCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$brandPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Brand.
     * @param {brandDeleteArgs} args - Arguments to delete one Brand.
     * @example
     * // Delete one Brand
     * const Brand = await prisma.brand.delete({
     *   where: {
     *     // ... filter to delete one Brand
     *   }
     * })
     * 
     */
    delete<T extends brandDeleteArgs>(args: SelectSubset<T, brandDeleteArgs<ExtArgs>>): Prisma__brandClient<$Result.GetResult<Prisma.$brandPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Brand.
     * @param {brandUpdateArgs} args - Arguments to update one Brand.
     * @example
     * // Update one Brand
     * const brand = await prisma.brand.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends brandUpdateArgs>(args: SelectSubset<T, brandUpdateArgs<ExtArgs>>): Prisma__brandClient<$Result.GetResult<Prisma.$brandPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Brands.
     * @param {brandDeleteManyArgs} args - Arguments to filter Brands to delete.
     * @example
     * // Delete a few Brands
     * const { count } = await prisma.brand.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends brandDeleteManyArgs>(args?: SelectSubset<T, brandDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Brands.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {brandUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Brands
     * const brand = await prisma.brand.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends brandUpdateManyArgs>(args: SelectSubset<T, brandUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Brands and returns the data updated in the database.
     * @param {brandUpdateManyAndReturnArgs} args - Arguments to update many Brands.
     * @example
     * // Update many Brands
     * const brand = await prisma.brand.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Brands and only return the `id`
     * const brandWithIdOnly = await prisma.brand.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends brandUpdateManyAndReturnArgs>(args: SelectSubset<T, brandUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$brandPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Brand.
     * @param {brandUpsertArgs} args - Arguments to update or create a Brand.
     * @example
     * // Update or create a Brand
     * const brand = await prisma.brand.upsert({
     *   create: {
     *     // ... data to create a Brand
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Brand we want to update
     *   }
     * })
     */
    upsert<T extends brandUpsertArgs>(args: SelectSubset<T, brandUpsertArgs<ExtArgs>>): Prisma__brandClient<$Result.GetResult<Prisma.$brandPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Brands.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {brandCountArgs} args - Arguments to filter Brands to count.
     * @example
     * // Count the number of Brands
     * const count = await prisma.brand.count({
     *   where: {
     *     // ... the filter for the Brands we want to count
     *   }
     * })
    **/
    count<T extends brandCountArgs>(
      args?: Subset<T, brandCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BrandCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Brand.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BrandAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BrandAggregateArgs>(args: Subset<T, BrandAggregateArgs>): Prisma.PrismaPromise<GetBrandAggregateType<T>>

    /**
     * Group by Brand.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {brandGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends brandGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: brandGroupByArgs['orderBy'] }
        : { orderBy?: brandGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, brandGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBrandGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the brand model
   */
  readonly fields: brandFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for brand.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__brandClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    subbrands<T extends brand$subbrandsArgs<ExtArgs> = {}>(args?: Subset<T, brand$subbrandsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$subbrandPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    stores<T extends brand$storesArgs<ExtArgs> = {}>(args?: Subset<T, brand$storesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$storePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    channels<T extends brand$channelsArgs<ExtArgs> = {}>(args?: Subset<T, brand$channelsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$channelPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    categories<T extends brand$categoriesArgs<ExtArgs> = {}>(args?: Subset<T, brand$categoriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$categoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    products<T extends brand$productsArgs<ExtArgs> = {}>(args?: Subset<T, brand$productsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$productPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    optiongroups<T extends brand$optiongroupsArgs<ExtArgs> = {}>(args?: Subset<T, brand$optiongroupsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$optiongroupPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    items<T extends brand$itemsArgs<ExtArgs> = {}>(args?: Subset<T, brand$itemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$itemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    paymenttypes<T extends brand$paymenttypesArgs<ExtArgs> = {}>(args?: Subset<T, brand$paymenttypesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$paymenttypePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    coupons<T extends brand$couponsArgs<ExtArgs> = {}>(args?: Subset<T, brand$couponsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$couponPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the brand model
   */
  interface brandFieldRefs {
    readonly id: FieldRef<"brand", 'Int'>
    readonly name: FieldRef<"brand", 'String'>
    readonly created_at: FieldRef<"brand", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * brand findUnique
   */
  export type brandFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the brand
     */
    select?: brandSelect<ExtArgs> | null
    /**
     * Omit specific fields from the brand
     */
    omit?: brandOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: brandInclude<ExtArgs> | null
    /**
     * Filter, which brand to fetch.
     */
    where: brandWhereUniqueInput
  }

  /**
   * brand findUniqueOrThrow
   */
  export type brandFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the brand
     */
    select?: brandSelect<ExtArgs> | null
    /**
     * Omit specific fields from the brand
     */
    omit?: brandOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: brandInclude<ExtArgs> | null
    /**
     * Filter, which brand to fetch.
     */
    where: brandWhereUniqueInput
  }

  /**
   * brand findFirst
   */
  export type brandFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the brand
     */
    select?: brandSelect<ExtArgs> | null
    /**
     * Omit specific fields from the brand
     */
    omit?: brandOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: brandInclude<ExtArgs> | null
    /**
     * Filter, which brand to fetch.
     */
    where?: brandWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of brands to fetch.
     */
    orderBy?: brandOrderByWithRelationInput | brandOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for brands.
     */
    cursor?: brandWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` brands from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` brands.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of brands.
     */
    distinct?: BrandScalarFieldEnum | BrandScalarFieldEnum[]
  }

  /**
   * brand findFirstOrThrow
   */
  export type brandFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the brand
     */
    select?: brandSelect<ExtArgs> | null
    /**
     * Omit specific fields from the brand
     */
    omit?: brandOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: brandInclude<ExtArgs> | null
    /**
     * Filter, which brand to fetch.
     */
    where?: brandWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of brands to fetch.
     */
    orderBy?: brandOrderByWithRelationInput | brandOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for brands.
     */
    cursor?: brandWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` brands from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` brands.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of brands.
     */
    distinct?: BrandScalarFieldEnum | BrandScalarFieldEnum[]
  }

  /**
   * brand findMany
   */
  export type brandFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the brand
     */
    select?: brandSelect<ExtArgs> | null
    /**
     * Omit specific fields from the brand
     */
    omit?: brandOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: brandInclude<ExtArgs> | null
    /**
     * Filter, which brands to fetch.
     */
    where?: brandWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of brands to fetch.
     */
    orderBy?: brandOrderByWithRelationInput | brandOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing brands.
     */
    cursor?: brandWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` brands from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` brands.
     */
    skip?: number
    distinct?: BrandScalarFieldEnum | BrandScalarFieldEnum[]
  }

  /**
   * brand create
   */
  export type brandCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the brand
     */
    select?: brandSelect<ExtArgs> | null
    /**
     * Omit specific fields from the brand
     */
    omit?: brandOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: brandInclude<ExtArgs> | null
    /**
     * The data needed to create a brand.
     */
    data: XOR<brandCreateInput, brandUncheckedCreateInput>
  }

  /**
   * brand createMany
   */
  export type brandCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many brands.
     */
    data: brandCreateManyInput | brandCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * brand createManyAndReturn
   */
  export type brandCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the brand
     */
    select?: brandSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the brand
     */
    omit?: brandOmit<ExtArgs> | null
    /**
     * The data used to create many brands.
     */
    data: brandCreateManyInput | brandCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * brand update
   */
  export type brandUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the brand
     */
    select?: brandSelect<ExtArgs> | null
    /**
     * Omit specific fields from the brand
     */
    omit?: brandOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: brandInclude<ExtArgs> | null
    /**
     * The data needed to update a brand.
     */
    data: XOR<brandUpdateInput, brandUncheckedUpdateInput>
    /**
     * Choose, which brand to update.
     */
    where: brandWhereUniqueInput
  }

  /**
   * brand updateMany
   */
  export type brandUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update brands.
     */
    data: XOR<brandUpdateManyMutationInput, brandUncheckedUpdateManyInput>
    /**
     * Filter which brands to update
     */
    where?: brandWhereInput
    /**
     * Limit how many brands to update.
     */
    limit?: number
  }

  /**
   * brand updateManyAndReturn
   */
  export type brandUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the brand
     */
    select?: brandSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the brand
     */
    omit?: brandOmit<ExtArgs> | null
    /**
     * The data used to update brands.
     */
    data: XOR<brandUpdateManyMutationInput, brandUncheckedUpdateManyInput>
    /**
     * Filter which brands to update
     */
    where?: brandWhereInput
    /**
     * Limit how many brands to update.
     */
    limit?: number
  }

  /**
   * brand upsert
   */
  export type brandUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the brand
     */
    select?: brandSelect<ExtArgs> | null
    /**
     * Omit specific fields from the brand
     */
    omit?: brandOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: brandInclude<ExtArgs> | null
    /**
     * The filter to search for the brand to update in case it exists.
     */
    where: brandWhereUniqueInput
    /**
     * In case the brand found by the `where` argument doesn't exist, create a new brand with this data.
     */
    create: XOR<brandCreateInput, brandUncheckedCreateInput>
    /**
     * In case the brand was found with the provided `where` argument, update it with this data.
     */
    update: XOR<brandUpdateInput, brandUncheckedUpdateInput>
  }

  /**
   * brand delete
   */
  export type brandDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the brand
     */
    select?: brandSelect<ExtArgs> | null
    /**
     * Omit specific fields from the brand
     */
    omit?: brandOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: brandInclude<ExtArgs> | null
    /**
     * Filter which brand to delete.
     */
    where: brandWhereUniqueInput
  }

  /**
   * brand deleteMany
   */
  export type brandDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which brands to delete
     */
    where?: brandWhereInput
    /**
     * Limit how many brands to delete.
     */
    limit?: number
  }

  /**
   * brand.subbrands
   */
  export type brand$subbrandsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the subbrand
     */
    select?: subbrandSelect<ExtArgs> | null
    /**
     * Omit specific fields from the subbrand
     */
    omit?: subbrandOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: subbrandInclude<ExtArgs> | null
    where?: subbrandWhereInput
    orderBy?: subbrandOrderByWithRelationInput | subbrandOrderByWithRelationInput[]
    cursor?: subbrandWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SubbrandScalarFieldEnum | SubbrandScalarFieldEnum[]
  }

  /**
   * brand.stores
   */
  export type brand$storesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the store
     */
    select?: storeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the store
     */
    omit?: storeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: storeInclude<ExtArgs> | null
    where?: storeWhereInput
    orderBy?: storeOrderByWithRelationInput | storeOrderByWithRelationInput[]
    cursor?: storeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StoreScalarFieldEnum | StoreScalarFieldEnum[]
  }

  /**
   * brand.channels
   */
  export type brand$channelsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the channel
     */
    select?: channelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the channel
     */
    omit?: channelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: channelInclude<ExtArgs> | null
    where?: channelWhereInput
    orderBy?: channelOrderByWithRelationInput | channelOrderByWithRelationInput[]
    cursor?: channelWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ChannelScalarFieldEnum | ChannelScalarFieldEnum[]
  }

  /**
   * brand.categories
   */
  export type brand$categoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the category
     */
    select?: categorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the category
     */
    omit?: categoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: categoryInclude<ExtArgs> | null
    where?: categoryWhereInput
    orderBy?: categoryOrderByWithRelationInput | categoryOrderByWithRelationInput[]
    cursor?: categoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CategoryScalarFieldEnum | CategoryScalarFieldEnum[]
  }

  /**
   * brand.products
   */
  export type brand$productsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the product
     */
    select?: productSelect<ExtArgs> | null
    /**
     * Omit specific fields from the product
     */
    omit?: productOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: productInclude<ExtArgs> | null
    where?: productWhereInput
    orderBy?: productOrderByWithRelationInput | productOrderByWithRelationInput[]
    cursor?: productWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * brand.optiongroups
   */
  export type brand$optiongroupsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the optiongroup
     */
    select?: optiongroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the optiongroup
     */
    omit?: optiongroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: optiongroupInclude<ExtArgs> | null
    where?: optiongroupWhereInput
    orderBy?: optiongroupOrderByWithRelationInput | optiongroupOrderByWithRelationInput[]
    cursor?: optiongroupWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OptiongroupScalarFieldEnum | OptiongroupScalarFieldEnum[]
  }

  /**
   * brand.items
   */
  export type brand$itemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the item
     */
    select?: itemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the item
     */
    omit?: itemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: itemInclude<ExtArgs> | null
    where?: itemWhereInput
    orderBy?: itemOrderByWithRelationInput | itemOrderByWithRelationInput[]
    cursor?: itemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ItemScalarFieldEnum | ItemScalarFieldEnum[]
  }

  /**
   * brand.paymenttypes
   */
  export type brand$paymenttypesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the paymenttype
     */
    select?: paymenttypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the paymenttype
     */
    omit?: paymenttypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: paymenttypeInclude<ExtArgs> | null
    where?: paymenttypeWhereInput
    orderBy?: paymenttypeOrderByWithRelationInput | paymenttypeOrderByWithRelationInput[]
    cursor?: paymenttypeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PaymenttypeScalarFieldEnum | PaymenttypeScalarFieldEnum[]
  }

  /**
   * brand.coupons
   */
  export type brand$couponsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the coupon
     */
    select?: couponSelect<ExtArgs> | null
    /**
     * Omit specific fields from the coupon
     */
    omit?: couponOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: couponInclude<ExtArgs> | null
    where?: couponWhereInput
    orderBy?: couponOrderByWithRelationInput | couponOrderByWithRelationInput[]
    cursor?: couponWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CouponScalarFieldEnum | CouponScalarFieldEnum[]
  }

  /**
   * brand without action
   */
  export type brandDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the brand
     */
    select?: brandSelect<ExtArgs> | null
    /**
     * Omit specific fields from the brand
     */
    omit?: brandOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: brandInclude<ExtArgs> | null
  }


  /**
   * Model subbrand
   */

  export type AggregateSubbrand = {
    _count: SubbrandCountAggregateOutputType | null
    _avg: SubbrandAvgAggregateOutputType | null
    _sum: SubbrandSumAggregateOutputType | null
    _min: SubbrandMinAggregateOutputType | null
    _max: SubbrandMaxAggregateOutputType | null
  }

  export type SubbrandAvgAggregateOutputType = {
    id: number | null
    brand_id: number | null
  }

  export type SubbrandSumAggregateOutputType = {
    id: number | null
    brand_id: number | null
  }

  export type SubbrandMinAggregateOutputType = {
    id: number | null
    brand_id: number | null
    name: string | null
    created_at: Date | null
  }

  export type SubbrandMaxAggregateOutputType = {
    id: number | null
    brand_id: number | null
    name: string | null
    created_at: Date | null
  }

  export type SubbrandCountAggregateOutputType = {
    id: number
    brand_id: number
    name: number
    created_at: number
    _all: number
  }


  export type SubbrandAvgAggregateInputType = {
    id?: true
    brand_id?: true
  }

  export type SubbrandSumAggregateInputType = {
    id?: true
    brand_id?: true
  }

  export type SubbrandMinAggregateInputType = {
    id?: true
    brand_id?: true
    name?: true
    created_at?: true
  }

  export type SubbrandMaxAggregateInputType = {
    id?: true
    brand_id?: true
    name?: true
    created_at?: true
  }

  export type SubbrandCountAggregateInputType = {
    id?: true
    brand_id?: true
    name?: true
    created_at?: true
    _all?: true
  }

  export type SubbrandAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which subbrand to aggregate.
     */
    where?: subbrandWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of subbrands to fetch.
     */
    orderBy?: subbrandOrderByWithRelationInput | subbrandOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: subbrandWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` subbrands from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` subbrands.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned subbrands
    **/
    _count?: true | SubbrandCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SubbrandAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SubbrandSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SubbrandMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SubbrandMaxAggregateInputType
  }

  export type GetSubbrandAggregateType<T extends SubbrandAggregateArgs> = {
        [P in keyof T & keyof AggregateSubbrand]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSubbrand[P]>
      : GetScalarType<T[P], AggregateSubbrand[P]>
  }




  export type subbrandGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: subbrandWhereInput
    orderBy?: subbrandOrderByWithAggregationInput | subbrandOrderByWithAggregationInput[]
    by: SubbrandScalarFieldEnum[] | SubbrandScalarFieldEnum
    having?: subbrandScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SubbrandCountAggregateInputType | true
    _avg?: SubbrandAvgAggregateInputType
    _sum?: SubbrandSumAggregateInputType
    _min?: SubbrandMinAggregateInputType
    _max?: SubbrandMaxAggregateInputType
  }

  export type SubbrandGroupByOutputType = {
    id: number
    brand_id: number
    name: string
    created_at: Date | null
    _count: SubbrandCountAggregateOutputType | null
    _avg: SubbrandAvgAggregateOutputType | null
    _sum: SubbrandSumAggregateOutputType | null
    _min: SubbrandMinAggregateOutputType | null
    _max: SubbrandMaxAggregateOutputType | null
  }

  type GetSubbrandGroupByPayload<T extends subbrandGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SubbrandGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SubbrandGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SubbrandGroupByOutputType[P]>
            : GetScalarType<T[P], SubbrandGroupByOutputType[P]>
        }
      >
    >


  export type subbrandSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    brand_id?: boolean
    name?: boolean
    created_at?: boolean
    brand?: boolean | brandDefaultArgs<ExtArgs>
    stores?: boolean | subbrand$storesArgs<ExtArgs>
    categories?: boolean | subbrand$categoriesArgs<ExtArgs>
    products?: boolean | subbrand$productsArgs<ExtArgs>
    optiongroups?: boolean | subbrand$optiongroupsArgs<ExtArgs>
    items?: boolean | subbrand$itemsArgs<ExtArgs>
    customers?: boolean | subbrand$customersArgs<ExtArgs>
    sales?: boolean | subbrand$salesArgs<ExtArgs>
    _count?: boolean | SubbrandCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["subbrand"]>

  export type subbrandSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    brand_id?: boolean
    name?: boolean
    created_at?: boolean
    brand?: boolean | brandDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["subbrand"]>

  export type subbrandSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    brand_id?: boolean
    name?: boolean
    created_at?: boolean
    brand?: boolean | brandDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["subbrand"]>

  export type subbrandSelectScalar = {
    id?: boolean
    brand_id?: boolean
    name?: boolean
    created_at?: boolean
  }

  export type subbrandOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "brand_id" | "name" | "created_at", ExtArgs["result"]["subbrand"]>
  export type subbrandInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    brand?: boolean | brandDefaultArgs<ExtArgs>
    stores?: boolean | subbrand$storesArgs<ExtArgs>
    categories?: boolean | subbrand$categoriesArgs<ExtArgs>
    products?: boolean | subbrand$productsArgs<ExtArgs>
    optiongroups?: boolean | subbrand$optiongroupsArgs<ExtArgs>
    items?: boolean | subbrand$itemsArgs<ExtArgs>
    customers?: boolean | subbrand$customersArgs<ExtArgs>
    sales?: boolean | subbrand$salesArgs<ExtArgs>
    _count?: boolean | SubbrandCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type subbrandIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    brand?: boolean | brandDefaultArgs<ExtArgs>
  }
  export type subbrandIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    brand?: boolean | brandDefaultArgs<ExtArgs>
  }

  export type $subbrandPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "subbrand"
    objects: {
      brand: Prisma.$brandPayload<ExtArgs>
      stores: Prisma.$storePayload<ExtArgs>[]
      categories: Prisma.$categoryPayload<ExtArgs>[]
      products: Prisma.$productPayload<ExtArgs>[]
      optiongroups: Prisma.$optiongroupPayload<ExtArgs>[]
      items: Prisma.$itemPayload<ExtArgs>[]
      customers: Prisma.$customerPayload<ExtArgs>[]
      sales: Prisma.$salePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      brand_id: number
      name: string
      created_at: Date | null
    }, ExtArgs["result"]["subbrand"]>
    composites: {}
  }

  type subbrandGetPayload<S extends boolean | null | undefined | subbrandDefaultArgs> = $Result.GetResult<Prisma.$subbrandPayload, S>

  type subbrandCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<subbrandFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SubbrandCountAggregateInputType | true
    }

  export interface subbrandDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['subbrand'], meta: { name: 'subbrand' } }
    /**
     * Find zero or one Subbrand that matches the filter.
     * @param {subbrandFindUniqueArgs} args - Arguments to find a Subbrand
     * @example
     * // Get one Subbrand
     * const subbrand = await prisma.subbrand.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends subbrandFindUniqueArgs>(args: SelectSubset<T, subbrandFindUniqueArgs<ExtArgs>>): Prisma__subbrandClient<$Result.GetResult<Prisma.$subbrandPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Subbrand that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {subbrandFindUniqueOrThrowArgs} args - Arguments to find a Subbrand
     * @example
     * // Get one Subbrand
     * const subbrand = await prisma.subbrand.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends subbrandFindUniqueOrThrowArgs>(args: SelectSubset<T, subbrandFindUniqueOrThrowArgs<ExtArgs>>): Prisma__subbrandClient<$Result.GetResult<Prisma.$subbrandPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Subbrand that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {subbrandFindFirstArgs} args - Arguments to find a Subbrand
     * @example
     * // Get one Subbrand
     * const subbrand = await prisma.subbrand.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends subbrandFindFirstArgs>(args?: SelectSubset<T, subbrandFindFirstArgs<ExtArgs>>): Prisma__subbrandClient<$Result.GetResult<Prisma.$subbrandPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Subbrand that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {subbrandFindFirstOrThrowArgs} args - Arguments to find a Subbrand
     * @example
     * // Get one Subbrand
     * const subbrand = await prisma.subbrand.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends subbrandFindFirstOrThrowArgs>(args?: SelectSubset<T, subbrandFindFirstOrThrowArgs<ExtArgs>>): Prisma__subbrandClient<$Result.GetResult<Prisma.$subbrandPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Subbrands that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {subbrandFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Subbrands
     * const subbrands = await prisma.subbrand.findMany()
     * 
     * // Get first 10 Subbrands
     * const subbrands = await prisma.subbrand.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const subbrandWithIdOnly = await prisma.subbrand.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends subbrandFindManyArgs>(args?: SelectSubset<T, subbrandFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$subbrandPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Subbrand.
     * @param {subbrandCreateArgs} args - Arguments to create a Subbrand.
     * @example
     * // Create one Subbrand
     * const Subbrand = await prisma.subbrand.create({
     *   data: {
     *     // ... data to create a Subbrand
     *   }
     * })
     * 
     */
    create<T extends subbrandCreateArgs>(args: SelectSubset<T, subbrandCreateArgs<ExtArgs>>): Prisma__subbrandClient<$Result.GetResult<Prisma.$subbrandPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Subbrands.
     * @param {subbrandCreateManyArgs} args - Arguments to create many Subbrands.
     * @example
     * // Create many Subbrands
     * const subbrand = await prisma.subbrand.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends subbrandCreateManyArgs>(args?: SelectSubset<T, subbrandCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Subbrands and returns the data saved in the database.
     * @param {subbrandCreateManyAndReturnArgs} args - Arguments to create many Subbrands.
     * @example
     * // Create many Subbrands
     * const subbrand = await prisma.subbrand.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Subbrands and only return the `id`
     * const subbrandWithIdOnly = await prisma.subbrand.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends subbrandCreateManyAndReturnArgs>(args?: SelectSubset<T, subbrandCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$subbrandPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Subbrand.
     * @param {subbrandDeleteArgs} args - Arguments to delete one Subbrand.
     * @example
     * // Delete one Subbrand
     * const Subbrand = await prisma.subbrand.delete({
     *   where: {
     *     // ... filter to delete one Subbrand
     *   }
     * })
     * 
     */
    delete<T extends subbrandDeleteArgs>(args: SelectSubset<T, subbrandDeleteArgs<ExtArgs>>): Prisma__subbrandClient<$Result.GetResult<Prisma.$subbrandPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Subbrand.
     * @param {subbrandUpdateArgs} args - Arguments to update one Subbrand.
     * @example
     * // Update one Subbrand
     * const subbrand = await prisma.subbrand.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends subbrandUpdateArgs>(args: SelectSubset<T, subbrandUpdateArgs<ExtArgs>>): Prisma__subbrandClient<$Result.GetResult<Prisma.$subbrandPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Subbrands.
     * @param {subbrandDeleteManyArgs} args - Arguments to filter Subbrands to delete.
     * @example
     * // Delete a few Subbrands
     * const { count } = await prisma.subbrand.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends subbrandDeleteManyArgs>(args?: SelectSubset<T, subbrandDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Subbrands.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {subbrandUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Subbrands
     * const subbrand = await prisma.subbrand.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends subbrandUpdateManyArgs>(args: SelectSubset<T, subbrandUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Subbrands and returns the data updated in the database.
     * @param {subbrandUpdateManyAndReturnArgs} args - Arguments to update many Subbrands.
     * @example
     * // Update many Subbrands
     * const subbrand = await prisma.subbrand.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Subbrands and only return the `id`
     * const subbrandWithIdOnly = await prisma.subbrand.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends subbrandUpdateManyAndReturnArgs>(args: SelectSubset<T, subbrandUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$subbrandPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Subbrand.
     * @param {subbrandUpsertArgs} args - Arguments to update or create a Subbrand.
     * @example
     * // Update or create a Subbrand
     * const subbrand = await prisma.subbrand.upsert({
     *   create: {
     *     // ... data to create a Subbrand
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Subbrand we want to update
     *   }
     * })
     */
    upsert<T extends subbrandUpsertArgs>(args: SelectSubset<T, subbrandUpsertArgs<ExtArgs>>): Prisma__subbrandClient<$Result.GetResult<Prisma.$subbrandPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Subbrands.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {subbrandCountArgs} args - Arguments to filter Subbrands to count.
     * @example
     * // Count the number of Subbrands
     * const count = await prisma.subbrand.count({
     *   where: {
     *     // ... the filter for the Subbrands we want to count
     *   }
     * })
    **/
    count<T extends subbrandCountArgs>(
      args?: Subset<T, subbrandCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SubbrandCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Subbrand.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubbrandAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SubbrandAggregateArgs>(args: Subset<T, SubbrandAggregateArgs>): Prisma.PrismaPromise<GetSubbrandAggregateType<T>>

    /**
     * Group by Subbrand.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {subbrandGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends subbrandGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: subbrandGroupByArgs['orderBy'] }
        : { orderBy?: subbrandGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, subbrandGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSubbrandGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the subbrand model
   */
  readonly fields: subbrandFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for subbrand.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__subbrandClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    brand<T extends brandDefaultArgs<ExtArgs> = {}>(args?: Subset<T, brandDefaultArgs<ExtArgs>>): Prisma__brandClient<$Result.GetResult<Prisma.$brandPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    stores<T extends subbrand$storesArgs<ExtArgs> = {}>(args?: Subset<T, subbrand$storesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$storePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    categories<T extends subbrand$categoriesArgs<ExtArgs> = {}>(args?: Subset<T, subbrand$categoriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$categoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    products<T extends subbrand$productsArgs<ExtArgs> = {}>(args?: Subset<T, subbrand$productsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$productPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    optiongroups<T extends subbrand$optiongroupsArgs<ExtArgs> = {}>(args?: Subset<T, subbrand$optiongroupsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$optiongroupPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    items<T extends subbrand$itemsArgs<ExtArgs> = {}>(args?: Subset<T, subbrand$itemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$itemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    customers<T extends subbrand$customersArgs<ExtArgs> = {}>(args?: Subset<T, subbrand$customersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$customerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    sales<T extends subbrand$salesArgs<ExtArgs> = {}>(args?: Subset<T, subbrand$salesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$salePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the subbrand model
   */
  interface subbrandFieldRefs {
    readonly id: FieldRef<"subbrand", 'Int'>
    readonly brand_id: FieldRef<"subbrand", 'Int'>
    readonly name: FieldRef<"subbrand", 'String'>
    readonly created_at: FieldRef<"subbrand", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * subbrand findUnique
   */
  export type subbrandFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the subbrand
     */
    select?: subbrandSelect<ExtArgs> | null
    /**
     * Omit specific fields from the subbrand
     */
    omit?: subbrandOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: subbrandInclude<ExtArgs> | null
    /**
     * Filter, which subbrand to fetch.
     */
    where: subbrandWhereUniqueInput
  }

  /**
   * subbrand findUniqueOrThrow
   */
  export type subbrandFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the subbrand
     */
    select?: subbrandSelect<ExtArgs> | null
    /**
     * Omit specific fields from the subbrand
     */
    omit?: subbrandOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: subbrandInclude<ExtArgs> | null
    /**
     * Filter, which subbrand to fetch.
     */
    where: subbrandWhereUniqueInput
  }

  /**
   * subbrand findFirst
   */
  export type subbrandFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the subbrand
     */
    select?: subbrandSelect<ExtArgs> | null
    /**
     * Omit specific fields from the subbrand
     */
    omit?: subbrandOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: subbrandInclude<ExtArgs> | null
    /**
     * Filter, which subbrand to fetch.
     */
    where?: subbrandWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of subbrands to fetch.
     */
    orderBy?: subbrandOrderByWithRelationInput | subbrandOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for subbrands.
     */
    cursor?: subbrandWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` subbrands from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` subbrands.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of subbrands.
     */
    distinct?: SubbrandScalarFieldEnum | SubbrandScalarFieldEnum[]
  }

  /**
   * subbrand findFirstOrThrow
   */
  export type subbrandFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the subbrand
     */
    select?: subbrandSelect<ExtArgs> | null
    /**
     * Omit specific fields from the subbrand
     */
    omit?: subbrandOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: subbrandInclude<ExtArgs> | null
    /**
     * Filter, which subbrand to fetch.
     */
    where?: subbrandWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of subbrands to fetch.
     */
    orderBy?: subbrandOrderByWithRelationInput | subbrandOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for subbrands.
     */
    cursor?: subbrandWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` subbrands from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` subbrands.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of subbrands.
     */
    distinct?: SubbrandScalarFieldEnum | SubbrandScalarFieldEnum[]
  }

  /**
   * subbrand findMany
   */
  export type subbrandFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the subbrand
     */
    select?: subbrandSelect<ExtArgs> | null
    /**
     * Omit specific fields from the subbrand
     */
    omit?: subbrandOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: subbrandInclude<ExtArgs> | null
    /**
     * Filter, which subbrands to fetch.
     */
    where?: subbrandWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of subbrands to fetch.
     */
    orderBy?: subbrandOrderByWithRelationInput | subbrandOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing subbrands.
     */
    cursor?: subbrandWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` subbrands from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` subbrands.
     */
    skip?: number
    distinct?: SubbrandScalarFieldEnum | SubbrandScalarFieldEnum[]
  }

  /**
   * subbrand create
   */
  export type subbrandCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the subbrand
     */
    select?: subbrandSelect<ExtArgs> | null
    /**
     * Omit specific fields from the subbrand
     */
    omit?: subbrandOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: subbrandInclude<ExtArgs> | null
    /**
     * The data needed to create a subbrand.
     */
    data: XOR<subbrandCreateInput, subbrandUncheckedCreateInput>
  }

  /**
   * subbrand createMany
   */
  export type subbrandCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many subbrands.
     */
    data: subbrandCreateManyInput | subbrandCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * subbrand createManyAndReturn
   */
  export type subbrandCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the subbrand
     */
    select?: subbrandSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the subbrand
     */
    omit?: subbrandOmit<ExtArgs> | null
    /**
     * The data used to create many subbrands.
     */
    data: subbrandCreateManyInput | subbrandCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: subbrandIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * subbrand update
   */
  export type subbrandUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the subbrand
     */
    select?: subbrandSelect<ExtArgs> | null
    /**
     * Omit specific fields from the subbrand
     */
    omit?: subbrandOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: subbrandInclude<ExtArgs> | null
    /**
     * The data needed to update a subbrand.
     */
    data: XOR<subbrandUpdateInput, subbrandUncheckedUpdateInput>
    /**
     * Choose, which subbrand to update.
     */
    where: subbrandWhereUniqueInput
  }

  /**
   * subbrand updateMany
   */
  export type subbrandUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update subbrands.
     */
    data: XOR<subbrandUpdateManyMutationInput, subbrandUncheckedUpdateManyInput>
    /**
     * Filter which subbrands to update
     */
    where?: subbrandWhereInput
    /**
     * Limit how many subbrands to update.
     */
    limit?: number
  }

  /**
   * subbrand updateManyAndReturn
   */
  export type subbrandUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the subbrand
     */
    select?: subbrandSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the subbrand
     */
    omit?: subbrandOmit<ExtArgs> | null
    /**
     * The data used to update subbrands.
     */
    data: XOR<subbrandUpdateManyMutationInput, subbrandUncheckedUpdateManyInput>
    /**
     * Filter which subbrands to update
     */
    where?: subbrandWhereInput
    /**
     * Limit how many subbrands to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: subbrandIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * subbrand upsert
   */
  export type subbrandUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the subbrand
     */
    select?: subbrandSelect<ExtArgs> | null
    /**
     * Omit specific fields from the subbrand
     */
    omit?: subbrandOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: subbrandInclude<ExtArgs> | null
    /**
     * The filter to search for the subbrand to update in case it exists.
     */
    where: subbrandWhereUniqueInput
    /**
     * In case the subbrand found by the `where` argument doesn't exist, create a new subbrand with this data.
     */
    create: XOR<subbrandCreateInput, subbrandUncheckedCreateInput>
    /**
     * In case the subbrand was found with the provided `where` argument, update it with this data.
     */
    update: XOR<subbrandUpdateInput, subbrandUncheckedUpdateInput>
  }

  /**
   * subbrand delete
   */
  export type subbrandDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the subbrand
     */
    select?: subbrandSelect<ExtArgs> | null
    /**
     * Omit specific fields from the subbrand
     */
    omit?: subbrandOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: subbrandInclude<ExtArgs> | null
    /**
     * Filter which subbrand to delete.
     */
    where: subbrandWhereUniqueInput
  }

  /**
   * subbrand deleteMany
   */
  export type subbrandDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which subbrands to delete
     */
    where?: subbrandWhereInput
    /**
     * Limit how many subbrands to delete.
     */
    limit?: number
  }

  /**
   * subbrand.stores
   */
  export type subbrand$storesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the store
     */
    select?: storeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the store
     */
    omit?: storeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: storeInclude<ExtArgs> | null
    where?: storeWhereInput
    orderBy?: storeOrderByWithRelationInput | storeOrderByWithRelationInput[]
    cursor?: storeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StoreScalarFieldEnum | StoreScalarFieldEnum[]
  }

  /**
   * subbrand.categories
   */
  export type subbrand$categoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the category
     */
    select?: categorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the category
     */
    omit?: categoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: categoryInclude<ExtArgs> | null
    where?: categoryWhereInput
    orderBy?: categoryOrderByWithRelationInput | categoryOrderByWithRelationInput[]
    cursor?: categoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CategoryScalarFieldEnum | CategoryScalarFieldEnum[]
  }

  /**
   * subbrand.products
   */
  export type subbrand$productsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the product
     */
    select?: productSelect<ExtArgs> | null
    /**
     * Omit specific fields from the product
     */
    omit?: productOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: productInclude<ExtArgs> | null
    where?: productWhereInput
    orderBy?: productOrderByWithRelationInput | productOrderByWithRelationInput[]
    cursor?: productWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * subbrand.optiongroups
   */
  export type subbrand$optiongroupsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the optiongroup
     */
    select?: optiongroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the optiongroup
     */
    omit?: optiongroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: optiongroupInclude<ExtArgs> | null
    where?: optiongroupWhereInput
    orderBy?: optiongroupOrderByWithRelationInput | optiongroupOrderByWithRelationInput[]
    cursor?: optiongroupWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OptiongroupScalarFieldEnum | OptiongroupScalarFieldEnum[]
  }

  /**
   * subbrand.items
   */
  export type subbrand$itemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the item
     */
    select?: itemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the item
     */
    omit?: itemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: itemInclude<ExtArgs> | null
    where?: itemWhereInput
    orderBy?: itemOrderByWithRelationInput | itemOrderByWithRelationInput[]
    cursor?: itemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ItemScalarFieldEnum | ItemScalarFieldEnum[]
  }

  /**
   * subbrand.customers
   */
  export type subbrand$customersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the customer
     */
    select?: customerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the customer
     */
    omit?: customerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: customerInclude<ExtArgs> | null
    where?: customerWhereInput
    orderBy?: customerOrderByWithRelationInput | customerOrderByWithRelationInput[]
    cursor?: customerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CustomerScalarFieldEnum | CustomerScalarFieldEnum[]
  }

  /**
   * subbrand.sales
   */
  export type subbrand$salesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sale
     */
    select?: saleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sale
     */
    omit?: saleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: saleInclude<ExtArgs> | null
    where?: saleWhereInput
    orderBy?: saleOrderByWithRelationInput | saleOrderByWithRelationInput[]
    cursor?: saleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SaleScalarFieldEnum | SaleScalarFieldEnum[]
  }

  /**
   * subbrand without action
   */
  export type subbrandDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the subbrand
     */
    select?: subbrandSelect<ExtArgs> | null
    /**
     * Omit specific fields from the subbrand
     */
    omit?: subbrandOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: subbrandInclude<ExtArgs> | null
  }


  /**
   * Model store
   */

  export type AggregateStore = {
    _count: StoreCountAggregateOutputType | null
    _avg: StoreAvgAggregateOutputType | null
    _sum: StoreSumAggregateOutputType | null
    _min: StoreMinAggregateOutputType | null
    _max: StoreMaxAggregateOutputType | null
  }

  export type StoreAvgAggregateOutputType = {
    id: number | null
    brand_id: number | null
    sub_brand_id: number | null
    address_number: number | null
    latitude: Decimal | null
    longitude: Decimal | null
  }

  export type StoreSumAggregateOutputType = {
    id: number | null
    brand_id: number | null
    sub_brand_id: number | null
    address_number: number | null
    latitude: Decimal | null
    longitude: Decimal | null
  }

  export type StoreMinAggregateOutputType = {
    id: number | null
    brand_id: number | null
    sub_brand_id: number | null
    name: string | null
    city: string | null
    state: string | null
    district: string | null
    address_street: string | null
    address_number: number | null
    zipcode: string | null
    latitude: Decimal | null
    longitude: Decimal | null
    is_active: boolean | null
    is_own: boolean | null
    is_holding: boolean | null
    creation_date: Date | null
    created_at: Date | null
  }

  export type StoreMaxAggregateOutputType = {
    id: number | null
    brand_id: number | null
    sub_brand_id: number | null
    name: string | null
    city: string | null
    state: string | null
    district: string | null
    address_street: string | null
    address_number: number | null
    zipcode: string | null
    latitude: Decimal | null
    longitude: Decimal | null
    is_active: boolean | null
    is_own: boolean | null
    is_holding: boolean | null
    creation_date: Date | null
    created_at: Date | null
  }

  export type StoreCountAggregateOutputType = {
    id: number
    brand_id: number
    sub_brand_id: number
    name: number
    city: number
    state: number
    district: number
    address_street: number
    address_number: number
    zipcode: number
    latitude: number
    longitude: number
    is_active: number
    is_own: number
    is_holding: number
    creation_date: number
    created_at: number
    _all: number
  }


  export type StoreAvgAggregateInputType = {
    id?: true
    brand_id?: true
    sub_brand_id?: true
    address_number?: true
    latitude?: true
    longitude?: true
  }

  export type StoreSumAggregateInputType = {
    id?: true
    brand_id?: true
    sub_brand_id?: true
    address_number?: true
    latitude?: true
    longitude?: true
  }

  export type StoreMinAggregateInputType = {
    id?: true
    brand_id?: true
    sub_brand_id?: true
    name?: true
    city?: true
    state?: true
    district?: true
    address_street?: true
    address_number?: true
    zipcode?: true
    latitude?: true
    longitude?: true
    is_active?: true
    is_own?: true
    is_holding?: true
    creation_date?: true
    created_at?: true
  }

  export type StoreMaxAggregateInputType = {
    id?: true
    brand_id?: true
    sub_brand_id?: true
    name?: true
    city?: true
    state?: true
    district?: true
    address_street?: true
    address_number?: true
    zipcode?: true
    latitude?: true
    longitude?: true
    is_active?: true
    is_own?: true
    is_holding?: true
    creation_date?: true
    created_at?: true
  }

  export type StoreCountAggregateInputType = {
    id?: true
    brand_id?: true
    sub_brand_id?: true
    name?: true
    city?: true
    state?: true
    district?: true
    address_street?: true
    address_number?: true
    zipcode?: true
    latitude?: true
    longitude?: true
    is_active?: true
    is_own?: true
    is_holding?: true
    creation_date?: true
    created_at?: true
    _all?: true
  }

  export type StoreAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which store to aggregate.
     */
    where?: storeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of stores to fetch.
     */
    orderBy?: storeOrderByWithRelationInput | storeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: storeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` stores from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` stores.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned stores
    **/
    _count?: true | StoreCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: StoreAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: StoreSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StoreMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StoreMaxAggregateInputType
  }

  export type GetStoreAggregateType<T extends StoreAggregateArgs> = {
        [P in keyof T & keyof AggregateStore]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStore[P]>
      : GetScalarType<T[P], AggregateStore[P]>
  }




  export type storeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: storeWhereInput
    orderBy?: storeOrderByWithAggregationInput | storeOrderByWithAggregationInput[]
    by: StoreScalarFieldEnum[] | StoreScalarFieldEnum
    having?: storeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StoreCountAggregateInputType | true
    _avg?: StoreAvgAggregateInputType
    _sum?: StoreSumAggregateInputType
    _min?: StoreMinAggregateInputType
    _max?: StoreMaxAggregateInputType
  }

  export type StoreGroupByOutputType = {
    id: number
    brand_id: number
    sub_brand_id: number | null
    name: string
    city: string | null
    state: string | null
    district: string | null
    address_street: string | null
    address_number: number | null
    zipcode: string | null
    latitude: Decimal | null
    longitude: Decimal | null
    is_active: boolean | null
    is_own: boolean | null
    is_holding: boolean | null
    creation_date: Date | null
    created_at: Date | null
    _count: StoreCountAggregateOutputType | null
    _avg: StoreAvgAggregateOutputType | null
    _sum: StoreSumAggregateOutputType | null
    _min: StoreMinAggregateOutputType | null
    _max: StoreMaxAggregateOutputType | null
  }

  type GetStoreGroupByPayload<T extends storeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StoreGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StoreGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StoreGroupByOutputType[P]>
            : GetScalarType<T[P], StoreGroupByOutputType[P]>
        }
      >
    >


  export type storeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    brand_id?: boolean
    sub_brand_id?: boolean
    name?: boolean
    city?: boolean
    state?: boolean
    district?: boolean
    address_street?: boolean
    address_number?: boolean
    zipcode?: boolean
    latitude?: boolean
    longitude?: boolean
    is_active?: boolean
    is_own?: boolean
    is_holding?: boolean
    creation_date?: boolean
    created_at?: boolean
    brand?: boolean | brandDefaultArgs<ExtArgs>
    subbrand?: boolean | store$subbrandArgs<ExtArgs>
    customers?: boolean | store$customersArgs<ExtArgs>
    sales?: boolean | store$salesArgs<ExtArgs>
    _count?: boolean | StoreCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["store"]>

  export type storeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    brand_id?: boolean
    sub_brand_id?: boolean
    name?: boolean
    city?: boolean
    state?: boolean
    district?: boolean
    address_street?: boolean
    address_number?: boolean
    zipcode?: boolean
    latitude?: boolean
    longitude?: boolean
    is_active?: boolean
    is_own?: boolean
    is_holding?: boolean
    creation_date?: boolean
    created_at?: boolean
    brand?: boolean | brandDefaultArgs<ExtArgs>
    subbrand?: boolean | store$subbrandArgs<ExtArgs>
  }, ExtArgs["result"]["store"]>

  export type storeSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    brand_id?: boolean
    sub_brand_id?: boolean
    name?: boolean
    city?: boolean
    state?: boolean
    district?: boolean
    address_street?: boolean
    address_number?: boolean
    zipcode?: boolean
    latitude?: boolean
    longitude?: boolean
    is_active?: boolean
    is_own?: boolean
    is_holding?: boolean
    creation_date?: boolean
    created_at?: boolean
    brand?: boolean | brandDefaultArgs<ExtArgs>
    subbrand?: boolean | store$subbrandArgs<ExtArgs>
  }, ExtArgs["result"]["store"]>

  export type storeSelectScalar = {
    id?: boolean
    brand_id?: boolean
    sub_brand_id?: boolean
    name?: boolean
    city?: boolean
    state?: boolean
    district?: boolean
    address_street?: boolean
    address_number?: boolean
    zipcode?: boolean
    latitude?: boolean
    longitude?: boolean
    is_active?: boolean
    is_own?: boolean
    is_holding?: boolean
    creation_date?: boolean
    created_at?: boolean
  }

  export type storeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "brand_id" | "sub_brand_id" | "name" | "city" | "state" | "district" | "address_street" | "address_number" | "zipcode" | "latitude" | "longitude" | "is_active" | "is_own" | "is_holding" | "creation_date" | "created_at", ExtArgs["result"]["store"]>
  export type storeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    brand?: boolean | brandDefaultArgs<ExtArgs>
    subbrand?: boolean | store$subbrandArgs<ExtArgs>
    customers?: boolean | store$customersArgs<ExtArgs>
    sales?: boolean | store$salesArgs<ExtArgs>
    _count?: boolean | StoreCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type storeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    brand?: boolean | brandDefaultArgs<ExtArgs>
    subbrand?: boolean | store$subbrandArgs<ExtArgs>
  }
  export type storeIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    brand?: boolean | brandDefaultArgs<ExtArgs>
    subbrand?: boolean | store$subbrandArgs<ExtArgs>
  }

  export type $storePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "store"
    objects: {
      brand: Prisma.$brandPayload<ExtArgs>
      subbrand: Prisma.$subbrandPayload<ExtArgs> | null
      customers: Prisma.$customerPayload<ExtArgs>[]
      sales: Prisma.$salePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      brand_id: number
      sub_brand_id: number | null
      name: string
      city: string | null
      state: string | null
      district: string | null
      address_street: string | null
      address_number: number | null
      zipcode: string | null
      latitude: Prisma.Decimal | null
      longitude: Prisma.Decimal | null
      is_active: boolean | null
      is_own: boolean | null
      is_holding: boolean | null
      creation_date: Date | null
      created_at: Date | null
    }, ExtArgs["result"]["store"]>
    composites: {}
  }

  type storeGetPayload<S extends boolean | null | undefined | storeDefaultArgs> = $Result.GetResult<Prisma.$storePayload, S>

  type storeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<storeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: StoreCountAggregateInputType | true
    }

  export interface storeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['store'], meta: { name: 'store' } }
    /**
     * Find zero or one Store that matches the filter.
     * @param {storeFindUniqueArgs} args - Arguments to find a Store
     * @example
     * // Get one Store
     * const store = await prisma.store.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends storeFindUniqueArgs>(args: SelectSubset<T, storeFindUniqueArgs<ExtArgs>>): Prisma__storeClient<$Result.GetResult<Prisma.$storePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Store that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {storeFindUniqueOrThrowArgs} args - Arguments to find a Store
     * @example
     * // Get one Store
     * const store = await prisma.store.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends storeFindUniqueOrThrowArgs>(args: SelectSubset<T, storeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__storeClient<$Result.GetResult<Prisma.$storePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Store that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {storeFindFirstArgs} args - Arguments to find a Store
     * @example
     * // Get one Store
     * const store = await prisma.store.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends storeFindFirstArgs>(args?: SelectSubset<T, storeFindFirstArgs<ExtArgs>>): Prisma__storeClient<$Result.GetResult<Prisma.$storePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Store that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {storeFindFirstOrThrowArgs} args - Arguments to find a Store
     * @example
     * // Get one Store
     * const store = await prisma.store.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends storeFindFirstOrThrowArgs>(args?: SelectSubset<T, storeFindFirstOrThrowArgs<ExtArgs>>): Prisma__storeClient<$Result.GetResult<Prisma.$storePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Stores that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {storeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Stores
     * const stores = await prisma.store.findMany()
     * 
     * // Get first 10 Stores
     * const stores = await prisma.store.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const storeWithIdOnly = await prisma.store.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends storeFindManyArgs>(args?: SelectSubset<T, storeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$storePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Store.
     * @param {storeCreateArgs} args - Arguments to create a Store.
     * @example
     * // Create one Store
     * const Store = await prisma.store.create({
     *   data: {
     *     // ... data to create a Store
     *   }
     * })
     * 
     */
    create<T extends storeCreateArgs>(args: SelectSubset<T, storeCreateArgs<ExtArgs>>): Prisma__storeClient<$Result.GetResult<Prisma.$storePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Stores.
     * @param {storeCreateManyArgs} args - Arguments to create many Stores.
     * @example
     * // Create many Stores
     * const store = await prisma.store.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends storeCreateManyArgs>(args?: SelectSubset<T, storeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Stores and returns the data saved in the database.
     * @param {storeCreateManyAndReturnArgs} args - Arguments to create many Stores.
     * @example
     * // Create many Stores
     * const store = await prisma.store.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Stores and only return the `id`
     * const storeWithIdOnly = await prisma.store.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends storeCreateManyAndReturnArgs>(args?: SelectSubset<T, storeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$storePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Store.
     * @param {storeDeleteArgs} args - Arguments to delete one Store.
     * @example
     * // Delete one Store
     * const Store = await prisma.store.delete({
     *   where: {
     *     // ... filter to delete one Store
     *   }
     * })
     * 
     */
    delete<T extends storeDeleteArgs>(args: SelectSubset<T, storeDeleteArgs<ExtArgs>>): Prisma__storeClient<$Result.GetResult<Prisma.$storePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Store.
     * @param {storeUpdateArgs} args - Arguments to update one Store.
     * @example
     * // Update one Store
     * const store = await prisma.store.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends storeUpdateArgs>(args: SelectSubset<T, storeUpdateArgs<ExtArgs>>): Prisma__storeClient<$Result.GetResult<Prisma.$storePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Stores.
     * @param {storeDeleteManyArgs} args - Arguments to filter Stores to delete.
     * @example
     * // Delete a few Stores
     * const { count } = await prisma.store.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends storeDeleteManyArgs>(args?: SelectSubset<T, storeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Stores.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {storeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Stores
     * const store = await prisma.store.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends storeUpdateManyArgs>(args: SelectSubset<T, storeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Stores and returns the data updated in the database.
     * @param {storeUpdateManyAndReturnArgs} args - Arguments to update many Stores.
     * @example
     * // Update many Stores
     * const store = await prisma.store.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Stores and only return the `id`
     * const storeWithIdOnly = await prisma.store.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends storeUpdateManyAndReturnArgs>(args: SelectSubset<T, storeUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$storePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Store.
     * @param {storeUpsertArgs} args - Arguments to update or create a Store.
     * @example
     * // Update or create a Store
     * const store = await prisma.store.upsert({
     *   create: {
     *     // ... data to create a Store
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Store we want to update
     *   }
     * })
     */
    upsert<T extends storeUpsertArgs>(args: SelectSubset<T, storeUpsertArgs<ExtArgs>>): Prisma__storeClient<$Result.GetResult<Prisma.$storePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Stores.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {storeCountArgs} args - Arguments to filter Stores to count.
     * @example
     * // Count the number of Stores
     * const count = await prisma.store.count({
     *   where: {
     *     // ... the filter for the Stores we want to count
     *   }
     * })
    **/
    count<T extends storeCountArgs>(
      args?: Subset<T, storeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StoreCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Store.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StoreAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StoreAggregateArgs>(args: Subset<T, StoreAggregateArgs>): Prisma.PrismaPromise<GetStoreAggregateType<T>>

    /**
     * Group by Store.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {storeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends storeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: storeGroupByArgs['orderBy'] }
        : { orderBy?: storeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, storeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStoreGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the store model
   */
  readonly fields: storeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for store.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__storeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    brand<T extends brandDefaultArgs<ExtArgs> = {}>(args?: Subset<T, brandDefaultArgs<ExtArgs>>): Prisma__brandClient<$Result.GetResult<Prisma.$brandPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    subbrand<T extends store$subbrandArgs<ExtArgs> = {}>(args?: Subset<T, store$subbrandArgs<ExtArgs>>): Prisma__subbrandClient<$Result.GetResult<Prisma.$subbrandPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    customers<T extends store$customersArgs<ExtArgs> = {}>(args?: Subset<T, store$customersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$customerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    sales<T extends store$salesArgs<ExtArgs> = {}>(args?: Subset<T, store$salesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$salePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the store model
   */
  interface storeFieldRefs {
    readonly id: FieldRef<"store", 'Int'>
    readonly brand_id: FieldRef<"store", 'Int'>
    readonly sub_brand_id: FieldRef<"store", 'Int'>
    readonly name: FieldRef<"store", 'String'>
    readonly city: FieldRef<"store", 'String'>
    readonly state: FieldRef<"store", 'String'>
    readonly district: FieldRef<"store", 'String'>
    readonly address_street: FieldRef<"store", 'String'>
    readonly address_number: FieldRef<"store", 'Int'>
    readonly zipcode: FieldRef<"store", 'String'>
    readonly latitude: FieldRef<"store", 'Decimal'>
    readonly longitude: FieldRef<"store", 'Decimal'>
    readonly is_active: FieldRef<"store", 'Boolean'>
    readonly is_own: FieldRef<"store", 'Boolean'>
    readonly is_holding: FieldRef<"store", 'Boolean'>
    readonly creation_date: FieldRef<"store", 'DateTime'>
    readonly created_at: FieldRef<"store", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * store findUnique
   */
  export type storeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the store
     */
    select?: storeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the store
     */
    omit?: storeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: storeInclude<ExtArgs> | null
    /**
     * Filter, which store to fetch.
     */
    where: storeWhereUniqueInput
  }

  /**
   * store findUniqueOrThrow
   */
  export type storeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the store
     */
    select?: storeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the store
     */
    omit?: storeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: storeInclude<ExtArgs> | null
    /**
     * Filter, which store to fetch.
     */
    where: storeWhereUniqueInput
  }

  /**
   * store findFirst
   */
  export type storeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the store
     */
    select?: storeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the store
     */
    omit?: storeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: storeInclude<ExtArgs> | null
    /**
     * Filter, which store to fetch.
     */
    where?: storeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of stores to fetch.
     */
    orderBy?: storeOrderByWithRelationInput | storeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for stores.
     */
    cursor?: storeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` stores from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` stores.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of stores.
     */
    distinct?: StoreScalarFieldEnum | StoreScalarFieldEnum[]
  }

  /**
   * store findFirstOrThrow
   */
  export type storeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the store
     */
    select?: storeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the store
     */
    omit?: storeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: storeInclude<ExtArgs> | null
    /**
     * Filter, which store to fetch.
     */
    where?: storeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of stores to fetch.
     */
    orderBy?: storeOrderByWithRelationInput | storeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for stores.
     */
    cursor?: storeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` stores from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` stores.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of stores.
     */
    distinct?: StoreScalarFieldEnum | StoreScalarFieldEnum[]
  }

  /**
   * store findMany
   */
  export type storeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the store
     */
    select?: storeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the store
     */
    omit?: storeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: storeInclude<ExtArgs> | null
    /**
     * Filter, which stores to fetch.
     */
    where?: storeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of stores to fetch.
     */
    orderBy?: storeOrderByWithRelationInput | storeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing stores.
     */
    cursor?: storeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` stores from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` stores.
     */
    skip?: number
    distinct?: StoreScalarFieldEnum | StoreScalarFieldEnum[]
  }

  /**
   * store create
   */
  export type storeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the store
     */
    select?: storeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the store
     */
    omit?: storeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: storeInclude<ExtArgs> | null
    /**
     * The data needed to create a store.
     */
    data: XOR<storeCreateInput, storeUncheckedCreateInput>
  }

  /**
   * store createMany
   */
  export type storeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many stores.
     */
    data: storeCreateManyInput | storeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * store createManyAndReturn
   */
  export type storeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the store
     */
    select?: storeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the store
     */
    omit?: storeOmit<ExtArgs> | null
    /**
     * The data used to create many stores.
     */
    data: storeCreateManyInput | storeCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: storeIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * store update
   */
  export type storeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the store
     */
    select?: storeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the store
     */
    omit?: storeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: storeInclude<ExtArgs> | null
    /**
     * The data needed to update a store.
     */
    data: XOR<storeUpdateInput, storeUncheckedUpdateInput>
    /**
     * Choose, which store to update.
     */
    where: storeWhereUniqueInput
  }

  /**
   * store updateMany
   */
  export type storeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update stores.
     */
    data: XOR<storeUpdateManyMutationInput, storeUncheckedUpdateManyInput>
    /**
     * Filter which stores to update
     */
    where?: storeWhereInput
    /**
     * Limit how many stores to update.
     */
    limit?: number
  }

  /**
   * store updateManyAndReturn
   */
  export type storeUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the store
     */
    select?: storeSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the store
     */
    omit?: storeOmit<ExtArgs> | null
    /**
     * The data used to update stores.
     */
    data: XOR<storeUpdateManyMutationInput, storeUncheckedUpdateManyInput>
    /**
     * Filter which stores to update
     */
    where?: storeWhereInput
    /**
     * Limit how many stores to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: storeIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * store upsert
   */
  export type storeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the store
     */
    select?: storeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the store
     */
    omit?: storeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: storeInclude<ExtArgs> | null
    /**
     * The filter to search for the store to update in case it exists.
     */
    where: storeWhereUniqueInput
    /**
     * In case the store found by the `where` argument doesn't exist, create a new store with this data.
     */
    create: XOR<storeCreateInput, storeUncheckedCreateInput>
    /**
     * In case the store was found with the provided `where` argument, update it with this data.
     */
    update: XOR<storeUpdateInput, storeUncheckedUpdateInput>
  }

  /**
   * store delete
   */
  export type storeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the store
     */
    select?: storeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the store
     */
    omit?: storeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: storeInclude<ExtArgs> | null
    /**
     * Filter which store to delete.
     */
    where: storeWhereUniqueInput
  }

  /**
   * store deleteMany
   */
  export type storeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which stores to delete
     */
    where?: storeWhereInput
    /**
     * Limit how many stores to delete.
     */
    limit?: number
  }

  /**
   * store.subbrand
   */
  export type store$subbrandArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the subbrand
     */
    select?: subbrandSelect<ExtArgs> | null
    /**
     * Omit specific fields from the subbrand
     */
    omit?: subbrandOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: subbrandInclude<ExtArgs> | null
    where?: subbrandWhereInput
  }

  /**
   * store.customers
   */
  export type store$customersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the customer
     */
    select?: customerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the customer
     */
    omit?: customerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: customerInclude<ExtArgs> | null
    where?: customerWhereInput
    orderBy?: customerOrderByWithRelationInput | customerOrderByWithRelationInput[]
    cursor?: customerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CustomerScalarFieldEnum | CustomerScalarFieldEnum[]
  }

  /**
   * store.sales
   */
  export type store$salesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sale
     */
    select?: saleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sale
     */
    omit?: saleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: saleInclude<ExtArgs> | null
    where?: saleWhereInput
    orderBy?: saleOrderByWithRelationInput | saleOrderByWithRelationInput[]
    cursor?: saleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SaleScalarFieldEnum | SaleScalarFieldEnum[]
  }

  /**
   * store without action
   */
  export type storeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the store
     */
    select?: storeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the store
     */
    omit?: storeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: storeInclude<ExtArgs> | null
  }


  /**
   * Model channel
   */

  export type AggregateChannel = {
    _count: ChannelCountAggregateOutputType | null
    _avg: ChannelAvgAggregateOutputType | null
    _sum: ChannelSumAggregateOutputType | null
    _min: ChannelMinAggregateOutputType | null
    _max: ChannelMaxAggregateOutputType | null
  }

  export type ChannelAvgAggregateOutputType = {
    id: number | null
    brand_id: number | null
  }

  export type ChannelSumAggregateOutputType = {
    id: number | null
    brand_id: number | null
  }

  export type ChannelMinAggregateOutputType = {
    id: number | null
    brand_id: number | null
    name: string | null
    description: string | null
    type: string | null
    created_at: Date | null
  }

  export type ChannelMaxAggregateOutputType = {
    id: number | null
    brand_id: number | null
    name: string | null
    description: string | null
    type: string | null
    created_at: Date | null
  }

  export type ChannelCountAggregateOutputType = {
    id: number
    brand_id: number
    name: number
    description: number
    type: number
    created_at: number
    _all: number
  }


  export type ChannelAvgAggregateInputType = {
    id?: true
    brand_id?: true
  }

  export type ChannelSumAggregateInputType = {
    id?: true
    brand_id?: true
  }

  export type ChannelMinAggregateInputType = {
    id?: true
    brand_id?: true
    name?: true
    description?: true
    type?: true
    created_at?: true
  }

  export type ChannelMaxAggregateInputType = {
    id?: true
    brand_id?: true
    name?: true
    description?: true
    type?: true
    created_at?: true
  }

  export type ChannelCountAggregateInputType = {
    id?: true
    brand_id?: true
    name?: true
    description?: true
    type?: true
    created_at?: true
    _all?: true
  }

  export type ChannelAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which channel to aggregate.
     */
    where?: channelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of channels to fetch.
     */
    orderBy?: channelOrderByWithRelationInput | channelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: channelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` channels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` channels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned channels
    **/
    _count?: true | ChannelCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ChannelAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ChannelSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ChannelMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ChannelMaxAggregateInputType
  }

  export type GetChannelAggregateType<T extends ChannelAggregateArgs> = {
        [P in keyof T & keyof AggregateChannel]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateChannel[P]>
      : GetScalarType<T[P], AggregateChannel[P]>
  }




  export type channelGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: channelWhereInput
    orderBy?: channelOrderByWithAggregationInput | channelOrderByWithAggregationInput[]
    by: ChannelScalarFieldEnum[] | ChannelScalarFieldEnum
    having?: channelScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ChannelCountAggregateInputType | true
    _avg?: ChannelAvgAggregateInputType
    _sum?: ChannelSumAggregateInputType
    _min?: ChannelMinAggregateInputType
    _max?: ChannelMaxAggregateInputType
  }

  export type ChannelGroupByOutputType = {
    id: number
    brand_id: number
    name: string
    description: string | null
    type: string | null
    created_at: Date | null
    _count: ChannelCountAggregateOutputType | null
    _avg: ChannelAvgAggregateOutputType | null
    _sum: ChannelSumAggregateOutputType | null
    _min: ChannelMinAggregateOutputType | null
    _max: ChannelMaxAggregateOutputType | null
  }

  type GetChannelGroupByPayload<T extends channelGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ChannelGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ChannelGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ChannelGroupByOutputType[P]>
            : GetScalarType<T[P], ChannelGroupByOutputType[P]>
        }
      >
    >


  export type channelSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    brand_id?: boolean
    name?: boolean
    description?: boolean
    type?: boolean
    created_at?: boolean
    brand?: boolean | brandDefaultArgs<ExtArgs>
    sales?: boolean | channel$salesArgs<ExtArgs>
    _count?: boolean | ChannelCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["channel"]>

  export type channelSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    brand_id?: boolean
    name?: boolean
    description?: boolean
    type?: boolean
    created_at?: boolean
    brand?: boolean | brandDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["channel"]>

  export type channelSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    brand_id?: boolean
    name?: boolean
    description?: boolean
    type?: boolean
    created_at?: boolean
    brand?: boolean | brandDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["channel"]>

  export type channelSelectScalar = {
    id?: boolean
    brand_id?: boolean
    name?: boolean
    description?: boolean
    type?: boolean
    created_at?: boolean
  }

  export type channelOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "brand_id" | "name" | "description" | "type" | "created_at", ExtArgs["result"]["channel"]>
  export type channelInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    brand?: boolean | brandDefaultArgs<ExtArgs>
    sales?: boolean | channel$salesArgs<ExtArgs>
    _count?: boolean | ChannelCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type channelIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    brand?: boolean | brandDefaultArgs<ExtArgs>
  }
  export type channelIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    brand?: boolean | brandDefaultArgs<ExtArgs>
  }

  export type $channelPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "channel"
    objects: {
      brand: Prisma.$brandPayload<ExtArgs>
      sales: Prisma.$salePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      brand_id: number
      name: string
      description: string | null
      type: string | null
      created_at: Date | null
    }, ExtArgs["result"]["channel"]>
    composites: {}
  }

  type channelGetPayload<S extends boolean | null | undefined | channelDefaultArgs> = $Result.GetResult<Prisma.$channelPayload, S>

  type channelCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<channelFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ChannelCountAggregateInputType | true
    }

  export interface channelDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['channel'], meta: { name: 'channel' } }
    /**
     * Find zero or one Channel that matches the filter.
     * @param {channelFindUniqueArgs} args - Arguments to find a Channel
     * @example
     * // Get one Channel
     * const channel = await prisma.channel.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends channelFindUniqueArgs>(args: SelectSubset<T, channelFindUniqueArgs<ExtArgs>>): Prisma__channelClient<$Result.GetResult<Prisma.$channelPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Channel that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {channelFindUniqueOrThrowArgs} args - Arguments to find a Channel
     * @example
     * // Get one Channel
     * const channel = await prisma.channel.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends channelFindUniqueOrThrowArgs>(args: SelectSubset<T, channelFindUniqueOrThrowArgs<ExtArgs>>): Prisma__channelClient<$Result.GetResult<Prisma.$channelPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Channel that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {channelFindFirstArgs} args - Arguments to find a Channel
     * @example
     * // Get one Channel
     * const channel = await prisma.channel.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends channelFindFirstArgs>(args?: SelectSubset<T, channelFindFirstArgs<ExtArgs>>): Prisma__channelClient<$Result.GetResult<Prisma.$channelPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Channel that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {channelFindFirstOrThrowArgs} args - Arguments to find a Channel
     * @example
     * // Get one Channel
     * const channel = await prisma.channel.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends channelFindFirstOrThrowArgs>(args?: SelectSubset<T, channelFindFirstOrThrowArgs<ExtArgs>>): Prisma__channelClient<$Result.GetResult<Prisma.$channelPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Channels that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {channelFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Channels
     * const channels = await prisma.channel.findMany()
     * 
     * // Get first 10 Channels
     * const channels = await prisma.channel.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const channelWithIdOnly = await prisma.channel.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends channelFindManyArgs>(args?: SelectSubset<T, channelFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$channelPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Channel.
     * @param {channelCreateArgs} args - Arguments to create a Channel.
     * @example
     * // Create one Channel
     * const Channel = await prisma.channel.create({
     *   data: {
     *     // ... data to create a Channel
     *   }
     * })
     * 
     */
    create<T extends channelCreateArgs>(args: SelectSubset<T, channelCreateArgs<ExtArgs>>): Prisma__channelClient<$Result.GetResult<Prisma.$channelPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Channels.
     * @param {channelCreateManyArgs} args - Arguments to create many Channels.
     * @example
     * // Create many Channels
     * const channel = await prisma.channel.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends channelCreateManyArgs>(args?: SelectSubset<T, channelCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Channels and returns the data saved in the database.
     * @param {channelCreateManyAndReturnArgs} args - Arguments to create many Channels.
     * @example
     * // Create many Channels
     * const channel = await prisma.channel.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Channels and only return the `id`
     * const channelWithIdOnly = await prisma.channel.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends channelCreateManyAndReturnArgs>(args?: SelectSubset<T, channelCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$channelPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Channel.
     * @param {channelDeleteArgs} args - Arguments to delete one Channel.
     * @example
     * // Delete one Channel
     * const Channel = await prisma.channel.delete({
     *   where: {
     *     // ... filter to delete one Channel
     *   }
     * })
     * 
     */
    delete<T extends channelDeleteArgs>(args: SelectSubset<T, channelDeleteArgs<ExtArgs>>): Prisma__channelClient<$Result.GetResult<Prisma.$channelPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Channel.
     * @param {channelUpdateArgs} args - Arguments to update one Channel.
     * @example
     * // Update one Channel
     * const channel = await prisma.channel.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends channelUpdateArgs>(args: SelectSubset<T, channelUpdateArgs<ExtArgs>>): Prisma__channelClient<$Result.GetResult<Prisma.$channelPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Channels.
     * @param {channelDeleteManyArgs} args - Arguments to filter Channels to delete.
     * @example
     * // Delete a few Channels
     * const { count } = await prisma.channel.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends channelDeleteManyArgs>(args?: SelectSubset<T, channelDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Channels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {channelUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Channels
     * const channel = await prisma.channel.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends channelUpdateManyArgs>(args: SelectSubset<T, channelUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Channels and returns the data updated in the database.
     * @param {channelUpdateManyAndReturnArgs} args - Arguments to update many Channels.
     * @example
     * // Update many Channels
     * const channel = await prisma.channel.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Channels and only return the `id`
     * const channelWithIdOnly = await prisma.channel.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends channelUpdateManyAndReturnArgs>(args: SelectSubset<T, channelUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$channelPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Channel.
     * @param {channelUpsertArgs} args - Arguments to update or create a Channel.
     * @example
     * // Update or create a Channel
     * const channel = await prisma.channel.upsert({
     *   create: {
     *     // ... data to create a Channel
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Channel we want to update
     *   }
     * })
     */
    upsert<T extends channelUpsertArgs>(args: SelectSubset<T, channelUpsertArgs<ExtArgs>>): Prisma__channelClient<$Result.GetResult<Prisma.$channelPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Channels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {channelCountArgs} args - Arguments to filter Channels to count.
     * @example
     * // Count the number of Channels
     * const count = await prisma.channel.count({
     *   where: {
     *     // ... the filter for the Channels we want to count
     *   }
     * })
    **/
    count<T extends channelCountArgs>(
      args?: Subset<T, channelCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ChannelCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Channel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChannelAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ChannelAggregateArgs>(args: Subset<T, ChannelAggregateArgs>): Prisma.PrismaPromise<GetChannelAggregateType<T>>

    /**
     * Group by Channel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {channelGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends channelGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: channelGroupByArgs['orderBy'] }
        : { orderBy?: channelGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, channelGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetChannelGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the channel model
   */
  readonly fields: channelFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for channel.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__channelClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    brand<T extends brandDefaultArgs<ExtArgs> = {}>(args?: Subset<T, brandDefaultArgs<ExtArgs>>): Prisma__brandClient<$Result.GetResult<Prisma.$brandPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    sales<T extends channel$salesArgs<ExtArgs> = {}>(args?: Subset<T, channel$salesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$salePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the channel model
   */
  interface channelFieldRefs {
    readonly id: FieldRef<"channel", 'Int'>
    readonly brand_id: FieldRef<"channel", 'Int'>
    readonly name: FieldRef<"channel", 'String'>
    readonly description: FieldRef<"channel", 'String'>
    readonly type: FieldRef<"channel", 'String'>
    readonly created_at: FieldRef<"channel", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * channel findUnique
   */
  export type channelFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the channel
     */
    select?: channelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the channel
     */
    omit?: channelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: channelInclude<ExtArgs> | null
    /**
     * Filter, which channel to fetch.
     */
    where: channelWhereUniqueInput
  }

  /**
   * channel findUniqueOrThrow
   */
  export type channelFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the channel
     */
    select?: channelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the channel
     */
    omit?: channelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: channelInclude<ExtArgs> | null
    /**
     * Filter, which channel to fetch.
     */
    where: channelWhereUniqueInput
  }

  /**
   * channel findFirst
   */
  export type channelFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the channel
     */
    select?: channelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the channel
     */
    omit?: channelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: channelInclude<ExtArgs> | null
    /**
     * Filter, which channel to fetch.
     */
    where?: channelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of channels to fetch.
     */
    orderBy?: channelOrderByWithRelationInput | channelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for channels.
     */
    cursor?: channelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` channels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` channels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of channels.
     */
    distinct?: ChannelScalarFieldEnum | ChannelScalarFieldEnum[]
  }

  /**
   * channel findFirstOrThrow
   */
  export type channelFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the channel
     */
    select?: channelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the channel
     */
    omit?: channelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: channelInclude<ExtArgs> | null
    /**
     * Filter, which channel to fetch.
     */
    where?: channelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of channels to fetch.
     */
    orderBy?: channelOrderByWithRelationInput | channelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for channels.
     */
    cursor?: channelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` channels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` channels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of channels.
     */
    distinct?: ChannelScalarFieldEnum | ChannelScalarFieldEnum[]
  }

  /**
   * channel findMany
   */
  export type channelFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the channel
     */
    select?: channelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the channel
     */
    omit?: channelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: channelInclude<ExtArgs> | null
    /**
     * Filter, which channels to fetch.
     */
    where?: channelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of channels to fetch.
     */
    orderBy?: channelOrderByWithRelationInput | channelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing channels.
     */
    cursor?: channelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` channels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` channels.
     */
    skip?: number
    distinct?: ChannelScalarFieldEnum | ChannelScalarFieldEnum[]
  }

  /**
   * channel create
   */
  export type channelCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the channel
     */
    select?: channelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the channel
     */
    omit?: channelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: channelInclude<ExtArgs> | null
    /**
     * The data needed to create a channel.
     */
    data: XOR<channelCreateInput, channelUncheckedCreateInput>
  }

  /**
   * channel createMany
   */
  export type channelCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many channels.
     */
    data: channelCreateManyInput | channelCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * channel createManyAndReturn
   */
  export type channelCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the channel
     */
    select?: channelSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the channel
     */
    omit?: channelOmit<ExtArgs> | null
    /**
     * The data used to create many channels.
     */
    data: channelCreateManyInput | channelCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: channelIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * channel update
   */
  export type channelUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the channel
     */
    select?: channelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the channel
     */
    omit?: channelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: channelInclude<ExtArgs> | null
    /**
     * The data needed to update a channel.
     */
    data: XOR<channelUpdateInput, channelUncheckedUpdateInput>
    /**
     * Choose, which channel to update.
     */
    where: channelWhereUniqueInput
  }

  /**
   * channel updateMany
   */
  export type channelUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update channels.
     */
    data: XOR<channelUpdateManyMutationInput, channelUncheckedUpdateManyInput>
    /**
     * Filter which channels to update
     */
    where?: channelWhereInput
    /**
     * Limit how many channels to update.
     */
    limit?: number
  }

  /**
   * channel updateManyAndReturn
   */
  export type channelUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the channel
     */
    select?: channelSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the channel
     */
    omit?: channelOmit<ExtArgs> | null
    /**
     * The data used to update channels.
     */
    data: XOR<channelUpdateManyMutationInput, channelUncheckedUpdateManyInput>
    /**
     * Filter which channels to update
     */
    where?: channelWhereInput
    /**
     * Limit how many channels to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: channelIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * channel upsert
   */
  export type channelUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the channel
     */
    select?: channelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the channel
     */
    omit?: channelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: channelInclude<ExtArgs> | null
    /**
     * The filter to search for the channel to update in case it exists.
     */
    where: channelWhereUniqueInput
    /**
     * In case the channel found by the `where` argument doesn't exist, create a new channel with this data.
     */
    create: XOR<channelCreateInput, channelUncheckedCreateInput>
    /**
     * In case the channel was found with the provided `where` argument, update it with this data.
     */
    update: XOR<channelUpdateInput, channelUncheckedUpdateInput>
  }

  /**
   * channel delete
   */
  export type channelDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the channel
     */
    select?: channelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the channel
     */
    omit?: channelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: channelInclude<ExtArgs> | null
    /**
     * Filter which channel to delete.
     */
    where: channelWhereUniqueInput
  }

  /**
   * channel deleteMany
   */
  export type channelDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which channels to delete
     */
    where?: channelWhereInput
    /**
     * Limit how many channels to delete.
     */
    limit?: number
  }

  /**
   * channel.sales
   */
  export type channel$salesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sale
     */
    select?: saleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sale
     */
    omit?: saleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: saleInclude<ExtArgs> | null
    where?: saleWhereInput
    orderBy?: saleOrderByWithRelationInput | saleOrderByWithRelationInput[]
    cursor?: saleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SaleScalarFieldEnum | SaleScalarFieldEnum[]
  }

  /**
   * channel without action
   */
  export type channelDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the channel
     */
    select?: channelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the channel
     */
    omit?: channelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: channelInclude<ExtArgs> | null
  }


  /**
   * Model category
   */

  export type AggregateCategory = {
    _count: CategoryCountAggregateOutputType | null
    _avg: CategoryAvgAggregateOutputType | null
    _sum: CategorySumAggregateOutputType | null
    _min: CategoryMinAggregateOutputType | null
    _max: CategoryMaxAggregateOutputType | null
  }

  export type CategoryAvgAggregateOutputType = {
    id: number | null
    brand_id: number | null
    sub_brand_id: number | null
  }

  export type CategorySumAggregateOutputType = {
    id: number | null
    brand_id: number | null
    sub_brand_id: number | null
  }

  export type CategoryMinAggregateOutputType = {
    id: number | null
    brand_id: number | null
    sub_brand_id: number | null
    name: string | null
    type: string | null
    pos_uuid: string | null
    deleted_at: Date | null
  }

  export type CategoryMaxAggregateOutputType = {
    id: number | null
    brand_id: number | null
    sub_brand_id: number | null
    name: string | null
    type: string | null
    pos_uuid: string | null
    deleted_at: Date | null
  }

  export type CategoryCountAggregateOutputType = {
    id: number
    brand_id: number
    sub_brand_id: number
    name: number
    type: number
    pos_uuid: number
    deleted_at: number
    _all: number
  }


  export type CategoryAvgAggregateInputType = {
    id?: true
    brand_id?: true
    sub_brand_id?: true
  }

  export type CategorySumAggregateInputType = {
    id?: true
    brand_id?: true
    sub_brand_id?: true
  }

  export type CategoryMinAggregateInputType = {
    id?: true
    brand_id?: true
    sub_brand_id?: true
    name?: true
    type?: true
    pos_uuid?: true
    deleted_at?: true
  }

  export type CategoryMaxAggregateInputType = {
    id?: true
    brand_id?: true
    sub_brand_id?: true
    name?: true
    type?: true
    pos_uuid?: true
    deleted_at?: true
  }

  export type CategoryCountAggregateInputType = {
    id?: true
    brand_id?: true
    sub_brand_id?: true
    name?: true
    type?: true
    pos_uuid?: true
    deleted_at?: true
    _all?: true
  }

  export type CategoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which category to aggregate.
     */
    where?: categoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of categories to fetch.
     */
    orderBy?: categoryOrderByWithRelationInput | categoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: categoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned categories
    **/
    _count?: true | CategoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CategoryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CategorySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CategoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CategoryMaxAggregateInputType
  }

  export type GetCategoryAggregateType<T extends CategoryAggregateArgs> = {
        [P in keyof T & keyof AggregateCategory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCategory[P]>
      : GetScalarType<T[P], AggregateCategory[P]>
  }




  export type categoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: categoryWhereInput
    orderBy?: categoryOrderByWithAggregationInput | categoryOrderByWithAggregationInput[]
    by: CategoryScalarFieldEnum[] | CategoryScalarFieldEnum
    having?: categoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CategoryCountAggregateInputType | true
    _avg?: CategoryAvgAggregateInputType
    _sum?: CategorySumAggregateInputType
    _min?: CategoryMinAggregateInputType
    _max?: CategoryMaxAggregateInputType
  }

  export type CategoryGroupByOutputType = {
    id: number
    brand_id: number
    sub_brand_id: number | null
    name: string
    type: string | null
    pos_uuid: string | null
    deleted_at: Date | null
    _count: CategoryCountAggregateOutputType | null
    _avg: CategoryAvgAggregateOutputType | null
    _sum: CategorySumAggregateOutputType | null
    _min: CategoryMinAggregateOutputType | null
    _max: CategoryMaxAggregateOutputType | null
  }

  type GetCategoryGroupByPayload<T extends categoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CategoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CategoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CategoryGroupByOutputType[P]>
            : GetScalarType<T[P], CategoryGroupByOutputType[P]>
        }
      >
    >


  export type categorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    brand_id?: boolean
    sub_brand_id?: boolean
    name?: boolean
    type?: boolean
    pos_uuid?: boolean
    deleted_at?: boolean
    brand?: boolean | brandDefaultArgs<ExtArgs>
    subbrand?: boolean | category$subbrandArgs<ExtArgs>
    products?: boolean | category$productsArgs<ExtArgs>
    optiongroups?: boolean | category$optiongroupsArgs<ExtArgs>
    items?: boolean | category$itemsArgs<ExtArgs>
    _count?: boolean | CategoryCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["category"]>

  export type categorySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    brand_id?: boolean
    sub_brand_id?: boolean
    name?: boolean
    type?: boolean
    pos_uuid?: boolean
    deleted_at?: boolean
    brand?: boolean | brandDefaultArgs<ExtArgs>
    subbrand?: boolean | category$subbrandArgs<ExtArgs>
  }, ExtArgs["result"]["category"]>

  export type categorySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    brand_id?: boolean
    sub_brand_id?: boolean
    name?: boolean
    type?: boolean
    pos_uuid?: boolean
    deleted_at?: boolean
    brand?: boolean | brandDefaultArgs<ExtArgs>
    subbrand?: boolean | category$subbrandArgs<ExtArgs>
  }, ExtArgs["result"]["category"]>

  export type categorySelectScalar = {
    id?: boolean
    brand_id?: boolean
    sub_brand_id?: boolean
    name?: boolean
    type?: boolean
    pos_uuid?: boolean
    deleted_at?: boolean
  }

  export type categoryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "brand_id" | "sub_brand_id" | "name" | "type" | "pos_uuid" | "deleted_at", ExtArgs["result"]["category"]>
  export type categoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    brand?: boolean | brandDefaultArgs<ExtArgs>
    subbrand?: boolean | category$subbrandArgs<ExtArgs>
    products?: boolean | category$productsArgs<ExtArgs>
    optiongroups?: boolean | category$optiongroupsArgs<ExtArgs>
    items?: boolean | category$itemsArgs<ExtArgs>
    _count?: boolean | CategoryCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type categoryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    brand?: boolean | brandDefaultArgs<ExtArgs>
    subbrand?: boolean | category$subbrandArgs<ExtArgs>
  }
  export type categoryIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    brand?: boolean | brandDefaultArgs<ExtArgs>
    subbrand?: boolean | category$subbrandArgs<ExtArgs>
  }

  export type $categoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "category"
    objects: {
      brand: Prisma.$brandPayload<ExtArgs>
      subbrand: Prisma.$subbrandPayload<ExtArgs> | null
      products: Prisma.$productPayload<ExtArgs>[]
      optiongroups: Prisma.$optiongroupPayload<ExtArgs>[]
      items: Prisma.$itemPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      brand_id: number
      sub_brand_id: number | null
      name: string
      type: string | null
      pos_uuid: string | null
      deleted_at: Date | null
    }, ExtArgs["result"]["category"]>
    composites: {}
  }

  type categoryGetPayload<S extends boolean | null | undefined | categoryDefaultArgs> = $Result.GetResult<Prisma.$categoryPayload, S>

  type categoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<categoryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CategoryCountAggregateInputType | true
    }

  export interface categoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['category'], meta: { name: 'category' } }
    /**
     * Find zero or one Category that matches the filter.
     * @param {categoryFindUniqueArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends categoryFindUniqueArgs>(args: SelectSubset<T, categoryFindUniqueArgs<ExtArgs>>): Prisma__categoryClient<$Result.GetResult<Prisma.$categoryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Category that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {categoryFindUniqueOrThrowArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends categoryFindUniqueOrThrowArgs>(args: SelectSubset<T, categoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__categoryClient<$Result.GetResult<Prisma.$categoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Category that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {categoryFindFirstArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends categoryFindFirstArgs>(args?: SelectSubset<T, categoryFindFirstArgs<ExtArgs>>): Prisma__categoryClient<$Result.GetResult<Prisma.$categoryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Category that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {categoryFindFirstOrThrowArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends categoryFindFirstOrThrowArgs>(args?: SelectSubset<T, categoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__categoryClient<$Result.GetResult<Prisma.$categoryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Categories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {categoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Categories
     * const categories = await prisma.category.findMany()
     * 
     * // Get first 10 Categories
     * const categories = await prisma.category.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const categoryWithIdOnly = await prisma.category.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends categoryFindManyArgs>(args?: SelectSubset<T, categoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$categoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Category.
     * @param {categoryCreateArgs} args - Arguments to create a Category.
     * @example
     * // Create one Category
     * const Category = await prisma.category.create({
     *   data: {
     *     // ... data to create a Category
     *   }
     * })
     * 
     */
    create<T extends categoryCreateArgs>(args: SelectSubset<T, categoryCreateArgs<ExtArgs>>): Prisma__categoryClient<$Result.GetResult<Prisma.$categoryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Categories.
     * @param {categoryCreateManyArgs} args - Arguments to create many Categories.
     * @example
     * // Create many Categories
     * const category = await prisma.category.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends categoryCreateManyArgs>(args?: SelectSubset<T, categoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Categories and returns the data saved in the database.
     * @param {categoryCreateManyAndReturnArgs} args - Arguments to create many Categories.
     * @example
     * // Create many Categories
     * const category = await prisma.category.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Categories and only return the `id`
     * const categoryWithIdOnly = await prisma.category.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends categoryCreateManyAndReturnArgs>(args?: SelectSubset<T, categoryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$categoryPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Category.
     * @param {categoryDeleteArgs} args - Arguments to delete one Category.
     * @example
     * // Delete one Category
     * const Category = await prisma.category.delete({
     *   where: {
     *     // ... filter to delete one Category
     *   }
     * })
     * 
     */
    delete<T extends categoryDeleteArgs>(args: SelectSubset<T, categoryDeleteArgs<ExtArgs>>): Prisma__categoryClient<$Result.GetResult<Prisma.$categoryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Category.
     * @param {categoryUpdateArgs} args - Arguments to update one Category.
     * @example
     * // Update one Category
     * const category = await prisma.category.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends categoryUpdateArgs>(args: SelectSubset<T, categoryUpdateArgs<ExtArgs>>): Prisma__categoryClient<$Result.GetResult<Prisma.$categoryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Categories.
     * @param {categoryDeleteManyArgs} args - Arguments to filter Categories to delete.
     * @example
     * // Delete a few Categories
     * const { count } = await prisma.category.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends categoryDeleteManyArgs>(args?: SelectSubset<T, categoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Categories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {categoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Categories
     * const category = await prisma.category.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends categoryUpdateManyArgs>(args: SelectSubset<T, categoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Categories and returns the data updated in the database.
     * @param {categoryUpdateManyAndReturnArgs} args - Arguments to update many Categories.
     * @example
     * // Update many Categories
     * const category = await prisma.category.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Categories and only return the `id`
     * const categoryWithIdOnly = await prisma.category.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends categoryUpdateManyAndReturnArgs>(args: SelectSubset<T, categoryUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$categoryPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Category.
     * @param {categoryUpsertArgs} args - Arguments to update or create a Category.
     * @example
     * // Update or create a Category
     * const category = await prisma.category.upsert({
     *   create: {
     *     // ... data to create a Category
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Category we want to update
     *   }
     * })
     */
    upsert<T extends categoryUpsertArgs>(args: SelectSubset<T, categoryUpsertArgs<ExtArgs>>): Prisma__categoryClient<$Result.GetResult<Prisma.$categoryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Categories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {categoryCountArgs} args - Arguments to filter Categories to count.
     * @example
     * // Count the number of Categories
     * const count = await prisma.category.count({
     *   where: {
     *     // ... the filter for the Categories we want to count
     *   }
     * })
    **/
    count<T extends categoryCountArgs>(
      args?: Subset<T, categoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CategoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Category.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CategoryAggregateArgs>(args: Subset<T, CategoryAggregateArgs>): Prisma.PrismaPromise<GetCategoryAggregateType<T>>

    /**
     * Group by Category.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {categoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends categoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: categoryGroupByArgs['orderBy'] }
        : { orderBy?: categoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, categoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCategoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the category model
   */
  readonly fields: categoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for category.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__categoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    brand<T extends brandDefaultArgs<ExtArgs> = {}>(args?: Subset<T, brandDefaultArgs<ExtArgs>>): Prisma__brandClient<$Result.GetResult<Prisma.$brandPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    subbrand<T extends category$subbrandArgs<ExtArgs> = {}>(args?: Subset<T, category$subbrandArgs<ExtArgs>>): Prisma__subbrandClient<$Result.GetResult<Prisma.$subbrandPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    products<T extends category$productsArgs<ExtArgs> = {}>(args?: Subset<T, category$productsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$productPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    optiongroups<T extends category$optiongroupsArgs<ExtArgs> = {}>(args?: Subset<T, category$optiongroupsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$optiongroupPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    items<T extends category$itemsArgs<ExtArgs> = {}>(args?: Subset<T, category$itemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$itemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the category model
   */
  interface categoryFieldRefs {
    readonly id: FieldRef<"category", 'Int'>
    readonly brand_id: FieldRef<"category", 'Int'>
    readonly sub_brand_id: FieldRef<"category", 'Int'>
    readonly name: FieldRef<"category", 'String'>
    readonly type: FieldRef<"category", 'String'>
    readonly pos_uuid: FieldRef<"category", 'String'>
    readonly deleted_at: FieldRef<"category", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * category findUnique
   */
  export type categoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the category
     */
    select?: categorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the category
     */
    omit?: categoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: categoryInclude<ExtArgs> | null
    /**
     * Filter, which category to fetch.
     */
    where: categoryWhereUniqueInput
  }

  /**
   * category findUniqueOrThrow
   */
  export type categoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the category
     */
    select?: categorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the category
     */
    omit?: categoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: categoryInclude<ExtArgs> | null
    /**
     * Filter, which category to fetch.
     */
    where: categoryWhereUniqueInput
  }

  /**
   * category findFirst
   */
  export type categoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the category
     */
    select?: categorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the category
     */
    omit?: categoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: categoryInclude<ExtArgs> | null
    /**
     * Filter, which category to fetch.
     */
    where?: categoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of categories to fetch.
     */
    orderBy?: categoryOrderByWithRelationInput | categoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for categories.
     */
    cursor?: categoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of categories.
     */
    distinct?: CategoryScalarFieldEnum | CategoryScalarFieldEnum[]
  }

  /**
   * category findFirstOrThrow
   */
  export type categoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the category
     */
    select?: categorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the category
     */
    omit?: categoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: categoryInclude<ExtArgs> | null
    /**
     * Filter, which category to fetch.
     */
    where?: categoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of categories to fetch.
     */
    orderBy?: categoryOrderByWithRelationInput | categoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for categories.
     */
    cursor?: categoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of categories.
     */
    distinct?: CategoryScalarFieldEnum | CategoryScalarFieldEnum[]
  }

  /**
   * category findMany
   */
  export type categoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the category
     */
    select?: categorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the category
     */
    omit?: categoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: categoryInclude<ExtArgs> | null
    /**
     * Filter, which categories to fetch.
     */
    where?: categoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of categories to fetch.
     */
    orderBy?: categoryOrderByWithRelationInput | categoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing categories.
     */
    cursor?: categoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` categories.
     */
    skip?: number
    distinct?: CategoryScalarFieldEnum | CategoryScalarFieldEnum[]
  }

  /**
   * category create
   */
  export type categoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the category
     */
    select?: categorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the category
     */
    omit?: categoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: categoryInclude<ExtArgs> | null
    /**
     * The data needed to create a category.
     */
    data: XOR<categoryCreateInput, categoryUncheckedCreateInput>
  }

  /**
   * category createMany
   */
  export type categoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many categories.
     */
    data: categoryCreateManyInput | categoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * category createManyAndReturn
   */
  export type categoryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the category
     */
    select?: categorySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the category
     */
    omit?: categoryOmit<ExtArgs> | null
    /**
     * The data used to create many categories.
     */
    data: categoryCreateManyInput | categoryCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: categoryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * category update
   */
  export type categoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the category
     */
    select?: categorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the category
     */
    omit?: categoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: categoryInclude<ExtArgs> | null
    /**
     * The data needed to update a category.
     */
    data: XOR<categoryUpdateInput, categoryUncheckedUpdateInput>
    /**
     * Choose, which category to update.
     */
    where: categoryWhereUniqueInput
  }

  /**
   * category updateMany
   */
  export type categoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update categories.
     */
    data: XOR<categoryUpdateManyMutationInput, categoryUncheckedUpdateManyInput>
    /**
     * Filter which categories to update
     */
    where?: categoryWhereInput
    /**
     * Limit how many categories to update.
     */
    limit?: number
  }

  /**
   * category updateManyAndReturn
   */
  export type categoryUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the category
     */
    select?: categorySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the category
     */
    omit?: categoryOmit<ExtArgs> | null
    /**
     * The data used to update categories.
     */
    data: XOR<categoryUpdateManyMutationInput, categoryUncheckedUpdateManyInput>
    /**
     * Filter which categories to update
     */
    where?: categoryWhereInput
    /**
     * Limit how many categories to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: categoryIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * category upsert
   */
  export type categoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the category
     */
    select?: categorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the category
     */
    omit?: categoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: categoryInclude<ExtArgs> | null
    /**
     * The filter to search for the category to update in case it exists.
     */
    where: categoryWhereUniqueInput
    /**
     * In case the category found by the `where` argument doesn't exist, create a new category with this data.
     */
    create: XOR<categoryCreateInput, categoryUncheckedCreateInput>
    /**
     * In case the category was found with the provided `where` argument, update it with this data.
     */
    update: XOR<categoryUpdateInput, categoryUncheckedUpdateInput>
  }

  /**
   * category delete
   */
  export type categoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the category
     */
    select?: categorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the category
     */
    omit?: categoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: categoryInclude<ExtArgs> | null
    /**
     * Filter which category to delete.
     */
    where: categoryWhereUniqueInput
  }

  /**
   * category deleteMany
   */
  export type categoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which categories to delete
     */
    where?: categoryWhereInput
    /**
     * Limit how many categories to delete.
     */
    limit?: number
  }

  /**
   * category.subbrand
   */
  export type category$subbrandArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the subbrand
     */
    select?: subbrandSelect<ExtArgs> | null
    /**
     * Omit specific fields from the subbrand
     */
    omit?: subbrandOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: subbrandInclude<ExtArgs> | null
    where?: subbrandWhereInput
  }

  /**
   * category.products
   */
  export type category$productsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the product
     */
    select?: productSelect<ExtArgs> | null
    /**
     * Omit specific fields from the product
     */
    omit?: productOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: productInclude<ExtArgs> | null
    where?: productWhereInput
    orderBy?: productOrderByWithRelationInput | productOrderByWithRelationInput[]
    cursor?: productWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * category.optiongroups
   */
  export type category$optiongroupsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the optiongroup
     */
    select?: optiongroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the optiongroup
     */
    omit?: optiongroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: optiongroupInclude<ExtArgs> | null
    where?: optiongroupWhereInput
    orderBy?: optiongroupOrderByWithRelationInput | optiongroupOrderByWithRelationInput[]
    cursor?: optiongroupWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OptiongroupScalarFieldEnum | OptiongroupScalarFieldEnum[]
  }

  /**
   * category.items
   */
  export type category$itemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the item
     */
    select?: itemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the item
     */
    omit?: itemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: itemInclude<ExtArgs> | null
    where?: itemWhereInput
    orderBy?: itemOrderByWithRelationInput | itemOrderByWithRelationInput[]
    cursor?: itemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ItemScalarFieldEnum | ItemScalarFieldEnum[]
  }

  /**
   * category without action
   */
  export type categoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the category
     */
    select?: categorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the category
     */
    omit?: categoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: categoryInclude<ExtArgs> | null
  }


  /**
   * Model product
   */

  export type AggregateProduct = {
    _count: ProductCountAggregateOutputType | null
    _avg: ProductAvgAggregateOutputType | null
    _sum: ProductSumAggregateOutputType | null
    _min: ProductMinAggregateOutputType | null
    _max: ProductMaxAggregateOutputType | null
  }

  export type ProductAvgAggregateOutputType = {
    id: number | null
    brand_id: number | null
    sub_brand_id: number | null
    category_id: number | null
  }

  export type ProductSumAggregateOutputType = {
    id: number | null
    brand_id: number | null
    sub_brand_id: number | null
    category_id: number | null
  }

  export type ProductMinAggregateOutputType = {
    id: number | null
    brand_id: number | null
    sub_brand_id: number | null
    category_id: number | null
    name: string | null
    pos_uuid: string | null
    deleted_at: Date | null
  }

  export type ProductMaxAggregateOutputType = {
    id: number | null
    brand_id: number | null
    sub_brand_id: number | null
    category_id: number | null
    name: string | null
    pos_uuid: string | null
    deleted_at: Date | null
  }

  export type ProductCountAggregateOutputType = {
    id: number
    brand_id: number
    sub_brand_id: number
    category_id: number
    name: number
    pos_uuid: number
    deleted_at: number
    _all: number
  }


  export type ProductAvgAggregateInputType = {
    id?: true
    brand_id?: true
    sub_brand_id?: true
    category_id?: true
  }

  export type ProductSumAggregateInputType = {
    id?: true
    brand_id?: true
    sub_brand_id?: true
    category_id?: true
  }

  export type ProductMinAggregateInputType = {
    id?: true
    brand_id?: true
    sub_brand_id?: true
    category_id?: true
    name?: true
    pos_uuid?: true
    deleted_at?: true
  }

  export type ProductMaxAggregateInputType = {
    id?: true
    brand_id?: true
    sub_brand_id?: true
    category_id?: true
    name?: true
    pos_uuid?: true
    deleted_at?: true
  }

  export type ProductCountAggregateInputType = {
    id?: true
    brand_id?: true
    sub_brand_id?: true
    category_id?: true
    name?: true
    pos_uuid?: true
    deleted_at?: true
    _all?: true
  }

  export type ProductAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which product to aggregate.
     */
    where?: productWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of products to fetch.
     */
    orderBy?: productOrderByWithRelationInput | productOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: productWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned products
    **/
    _count?: true | ProductCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProductAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProductSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProductMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProductMaxAggregateInputType
  }

  export type GetProductAggregateType<T extends ProductAggregateArgs> = {
        [P in keyof T & keyof AggregateProduct]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProduct[P]>
      : GetScalarType<T[P], AggregateProduct[P]>
  }




  export type productGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: productWhereInput
    orderBy?: productOrderByWithAggregationInput | productOrderByWithAggregationInput[]
    by: ProductScalarFieldEnum[] | ProductScalarFieldEnum
    having?: productScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProductCountAggregateInputType | true
    _avg?: ProductAvgAggregateInputType
    _sum?: ProductSumAggregateInputType
    _min?: ProductMinAggregateInputType
    _max?: ProductMaxAggregateInputType
  }

  export type ProductGroupByOutputType = {
    id: number
    brand_id: number
    sub_brand_id: number | null
    category_id: number | null
    name: string
    pos_uuid: string | null
    deleted_at: Date | null
    _count: ProductCountAggregateOutputType | null
    _avg: ProductAvgAggregateOutputType | null
    _sum: ProductSumAggregateOutputType | null
    _min: ProductMinAggregateOutputType | null
    _max: ProductMaxAggregateOutputType | null
  }

  type GetProductGroupByPayload<T extends productGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProductGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProductGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProductGroupByOutputType[P]>
            : GetScalarType<T[P], ProductGroupByOutputType[P]>
        }
      >
    >


  export type productSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    brand_id?: boolean
    sub_brand_id?: boolean
    category_id?: boolean
    name?: boolean
    pos_uuid?: boolean
    deleted_at?: boolean
    brand?: boolean | brandDefaultArgs<ExtArgs>
    subbrand?: boolean | product$subbrandArgs<ExtArgs>
    category?: boolean | product$categoryArgs<ExtArgs>
    productsales?: boolean | product$productsalesArgs<ExtArgs>
    _count?: boolean | ProductCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["product"]>

  export type productSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    brand_id?: boolean
    sub_brand_id?: boolean
    category_id?: boolean
    name?: boolean
    pos_uuid?: boolean
    deleted_at?: boolean
    brand?: boolean | brandDefaultArgs<ExtArgs>
    subbrand?: boolean | product$subbrandArgs<ExtArgs>
    category?: boolean | product$categoryArgs<ExtArgs>
  }, ExtArgs["result"]["product"]>

  export type productSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    brand_id?: boolean
    sub_brand_id?: boolean
    category_id?: boolean
    name?: boolean
    pos_uuid?: boolean
    deleted_at?: boolean
    brand?: boolean | brandDefaultArgs<ExtArgs>
    subbrand?: boolean | product$subbrandArgs<ExtArgs>
    category?: boolean | product$categoryArgs<ExtArgs>
  }, ExtArgs["result"]["product"]>

  export type productSelectScalar = {
    id?: boolean
    brand_id?: boolean
    sub_brand_id?: boolean
    category_id?: boolean
    name?: boolean
    pos_uuid?: boolean
    deleted_at?: boolean
  }

  export type productOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "brand_id" | "sub_brand_id" | "category_id" | "name" | "pos_uuid" | "deleted_at", ExtArgs["result"]["product"]>
  export type productInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    brand?: boolean | brandDefaultArgs<ExtArgs>
    subbrand?: boolean | product$subbrandArgs<ExtArgs>
    category?: boolean | product$categoryArgs<ExtArgs>
    productsales?: boolean | product$productsalesArgs<ExtArgs>
    _count?: boolean | ProductCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type productIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    brand?: boolean | brandDefaultArgs<ExtArgs>
    subbrand?: boolean | product$subbrandArgs<ExtArgs>
    category?: boolean | product$categoryArgs<ExtArgs>
  }
  export type productIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    brand?: boolean | brandDefaultArgs<ExtArgs>
    subbrand?: boolean | product$subbrandArgs<ExtArgs>
    category?: boolean | product$categoryArgs<ExtArgs>
  }

  export type $productPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "product"
    objects: {
      brand: Prisma.$brandPayload<ExtArgs>
      subbrand: Prisma.$subbrandPayload<ExtArgs> | null
      category: Prisma.$categoryPayload<ExtArgs> | null
      productsales: Prisma.$productsalePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      brand_id: number
      sub_brand_id: number | null
      category_id: number | null
      name: string
      pos_uuid: string | null
      deleted_at: Date | null
    }, ExtArgs["result"]["product"]>
    composites: {}
  }

  type productGetPayload<S extends boolean | null | undefined | productDefaultArgs> = $Result.GetResult<Prisma.$productPayload, S>

  type productCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<productFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProductCountAggregateInputType | true
    }

  export interface productDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['product'], meta: { name: 'product' } }
    /**
     * Find zero or one Product that matches the filter.
     * @param {productFindUniqueArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends productFindUniqueArgs>(args: SelectSubset<T, productFindUniqueArgs<ExtArgs>>): Prisma__productClient<$Result.GetResult<Prisma.$productPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Product that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {productFindUniqueOrThrowArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends productFindUniqueOrThrowArgs>(args: SelectSubset<T, productFindUniqueOrThrowArgs<ExtArgs>>): Prisma__productClient<$Result.GetResult<Prisma.$productPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Product that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {productFindFirstArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends productFindFirstArgs>(args?: SelectSubset<T, productFindFirstArgs<ExtArgs>>): Prisma__productClient<$Result.GetResult<Prisma.$productPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Product that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {productFindFirstOrThrowArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends productFindFirstOrThrowArgs>(args?: SelectSubset<T, productFindFirstOrThrowArgs<ExtArgs>>): Prisma__productClient<$Result.GetResult<Prisma.$productPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Products that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {productFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Products
     * const products = await prisma.product.findMany()
     * 
     * // Get first 10 Products
     * const products = await prisma.product.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const productWithIdOnly = await prisma.product.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends productFindManyArgs>(args?: SelectSubset<T, productFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$productPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Product.
     * @param {productCreateArgs} args - Arguments to create a Product.
     * @example
     * // Create one Product
     * const Product = await prisma.product.create({
     *   data: {
     *     // ... data to create a Product
     *   }
     * })
     * 
     */
    create<T extends productCreateArgs>(args: SelectSubset<T, productCreateArgs<ExtArgs>>): Prisma__productClient<$Result.GetResult<Prisma.$productPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Products.
     * @param {productCreateManyArgs} args - Arguments to create many Products.
     * @example
     * // Create many Products
     * const product = await prisma.product.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends productCreateManyArgs>(args?: SelectSubset<T, productCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Products and returns the data saved in the database.
     * @param {productCreateManyAndReturnArgs} args - Arguments to create many Products.
     * @example
     * // Create many Products
     * const product = await prisma.product.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Products and only return the `id`
     * const productWithIdOnly = await prisma.product.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends productCreateManyAndReturnArgs>(args?: SelectSubset<T, productCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$productPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Product.
     * @param {productDeleteArgs} args - Arguments to delete one Product.
     * @example
     * // Delete one Product
     * const Product = await prisma.product.delete({
     *   where: {
     *     // ... filter to delete one Product
     *   }
     * })
     * 
     */
    delete<T extends productDeleteArgs>(args: SelectSubset<T, productDeleteArgs<ExtArgs>>): Prisma__productClient<$Result.GetResult<Prisma.$productPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Product.
     * @param {productUpdateArgs} args - Arguments to update one Product.
     * @example
     * // Update one Product
     * const product = await prisma.product.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends productUpdateArgs>(args: SelectSubset<T, productUpdateArgs<ExtArgs>>): Prisma__productClient<$Result.GetResult<Prisma.$productPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Products.
     * @param {productDeleteManyArgs} args - Arguments to filter Products to delete.
     * @example
     * // Delete a few Products
     * const { count } = await prisma.product.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends productDeleteManyArgs>(args?: SelectSubset<T, productDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Products.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {productUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Products
     * const product = await prisma.product.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends productUpdateManyArgs>(args: SelectSubset<T, productUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Products and returns the data updated in the database.
     * @param {productUpdateManyAndReturnArgs} args - Arguments to update many Products.
     * @example
     * // Update many Products
     * const product = await prisma.product.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Products and only return the `id`
     * const productWithIdOnly = await prisma.product.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends productUpdateManyAndReturnArgs>(args: SelectSubset<T, productUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$productPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Product.
     * @param {productUpsertArgs} args - Arguments to update or create a Product.
     * @example
     * // Update or create a Product
     * const product = await prisma.product.upsert({
     *   create: {
     *     // ... data to create a Product
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Product we want to update
     *   }
     * })
     */
    upsert<T extends productUpsertArgs>(args: SelectSubset<T, productUpsertArgs<ExtArgs>>): Prisma__productClient<$Result.GetResult<Prisma.$productPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Products.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {productCountArgs} args - Arguments to filter Products to count.
     * @example
     * // Count the number of Products
     * const count = await prisma.product.count({
     *   where: {
     *     // ... the filter for the Products we want to count
     *   }
     * })
    **/
    count<T extends productCountArgs>(
      args?: Subset<T, productCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProductCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Product.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProductAggregateArgs>(args: Subset<T, ProductAggregateArgs>): Prisma.PrismaPromise<GetProductAggregateType<T>>

    /**
     * Group by Product.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {productGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends productGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: productGroupByArgs['orderBy'] }
        : { orderBy?: productGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, productGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProductGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the product model
   */
  readonly fields: productFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for product.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__productClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    brand<T extends brandDefaultArgs<ExtArgs> = {}>(args?: Subset<T, brandDefaultArgs<ExtArgs>>): Prisma__brandClient<$Result.GetResult<Prisma.$brandPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    subbrand<T extends product$subbrandArgs<ExtArgs> = {}>(args?: Subset<T, product$subbrandArgs<ExtArgs>>): Prisma__subbrandClient<$Result.GetResult<Prisma.$subbrandPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    category<T extends product$categoryArgs<ExtArgs> = {}>(args?: Subset<T, product$categoryArgs<ExtArgs>>): Prisma__categoryClient<$Result.GetResult<Prisma.$categoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    productsales<T extends product$productsalesArgs<ExtArgs> = {}>(args?: Subset<T, product$productsalesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$productsalePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the product model
   */
  interface productFieldRefs {
    readonly id: FieldRef<"product", 'Int'>
    readonly brand_id: FieldRef<"product", 'Int'>
    readonly sub_brand_id: FieldRef<"product", 'Int'>
    readonly category_id: FieldRef<"product", 'Int'>
    readonly name: FieldRef<"product", 'String'>
    readonly pos_uuid: FieldRef<"product", 'String'>
    readonly deleted_at: FieldRef<"product", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * product findUnique
   */
  export type productFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the product
     */
    select?: productSelect<ExtArgs> | null
    /**
     * Omit specific fields from the product
     */
    omit?: productOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: productInclude<ExtArgs> | null
    /**
     * Filter, which product to fetch.
     */
    where: productWhereUniqueInput
  }

  /**
   * product findUniqueOrThrow
   */
  export type productFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the product
     */
    select?: productSelect<ExtArgs> | null
    /**
     * Omit specific fields from the product
     */
    omit?: productOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: productInclude<ExtArgs> | null
    /**
     * Filter, which product to fetch.
     */
    where: productWhereUniqueInput
  }

  /**
   * product findFirst
   */
  export type productFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the product
     */
    select?: productSelect<ExtArgs> | null
    /**
     * Omit specific fields from the product
     */
    omit?: productOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: productInclude<ExtArgs> | null
    /**
     * Filter, which product to fetch.
     */
    where?: productWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of products to fetch.
     */
    orderBy?: productOrderByWithRelationInput | productOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for products.
     */
    cursor?: productWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of products.
     */
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * product findFirstOrThrow
   */
  export type productFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the product
     */
    select?: productSelect<ExtArgs> | null
    /**
     * Omit specific fields from the product
     */
    omit?: productOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: productInclude<ExtArgs> | null
    /**
     * Filter, which product to fetch.
     */
    where?: productWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of products to fetch.
     */
    orderBy?: productOrderByWithRelationInput | productOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for products.
     */
    cursor?: productWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of products.
     */
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * product findMany
   */
  export type productFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the product
     */
    select?: productSelect<ExtArgs> | null
    /**
     * Omit specific fields from the product
     */
    omit?: productOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: productInclude<ExtArgs> | null
    /**
     * Filter, which products to fetch.
     */
    where?: productWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of products to fetch.
     */
    orderBy?: productOrderByWithRelationInput | productOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing products.
     */
    cursor?: productWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` products.
     */
    skip?: number
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * product create
   */
  export type productCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the product
     */
    select?: productSelect<ExtArgs> | null
    /**
     * Omit specific fields from the product
     */
    omit?: productOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: productInclude<ExtArgs> | null
    /**
     * The data needed to create a product.
     */
    data: XOR<productCreateInput, productUncheckedCreateInput>
  }

  /**
   * product createMany
   */
  export type productCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many products.
     */
    data: productCreateManyInput | productCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * product createManyAndReturn
   */
  export type productCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the product
     */
    select?: productSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the product
     */
    omit?: productOmit<ExtArgs> | null
    /**
     * The data used to create many products.
     */
    data: productCreateManyInput | productCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: productIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * product update
   */
  export type productUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the product
     */
    select?: productSelect<ExtArgs> | null
    /**
     * Omit specific fields from the product
     */
    omit?: productOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: productInclude<ExtArgs> | null
    /**
     * The data needed to update a product.
     */
    data: XOR<productUpdateInput, productUncheckedUpdateInput>
    /**
     * Choose, which product to update.
     */
    where: productWhereUniqueInput
  }

  /**
   * product updateMany
   */
  export type productUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update products.
     */
    data: XOR<productUpdateManyMutationInput, productUncheckedUpdateManyInput>
    /**
     * Filter which products to update
     */
    where?: productWhereInput
    /**
     * Limit how many products to update.
     */
    limit?: number
  }

  /**
   * product updateManyAndReturn
   */
  export type productUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the product
     */
    select?: productSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the product
     */
    omit?: productOmit<ExtArgs> | null
    /**
     * The data used to update products.
     */
    data: XOR<productUpdateManyMutationInput, productUncheckedUpdateManyInput>
    /**
     * Filter which products to update
     */
    where?: productWhereInput
    /**
     * Limit how many products to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: productIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * product upsert
   */
  export type productUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the product
     */
    select?: productSelect<ExtArgs> | null
    /**
     * Omit specific fields from the product
     */
    omit?: productOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: productInclude<ExtArgs> | null
    /**
     * The filter to search for the product to update in case it exists.
     */
    where: productWhereUniqueInput
    /**
     * In case the product found by the `where` argument doesn't exist, create a new product with this data.
     */
    create: XOR<productCreateInput, productUncheckedCreateInput>
    /**
     * In case the product was found with the provided `where` argument, update it with this data.
     */
    update: XOR<productUpdateInput, productUncheckedUpdateInput>
  }

  /**
   * product delete
   */
  export type productDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the product
     */
    select?: productSelect<ExtArgs> | null
    /**
     * Omit specific fields from the product
     */
    omit?: productOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: productInclude<ExtArgs> | null
    /**
     * Filter which product to delete.
     */
    where: productWhereUniqueInput
  }

  /**
   * product deleteMany
   */
  export type productDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which products to delete
     */
    where?: productWhereInput
    /**
     * Limit how many products to delete.
     */
    limit?: number
  }

  /**
   * product.subbrand
   */
  export type product$subbrandArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the subbrand
     */
    select?: subbrandSelect<ExtArgs> | null
    /**
     * Omit specific fields from the subbrand
     */
    omit?: subbrandOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: subbrandInclude<ExtArgs> | null
    where?: subbrandWhereInput
  }

  /**
   * product.category
   */
  export type product$categoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the category
     */
    select?: categorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the category
     */
    omit?: categoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: categoryInclude<ExtArgs> | null
    where?: categoryWhereInput
  }

  /**
   * product.productsales
   */
  export type product$productsalesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the productsale
     */
    select?: productsaleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the productsale
     */
    omit?: productsaleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: productsaleInclude<ExtArgs> | null
    where?: productsaleWhereInput
    orderBy?: productsaleOrderByWithRelationInput | productsaleOrderByWithRelationInput[]
    cursor?: productsaleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductsaleScalarFieldEnum | ProductsaleScalarFieldEnum[]
  }

  /**
   * product without action
   */
  export type productDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the product
     */
    select?: productSelect<ExtArgs> | null
    /**
     * Omit specific fields from the product
     */
    omit?: productOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: productInclude<ExtArgs> | null
  }


  /**
   * Model optiongroup
   */

  export type AggregateOptiongroup = {
    _count: OptiongroupCountAggregateOutputType | null
    _avg: OptiongroupAvgAggregateOutputType | null
    _sum: OptiongroupSumAggregateOutputType | null
    _min: OptiongroupMinAggregateOutputType | null
    _max: OptiongroupMaxAggregateOutputType | null
  }

  export type OptiongroupAvgAggregateOutputType = {
    id: number | null
    brand_id: number | null
    sub_brand_id: number | null
    category_id: number | null
  }

  export type OptiongroupSumAggregateOutputType = {
    id: number | null
    brand_id: number | null
    sub_brand_id: number | null
    category_id: number | null
  }

  export type OptiongroupMinAggregateOutputType = {
    id: number | null
    brand_id: number | null
    sub_brand_id: number | null
    category_id: number | null
    name: string | null
    pos_uuid: string | null
    deleted_at: Date | null
  }

  export type OptiongroupMaxAggregateOutputType = {
    id: number | null
    brand_id: number | null
    sub_brand_id: number | null
    category_id: number | null
    name: string | null
    pos_uuid: string | null
    deleted_at: Date | null
  }

  export type OptiongroupCountAggregateOutputType = {
    id: number
    brand_id: number
    sub_brand_id: number
    category_id: number
    name: number
    pos_uuid: number
    deleted_at: number
    _all: number
  }


  export type OptiongroupAvgAggregateInputType = {
    id?: true
    brand_id?: true
    sub_brand_id?: true
    category_id?: true
  }

  export type OptiongroupSumAggregateInputType = {
    id?: true
    brand_id?: true
    sub_brand_id?: true
    category_id?: true
  }

  export type OptiongroupMinAggregateInputType = {
    id?: true
    brand_id?: true
    sub_brand_id?: true
    category_id?: true
    name?: true
    pos_uuid?: true
    deleted_at?: true
  }

  export type OptiongroupMaxAggregateInputType = {
    id?: true
    brand_id?: true
    sub_brand_id?: true
    category_id?: true
    name?: true
    pos_uuid?: true
    deleted_at?: true
  }

  export type OptiongroupCountAggregateInputType = {
    id?: true
    brand_id?: true
    sub_brand_id?: true
    category_id?: true
    name?: true
    pos_uuid?: true
    deleted_at?: true
    _all?: true
  }

  export type OptiongroupAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which optiongroup to aggregate.
     */
    where?: optiongroupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of optiongroups to fetch.
     */
    orderBy?: optiongroupOrderByWithRelationInput | optiongroupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: optiongroupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` optiongroups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` optiongroups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned optiongroups
    **/
    _count?: true | OptiongroupCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OptiongroupAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OptiongroupSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OptiongroupMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OptiongroupMaxAggregateInputType
  }

  export type GetOptiongroupAggregateType<T extends OptiongroupAggregateArgs> = {
        [P in keyof T & keyof AggregateOptiongroup]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOptiongroup[P]>
      : GetScalarType<T[P], AggregateOptiongroup[P]>
  }




  export type optiongroupGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: optiongroupWhereInput
    orderBy?: optiongroupOrderByWithAggregationInput | optiongroupOrderByWithAggregationInput[]
    by: OptiongroupScalarFieldEnum[] | OptiongroupScalarFieldEnum
    having?: optiongroupScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OptiongroupCountAggregateInputType | true
    _avg?: OptiongroupAvgAggregateInputType
    _sum?: OptiongroupSumAggregateInputType
    _min?: OptiongroupMinAggregateInputType
    _max?: OptiongroupMaxAggregateInputType
  }

  export type OptiongroupGroupByOutputType = {
    id: number
    brand_id: number
    sub_brand_id: number | null
    category_id: number | null
    name: string
    pos_uuid: string | null
    deleted_at: Date | null
    _count: OptiongroupCountAggregateOutputType | null
    _avg: OptiongroupAvgAggregateOutputType | null
    _sum: OptiongroupSumAggregateOutputType | null
    _min: OptiongroupMinAggregateOutputType | null
    _max: OptiongroupMaxAggregateOutputType | null
  }

  type GetOptiongroupGroupByPayload<T extends optiongroupGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OptiongroupGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OptiongroupGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OptiongroupGroupByOutputType[P]>
            : GetScalarType<T[P], OptiongroupGroupByOutputType[P]>
        }
      >
    >


  export type optiongroupSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    brand_id?: boolean
    sub_brand_id?: boolean
    category_id?: boolean
    name?: boolean
    pos_uuid?: boolean
    deleted_at?: boolean
    brand?: boolean | brandDefaultArgs<ExtArgs>
    subbrand?: boolean | optiongroup$subbrandArgs<ExtArgs>
    category?: boolean | optiongroup$categoryArgs<ExtArgs>
    itemproductsales?: boolean | optiongroup$itemproductsalesArgs<ExtArgs>
    itemitemproductsales?: boolean | optiongroup$itemitemproductsalesArgs<ExtArgs>
    _count?: boolean | OptiongroupCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["optiongroup"]>

  export type optiongroupSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    brand_id?: boolean
    sub_brand_id?: boolean
    category_id?: boolean
    name?: boolean
    pos_uuid?: boolean
    deleted_at?: boolean
    brand?: boolean | brandDefaultArgs<ExtArgs>
    subbrand?: boolean | optiongroup$subbrandArgs<ExtArgs>
    category?: boolean | optiongroup$categoryArgs<ExtArgs>
  }, ExtArgs["result"]["optiongroup"]>

  export type optiongroupSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    brand_id?: boolean
    sub_brand_id?: boolean
    category_id?: boolean
    name?: boolean
    pos_uuid?: boolean
    deleted_at?: boolean
    brand?: boolean | brandDefaultArgs<ExtArgs>
    subbrand?: boolean | optiongroup$subbrandArgs<ExtArgs>
    category?: boolean | optiongroup$categoryArgs<ExtArgs>
  }, ExtArgs["result"]["optiongroup"]>

  export type optiongroupSelectScalar = {
    id?: boolean
    brand_id?: boolean
    sub_brand_id?: boolean
    category_id?: boolean
    name?: boolean
    pos_uuid?: boolean
    deleted_at?: boolean
  }

  export type optiongroupOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "brand_id" | "sub_brand_id" | "category_id" | "name" | "pos_uuid" | "deleted_at", ExtArgs["result"]["optiongroup"]>
  export type optiongroupInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    brand?: boolean | brandDefaultArgs<ExtArgs>
    subbrand?: boolean | optiongroup$subbrandArgs<ExtArgs>
    category?: boolean | optiongroup$categoryArgs<ExtArgs>
    itemproductsales?: boolean | optiongroup$itemproductsalesArgs<ExtArgs>
    itemitemproductsales?: boolean | optiongroup$itemitemproductsalesArgs<ExtArgs>
    _count?: boolean | OptiongroupCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type optiongroupIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    brand?: boolean | brandDefaultArgs<ExtArgs>
    subbrand?: boolean | optiongroup$subbrandArgs<ExtArgs>
    category?: boolean | optiongroup$categoryArgs<ExtArgs>
  }
  export type optiongroupIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    brand?: boolean | brandDefaultArgs<ExtArgs>
    subbrand?: boolean | optiongroup$subbrandArgs<ExtArgs>
    category?: boolean | optiongroup$categoryArgs<ExtArgs>
  }

  export type $optiongroupPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "optiongroup"
    objects: {
      brand: Prisma.$brandPayload<ExtArgs>
      subbrand: Prisma.$subbrandPayload<ExtArgs> | null
      category: Prisma.$categoryPayload<ExtArgs> | null
      itemproductsales: Prisma.$itemproductsalePayload<ExtArgs>[]
      itemitemproductsales: Prisma.$itemitemproductsalePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      brand_id: number
      sub_brand_id: number | null
      category_id: number | null
      name: string
      pos_uuid: string | null
      deleted_at: Date | null
    }, ExtArgs["result"]["optiongroup"]>
    composites: {}
  }

  type optiongroupGetPayload<S extends boolean | null | undefined | optiongroupDefaultArgs> = $Result.GetResult<Prisma.$optiongroupPayload, S>

  type optiongroupCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<optiongroupFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: OptiongroupCountAggregateInputType | true
    }

  export interface optiongroupDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['optiongroup'], meta: { name: 'optiongroup' } }
    /**
     * Find zero or one Optiongroup that matches the filter.
     * @param {optiongroupFindUniqueArgs} args - Arguments to find a Optiongroup
     * @example
     * // Get one Optiongroup
     * const optiongroup = await prisma.optiongroup.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends optiongroupFindUniqueArgs>(args: SelectSubset<T, optiongroupFindUniqueArgs<ExtArgs>>): Prisma__optiongroupClient<$Result.GetResult<Prisma.$optiongroupPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Optiongroup that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {optiongroupFindUniqueOrThrowArgs} args - Arguments to find a Optiongroup
     * @example
     * // Get one Optiongroup
     * const optiongroup = await prisma.optiongroup.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends optiongroupFindUniqueOrThrowArgs>(args: SelectSubset<T, optiongroupFindUniqueOrThrowArgs<ExtArgs>>): Prisma__optiongroupClient<$Result.GetResult<Prisma.$optiongroupPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Optiongroup that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {optiongroupFindFirstArgs} args - Arguments to find a Optiongroup
     * @example
     * // Get one Optiongroup
     * const optiongroup = await prisma.optiongroup.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends optiongroupFindFirstArgs>(args?: SelectSubset<T, optiongroupFindFirstArgs<ExtArgs>>): Prisma__optiongroupClient<$Result.GetResult<Prisma.$optiongroupPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Optiongroup that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {optiongroupFindFirstOrThrowArgs} args - Arguments to find a Optiongroup
     * @example
     * // Get one Optiongroup
     * const optiongroup = await prisma.optiongroup.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends optiongroupFindFirstOrThrowArgs>(args?: SelectSubset<T, optiongroupFindFirstOrThrowArgs<ExtArgs>>): Prisma__optiongroupClient<$Result.GetResult<Prisma.$optiongroupPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Optiongroups that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {optiongroupFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Optiongroups
     * const optiongroups = await prisma.optiongroup.findMany()
     * 
     * // Get first 10 Optiongroups
     * const optiongroups = await prisma.optiongroup.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const optiongroupWithIdOnly = await prisma.optiongroup.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends optiongroupFindManyArgs>(args?: SelectSubset<T, optiongroupFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$optiongroupPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Optiongroup.
     * @param {optiongroupCreateArgs} args - Arguments to create a Optiongroup.
     * @example
     * // Create one Optiongroup
     * const Optiongroup = await prisma.optiongroup.create({
     *   data: {
     *     // ... data to create a Optiongroup
     *   }
     * })
     * 
     */
    create<T extends optiongroupCreateArgs>(args: SelectSubset<T, optiongroupCreateArgs<ExtArgs>>): Prisma__optiongroupClient<$Result.GetResult<Prisma.$optiongroupPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Optiongroups.
     * @param {optiongroupCreateManyArgs} args - Arguments to create many Optiongroups.
     * @example
     * // Create many Optiongroups
     * const optiongroup = await prisma.optiongroup.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends optiongroupCreateManyArgs>(args?: SelectSubset<T, optiongroupCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Optiongroups and returns the data saved in the database.
     * @param {optiongroupCreateManyAndReturnArgs} args - Arguments to create many Optiongroups.
     * @example
     * // Create many Optiongroups
     * const optiongroup = await prisma.optiongroup.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Optiongroups and only return the `id`
     * const optiongroupWithIdOnly = await prisma.optiongroup.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends optiongroupCreateManyAndReturnArgs>(args?: SelectSubset<T, optiongroupCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$optiongroupPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Optiongroup.
     * @param {optiongroupDeleteArgs} args - Arguments to delete one Optiongroup.
     * @example
     * // Delete one Optiongroup
     * const Optiongroup = await prisma.optiongroup.delete({
     *   where: {
     *     // ... filter to delete one Optiongroup
     *   }
     * })
     * 
     */
    delete<T extends optiongroupDeleteArgs>(args: SelectSubset<T, optiongroupDeleteArgs<ExtArgs>>): Prisma__optiongroupClient<$Result.GetResult<Prisma.$optiongroupPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Optiongroup.
     * @param {optiongroupUpdateArgs} args - Arguments to update one Optiongroup.
     * @example
     * // Update one Optiongroup
     * const optiongroup = await prisma.optiongroup.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends optiongroupUpdateArgs>(args: SelectSubset<T, optiongroupUpdateArgs<ExtArgs>>): Prisma__optiongroupClient<$Result.GetResult<Prisma.$optiongroupPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Optiongroups.
     * @param {optiongroupDeleteManyArgs} args - Arguments to filter Optiongroups to delete.
     * @example
     * // Delete a few Optiongroups
     * const { count } = await prisma.optiongroup.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends optiongroupDeleteManyArgs>(args?: SelectSubset<T, optiongroupDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Optiongroups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {optiongroupUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Optiongroups
     * const optiongroup = await prisma.optiongroup.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends optiongroupUpdateManyArgs>(args: SelectSubset<T, optiongroupUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Optiongroups and returns the data updated in the database.
     * @param {optiongroupUpdateManyAndReturnArgs} args - Arguments to update many Optiongroups.
     * @example
     * // Update many Optiongroups
     * const optiongroup = await prisma.optiongroup.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Optiongroups and only return the `id`
     * const optiongroupWithIdOnly = await prisma.optiongroup.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends optiongroupUpdateManyAndReturnArgs>(args: SelectSubset<T, optiongroupUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$optiongroupPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Optiongroup.
     * @param {optiongroupUpsertArgs} args - Arguments to update or create a Optiongroup.
     * @example
     * // Update or create a Optiongroup
     * const optiongroup = await prisma.optiongroup.upsert({
     *   create: {
     *     // ... data to create a Optiongroup
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Optiongroup we want to update
     *   }
     * })
     */
    upsert<T extends optiongroupUpsertArgs>(args: SelectSubset<T, optiongroupUpsertArgs<ExtArgs>>): Prisma__optiongroupClient<$Result.GetResult<Prisma.$optiongroupPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Optiongroups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {optiongroupCountArgs} args - Arguments to filter Optiongroups to count.
     * @example
     * // Count the number of Optiongroups
     * const count = await prisma.optiongroup.count({
     *   where: {
     *     // ... the filter for the Optiongroups we want to count
     *   }
     * })
    **/
    count<T extends optiongroupCountArgs>(
      args?: Subset<T, optiongroupCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OptiongroupCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Optiongroup.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OptiongroupAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OptiongroupAggregateArgs>(args: Subset<T, OptiongroupAggregateArgs>): Prisma.PrismaPromise<GetOptiongroupAggregateType<T>>

    /**
     * Group by Optiongroup.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {optiongroupGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends optiongroupGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: optiongroupGroupByArgs['orderBy'] }
        : { orderBy?: optiongroupGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, optiongroupGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOptiongroupGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the optiongroup model
   */
  readonly fields: optiongroupFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for optiongroup.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__optiongroupClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    brand<T extends brandDefaultArgs<ExtArgs> = {}>(args?: Subset<T, brandDefaultArgs<ExtArgs>>): Prisma__brandClient<$Result.GetResult<Prisma.$brandPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    subbrand<T extends optiongroup$subbrandArgs<ExtArgs> = {}>(args?: Subset<T, optiongroup$subbrandArgs<ExtArgs>>): Prisma__subbrandClient<$Result.GetResult<Prisma.$subbrandPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    category<T extends optiongroup$categoryArgs<ExtArgs> = {}>(args?: Subset<T, optiongroup$categoryArgs<ExtArgs>>): Prisma__categoryClient<$Result.GetResult<Prisma.$categoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    itemproductsales<T extends optiongroup$itemproductsalesArgs<ExtArgs> = {}>(args?: Subset<T, optiongroup$itemproductsalesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$itemproductsalePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    itemitemproductsales<T extends optiongroup$itemitemproductsalesArgs<ExtArgs> = {}>(args?: Subset<T, optiongroup$itemitemproductsalesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$itemitemproductsalePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the optiongroup model
   */
  interface optiongroupFieldRefs {
    readonly id: FieldRef<"optiongroup", 'Int'>
    readonly brand_id: FieldRef<"optiongroup", 'Int'>
    readonly sub_brand_id: FieldRef<"optiongroup", 'Int'>
    readonly category_id: FieldRef<"optiongroup", 'Int'>
    readonly name: FieldRef<"optiongroup", 'String'>
    readonly pos_uuid: FieldRef<"optiongroup", 'String'>
    readonly deleted_at: FieldRef<"optiongroup", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * optiongroup findUnique
   */
  export type optiongroupFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the optiongroup
     */
    select?: optiongroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the optiongroup
     */
    omit?: optiongroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: optiongroupInclude<ExtArgs> | null
    /**
     * Filter, which optiongroup to fetch.
     */
    where: optiongroupWhereUniqueInput
  }

  /**
   * optiongroup findUniqueOrThrow
   */
  export type optiongroupFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the optiongroup
     */
    select?: optiongroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the optiongroup
     */
    omit?: optiongroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: optiongroupInclude<ExtArgs> | null
    /**
     * Filter, which optiongroup to fetch.
     */
    where: optiongroupWhereUniqueInput
  }

  /**
   * optiongroup findFirst
   */
  export type optiongroupFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the optiongroup
     */
    select?: optiongroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the optiongroup
     */
    omit?: optiongroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: optiongroupInclude<ExtArgs> | null
    /**
     * Filter, which optiongroup to fetch.
     */
    where?: optiongroupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of optiongroups to fetch.
     */
    orderBy?: optiongroupOrderByWithRelationInput | optiongroupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for optiongroups.
     */
    cursor?: optiongroupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` optiongroups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` optiongroups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of optiongroups.
     */
    distinct?: OptiongroupScalarFieldEnum | OptiongroupScalarFieldEnum[]
  }

  /**
   * optiongroup findFirstOrThrow
   */
  export type optiongroupFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the optiongroup
     */
    select?: optiongroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the optiongroup
     */
    omit?: optiongroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: optiongroupInclude<ExtArgs> | null
    /**
     * Filter, which optiongroup to fetch.
     */
    where?: optiongroupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of optiongroups to fetch.
     */
    orderBy?: optiongroupOrderByWithRelationInput | optiongroupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for optiongroups.
     */
    cursor?: optiongroupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` optiongroups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` optiongroups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of optiongroups.
     */
    distinct?: OptiongroupScalarFieldEnum | OptiongroupScalarFieldEnum[]
  }

  /**
   * optiongroup findMany
   */
  export type optiongroupFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the optiongroup
     */
    select?: optiongroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the optiongroup
     */
    omit?: optiongroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: optiongroupInclude<ExtArgs> | null
    /**
     * Filter, which optiongroups to fetch.
     */
    where?: optiongroupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of optiongroups to fetch.
     */
    orderBy?: optiongroupOrderByWithRelationInput | optiongroupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing optiongroups.
     */
    cursor?: optiongroupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` optiongroups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` optiongroups.
     */
    skip?: number
    distinct?: OptiongroupScalarFieldEnum | OptiongroupScalarFieldEnum[]
  }

  /**
   * optiongroup create
   */
  export type optiongroupCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the optiongroup
     */
    select?: optiongroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the optiongroup
     */
    omit?: optiongroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: optiongroupInclude<ExtArgs> | null
    /**
     * The data needed to create a optiongroup.
     */
    data: XOR<optiongroupCreateInput, optiongroupUncheckedCreateInput>
  }

  /**
   * optiongroup createMany
   */
  export type optiongroupCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many optiongroups.
     */
    data: optiongroupCreateManyInput | optiongroupCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * optiongroup createManyAndReturn
   */
  export type optiongroupCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the optiongroup
     */
    select?: optiongroupSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the optiongroup
     */
    omit?: optiongroupOmit<ExtArgs> | null
    /**
     * The data used to create many optiongroups.
     */
    data: optiongroupCreateManyInput | optiongroupCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: optiongroupIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * optiongroup update
   */
  export type optiongroupUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the optiongroup
     */
    select?: optiongroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the optiongroup
     */
    omit?: optiongroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: optiongroupInclude<ExtArgs> | null
    /**
     * The data needed to update a optiongroup.
     */
    data: XOR<optiongroupUpdateInput, optiongroupUncheckedUpdateInput>
    /**
     * Choose, which optiongroup to update.
     */
    where: optiongroupWhereUniqueInput
  }

  /**
   * optiongroup updateMany
   */
  export type optiongroupUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update optiongroups.
     */
    data: XOR<optiongroupUpdateManyMutationInput, optiongroupUncheckedUpdateManyInput>
    /**
     * Filter which optiongroups to update
     */
    where?: optiongroupWhereInput
    /**
     * Limit how many optiongroups to update.
     */
    limit?: number
  }

  /**
   * optiongroup updateManyAndReturn
   */
  export type optiongroupUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the optiongroup
     */
    select?: optiongroupSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the optiongroup
     */
    omit?: optiongroupOmit<ExtArgs> | null
    /**
     * The data used to update optiongroups.
     */
    data: XOR<optiongroupUpdateManyMutationInput, optiongroupUncheckedUpdateManyInput>
    /**
     * Filter which optiongroups to update
     */
    where?: optiongroupWhereInput
    /**
     * Limit how many optiongroups to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: optiongroupIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * optiongroup upsert
   */
  export type optiongroupUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the optiongroup
     */
    select?: optiongroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the optiongroup
     */
    omit?: optiongroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: optiongroupInclude<ExtArgs> | null
    /**
     * The filter to search for the optiongroup to update in case it exists.
     */
    where: optiongroupWhereUniqueInput
    /**
     * In case the optiongroup found by the `where` argument doesn't exist, create a new optiongroup with this data.
     */
    create: XOR<optiongroupCreateInput, optiongroupUncheckedCreateInput>
    /**
     * In case the optiongroup was found with the provided `where` argument, update it with this data.
     */
    update: XOR<optiongroupUpdateInput, optiongroupUncheckedUpdateInput>
  }

  /**
   * optiongroup delete
   */
  export type optiongroupDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the optiongroup
     */
    select?: optiongroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the optiongroup
     */
    omit?: optiongroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: optiongroupInclude<ExtArgs> | null
    /**
     * Filter which optiongroup to delete.
     */
    where: optiongroupWhereUniqueInput
  }

  /**
   * optiongroup deleteMany
   */
  export type optiongroupDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which optiongroups to delete
     */
    where?: optiongroupWhereInput
    /**
     * Limit how many optiongroups to delete.
     */
    limit?: number
  }

  /**
   * optiongroup.subbrand
   */
  export type optiongroup$subbrandArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the subbrand
     */
    select?: subbrandSelect<ExtArgs> | null
    /**
     * Omit specific fields from the subbrand
     */
    omit?: subbrandOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: subbrandInclude<ExtArgs> | null
    where?: subbrandWhereInput
  }

  /**
   * optiongroup.category
   */
  export type optiongroup$categoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the category
     */
    select?: categorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the category
     */
    omit?: categoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: categoryInclude<ExtArgs> | null
    where?: categoryWhereInput
  }

  /**
   * optiongroup.itemproductsales
   */
  export type optiongroup$itemproductsalesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the itemproductsale
     */
    select?: itemproductsaleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the itemproductsale
     */
    omit?: itemproductsaleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: itemproductsaleInclude<ExtArgs> | null
    where?: itemproductsaleWhereInput
    orderBy?: itemproductsaleOrderByWithRelationInput | itemproductsaleOrderByWithRelationInput[]
    cursor?: itemproductsaleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ItemproductsaleScalarFieldEnum | ItemproductsaleScalarFieldEnum[]
  }

  /**
   * optiongroup.itemitemproductsales
   */
  export type optiongroup$itemitemproductsalesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the itemitemproductsale
     */
    select?: itemitemproductsaleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the itemitemproductsale
     */
    omit?: itemitemproductsaleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: itemitemproductsaleInclude<ExtArgs> | null
    where?: itemitemproductsaleWhereInput
    orderBy?: itemitemproductsaleOrderByWithRelationInput | itemitemproductsaleOrderByWithRelationInput[]
    cursor?: itemitemproductsaleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ItemitemproductsaleScalarFieldEnum | ItemitemproductsaleScalarFieldEnum[]
  }

  /**
   * optiongroup without action
   */
  export type optiongroupDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the optiongroup
     */
    select?: optiongroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the optiongroup
     */
    omit?: optiongroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: optiongroupInclude<ExtArgs> | null
  }


  /**
   * Model item
   */

  export type AggregateItem = {
    _count: ItemCountAggregateOutputType | null
    _avg: ItemAvgAggregateOutputType | null
    _sum: ItemSumAggregateOutputType | null
    _min: ItemMinAggregateOutputType | null
    _max: ItemMaxAggregateOutputType | null
  }

  export type ItemAvgAggregateOutputType = {
    id: number | null
    brand_id: number | null
    sub_brand_id: number | null
    category_id: number | null
  }

  export type ItemSumAggregateOutputType = {
    id: number | null
    brand_id: number | null
    sub_brand_id: number | null
    category_id: number | null
  }

  export type ItemMinAggregateOutputType = {
    id: number | null
    brand_id: number | null
    sub_brand_id: number | null
    category_id: number | null
    name: string | null
    pos_uuid: string | null
    deleted_at: Date | null
  }

  export type ItemMaxAggregateOutputType = {
    id: number | null
    brand_id: number | null
    sub_brand_id: number | null
    category_id: number | null
    name: string | null
    pos_uuid: string | null
    deleted_at: Date | null
  }

  export type ItemCountAggregateOutputType = {
    id: number
    brand_id: number
    sub_brand_id: number
    category_id: number
    name: number
    pos_uuid: number
    deleted_at: number
    _all: number
  }


  export type ItemAvgAggregateInputType = {
    id?: true
    brand_id?: true
    sub_brand_id?: true
    category_id?: true
  }

  export type ItemSumAggregateInputType = {
    id?: true
    brand_id?: true
    sub_brand_id?: true
    category_id?: true
  }

  export type ItemMinAggregateInputType = {
    id?: true
    brand_id?: true
    sub_brand_id?: true
    category_id?: true
    name?: true
    pos_uuid?: true
    deleted_at?: true
  }

  export type ItemMaxAggregateInputType = {
    id?: true
    brand_id?: true
    sub_brand_id?: true
    category_id?: true
    name?: true
    pos_uuid?: true
    deleted_at?: true
  }

  export type ItemCountAggregateInputType = {
    id?: true
    brand_id?: true
    sub_brand_id?: true
    category_id?: true
    name?: true
    pos_uuid?: true
    deleted_at?: true
    _all?: true
  }

  export type ItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which item to aggregate.
     */
    where?: itemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of items to fetch.
     */
    orderBy?: itemOrderByWithRelationInput | itemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: itemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` items from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` items.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned items
    **/
    _count?: true | ItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ItemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ItemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ItemMaxAggregateInputType
  }

  export type GetItemAggregateType<T extends ItemAggregateArgs> = {
        [P in keyof T & keyof AggregateItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateItem[P]>
      : GetScalarType<T[P], AggregateItem[P]>
  }




  export type itemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: itemWhereInput
    orderBy?: itemOrderByWithAggregationInput | itemOrderByWithAggregationInput[]
    by: ItemScalarFieldEnum[] | ItemScalarFieldEnum
    having?: itemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ItemCountAggregateInputType | true
    _avg?: ItemAvgAggregateInputType
    _sum?: ItemSumAggregateInputType
    _min?: ItemMinAggregateInputType
    _max?: ItemMaxAggregateInputType
  }

  export type ItemGroupByOutputType = {
    id: number
    brand_id: number
    sub_brand_id: number | null
    category_id: number | null
    name: string
    pos_uuid: string | null
    deleted_at: Date | null
    _count: ItemCountAggregateOutputType | null
    _avg: ItemAvgAggregateOutputType | null
    _sum: ItemSumAggregateOutputType | null
    _min: ItemMinAggregateOutputType | null
    _max: ItemMaxAggregateOutputType | null
  }

  type GetItemGroupByPayload<T extends itemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ItemGroupByOutputType[P]>
            : GetScalarType<T[P], ItemGroupByOutputType[P]>
        }
      >
    >


  export type itemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    brand_id?: boolean
    sub_brand_id?: boolean
    category_id?: boolean
    name?: boolean
    pos_uuid?: boolean
    deleted_at?: boolean
    brand?: boolean | brandDefaultArgs<ExtArgs>
    subbrand?: boolean | item$subbrandArgs<ExtArgs>
    category?: boolean | item$categoryArgs<ExtArgs>
    itemproductsales?: boolean | item$itemproductsalesArgs<ExtArgs>
    itemitemproductsales?: boolean | item$itemitemproductsalesArgs<ExtArgs>
    _count?: boolean | ItemCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["item"]>

  export type itemSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    brand_id?: boolean
    sub_brand_id?: boolean
    category_id?: boolean
    name?: boolean
    pos_uuid?: boolean
    deleted_at?: boolean
    brand?: boolean | brandDefaultArgs<ExtArgs>
    subbrand?: boolean | item$subbrandArgs<ExtArgs>
    category?: boolean | item$categoryArgs<ExtArgs>
  }, ExtArgs["result"]["item"]>

  export type itemSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    brand_id?: boolean
    sub_brand_id?: boolean
    category_id?: boolean
    name?: boolean
    pos_uuid?: boolean
    deleted_at?: boolean
    brand?: boolean | brandDefaultArgs<ExtArgs>
    subbrand?: boolean | item$subbrandArgs<ExtArgs>
    category?: boolean | item$categoryArgs<ExtArgs>
  }, ExtArgs["result"]["item"]>

  export type itemSelectScalar = {
    id?: boolean
    brand_id?: boolean
    sub_brand_id?: boolean
    category_id?: boolean
    name?: boolean
    pos_uuid?: boolean
    deleted_at?: boolean
  }

  export type itemOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "brand_id" | "sub_brand_id" | "category_id" | "name" | "pos_uuid" | "deleted_at", ExtArgs["result"]["item"]>
  export type itemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    brand?: boolean | brandDefaultArgs<ExtArgs>
    subbrand?: boolean | item$subbrandArgs<ExtArgs>
    category?: boolean | item$categoryArgs<ExtArgs>
    itemproductsales?: boolean | item$itemproductsalesArgs<ExtArgs>
    itemitemproductsales?: boolean | item$itemitemproductsalesArgs<ExtArgs>
    _count?: boolean | ItemCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type itemIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    brand?: boolean | brandDefaultArgs<ExtArgs>
    subbrand?: boolean | item$subbrandArgs<ExtArgs>
    category?: boolean | item$categoryArgs<ExtArgs>
  }
  export type itemIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    brand?: boolean | brandDefaultArgs<ExtArgs>
    subbrand?: boolean | item$subbrandArgs<ExtArgs>
    category?: boolean | item$categoryArgs<ExtArgs>
  }

  export type $itemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "item"
    objects: {
      brand: Prisma.$brandPayload<ExtArgs>
      subbrand: Prisma.$subbrandPayload<ExtArgs> | null
      category: Prisma.$categoryPayload<ExtArgs> | null
      itemproductsales: Prisma.$itemproductsalePayload<ExtArgs>[]
      itemitemproductsales: Prisma.$itemitemproductsalePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      brand_id: number
      sub_brand_id: number | null
      category_id: number | null
      name: string
      pos_uuid: string | null
      deleted_at: Date | null
    }, ExtArgs["result"]["item"]>
    composites: {}
  }

  type itemGetPayload<S extends boolean | null | undefined | itemDefaultArgs> = $Result.GetResult<Prisma.$itemPayload, S>

  type itemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<itemFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ItemCountAggregateInputType | true
    }

  export interface itemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['item'], meta: { name: 'item' } }
    /**
     * Find zero or one Item that matches the filter.
     * @param {itemFindUniqueArgs} args - Arguments to find a Item
     * @example
     * // Get one Item
     * const item = await prisma.item.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends itemFindUniqueArgs>(args: SelectSubset<T, itemFindUniqueArgs<ExtArgs>>): Prisma__itemClient<$Result.GetResult<Prisma.$itemPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Item that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {itemFindUniqueOrThrowArgs} args - Arguments to find a Item
     * @example
     * // Get one Item
     * const item = await prisma.item.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends itemFindUniqueOrThrowArgs>(args: SelectSubset<T, itemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__itemClient<$Result.GetResult<Prisma.$itemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Item that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {itemFindFirstArgs} args - Arguments to find a Item
     * @example
     * // Get one Item
     * const item = await prisma.item.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends itemFindFirstArgs>(args?: SelectSubset<T, itemFindFirstArgs<ExtArgs>>): Prisma__itemClient<$Result.GetResult<Prisma.$itemPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Item that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {itemFindFirstOrThrowArgs} args - Arguments to find a Item
     * @example
     * // Get one Item
     * const item = await prisma.item.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends itemFindFirstOrThrowArgs>(args?: SelectSubset<T, itemFindFirstOrThrowArgs<ExtArgs>>): Prisma__itemClient<$Result.GetResult<Prisma.$itemPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Items that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {itemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Items
     * const items = await prisma.item.findMany()
     * 
     * // Get first 10 Items
     * const items = await prisma.item.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const itemWithIdOnly = await prisma.item.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends itemFindManyArgs>(args?: SelectSubset<T, itemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$itemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Item.
     * @param {itemCreateArgs} args - Arguments to create a Item.
     * @example
     * // Create one Item
     * const Item = await prisma.item.create({
     *   data: {
     *     // ... data to create a Item
     *   }
     * })
     * 
     */
    create<T extends itemCreateArgs>(args: SelectSubset<T, itemCreateArgs<ExtArgs>>): Prisma__itemClient<$Result.GetResult<Prisma.$itemPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Items.
     * @param {itemCreateManyArgs} args - Arguments to create many Items.
     * @example
     * // Create many Items
     * const item = await prisma.item.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends itemCreateManyArgs>(args?: SelectSubset<T, itemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Items and returns the data saved in the database.
     * @param {itemCreateManyAndReturnArgs} args - Arguments to create many Items.
     * @example
     * // Create many Items
     * const item = await prisma.item.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Items and only return the `id`
     * const itemWithIdOnly = await prisma.item.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends itemCreateManyAndReturnArgs>(args?: SelectSubset<T, itemCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$itemPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Item.
     * @param {itemDeleteArgs} args - Arguments to delete one Item.
     * @example
     * // Delete one Item
     * const Item = await prisma.item.delete({
     *   where: {
     *     // ... filter to delete one Item
     *   }
     * })
     * 
     */
    delete<T extends itemDeleteArgs>(args: SelectSubset<T, itemDeleteArgs<ExtArgs>>): Prisma__itemClient<$Result.GetResult<Prisma.$itemPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Item.
     * @param {itemUpdateArgs} args - Arguments to update one Item.
     * @example
     * // Update one Item
     * const item = await prisma.item.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends itemUpdateArgs>(args: SelectSubset<T, itemUpdateArgs<ExtArgs>>): Prisma__itemClient<$Result.GetResult<Prisma.$itemPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Items.
     * @param {itemDeleteManyArgs} args - Arguments to filter Items to delete.
     * @example
     * // Delete a few Items
     * const { count } = await prisma.item.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends itemDeleteManyArgs>(args?: SelectSubset<T, itemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Items.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {itemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Items
     * const item = await prisma.item.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends itemUpdateManyArgs>(args: SelectSubset<T, itemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Items and returns the data updated in the database.
     * @param {itemUpdateManyAndReturnArgs} args - Arguments to update many Items.
     * @example
     * // Update many Items
     * const item = await prisma.item.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Items and only return the `id`
     * const itemWithIdOnly = await prisma.item.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends itemUpdateManyAndReturnArgs>(args: SelectSubset<T, itemUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$itemPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Item.
     * @param {itemUpsertArgs} args - Arguments to update or create a Item.
     * @example
     * // Update or create a Item
     * const item = await prisma.item.upsert({
     *   create: {
     *     // ... data to create a Item
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Item we want to update
     *   }
     * })
     */
    upsert<T extends itemUpsertArgs>(args: SelectSubset<T, itemUpsertArgs<ExtArgs>>): Prisma__itemClient<$Result.GetResult<Prisma.$itemPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Items.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {itemCountArgs} args - Arguments to filter Items to count.
     * @example
     * // Count the number of Items
     * const count = await prisma.item.count({
     *   where: {
     *     // ... the filter for the Items we want to count
     *   }
     * })
    **/
    count<T extends itemCountArgs>(
      args?: Subset<T, itemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Item.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ItemAggregateArgs>(args: Subset<T, ItemAggregateArgs>): Prisma.PrismaPromise<GetItemAggregateType<T>>

    /**
     * Group by Item.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {itemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends itemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: itemGroupByArgs['orderBy'] }
        : { orderBy?: itemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, itemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the item model
   */
  readonly fields: itemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for item.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__itemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    brand<T extends brandDefaultArgs<ExtArgs> = {}>(args?: Subset<T, brandDefaultArgs<ExtArgs>>): Prisma__brandClient<$Result.GetResult<Prisma.$brandPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    subbrand<T extends item$subbrandArgs<ExtArgs> = {}>(args?: Subset<T, item$subbrandArgs<ExtArgs>>): Prisma__subbrandClient<$Result.GetResult<Prisma.$subbrandPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    category<T extends item$categoryArgs<ExtArgs> = {}>(args?: Subset<T, item$categoryArgs<ExtArgs>>): Prisma__categoryClient<$Result.GetResult<Prisma.$categoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    itemproductsales<T extends item$itemproductsalesArgs<ExtArgs> = {}>(args?: Subset<T, item$itemproductsalesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$itemproductsalePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    itemitemproductsales<T extends item$itemitemproductsalesArgs<ExtArgs> = {}>(args?: Subset<T, item$itemitemproductsalesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$itemitemproductsalePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the item model
   */
  interface itemFieldRefs {
    readonly id: FieldRef<"item", 'Int'>
    readonly brand_id: FieldRef<"item", 'Int'>
    readonly sub_brand_id: FieldRef<"item", 'Int'>
    readonly category_id: FieldRef<"item", 'Int'>
    readonly name: FieldRef<"item", 'String'>
    readonly pos_uuid: FieldRef<"item", 'String'>
    readonly deleted_at: FieldRef<"item", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * item findUnique
   */
  export type itemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the item
     */
    select?: itemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the item
     */
    omit?: itemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: itemInclude<ExtArgs> | null
    /**
     * Filter, which item to fetch.
     */
    where: itemWhereUniqueInput
  }

  /**
   * item findUniqueOrThrow
   */
  export type itemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the item
     */
    select?: itemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the item
     */
    omit?: itemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: itemInclude<ExtArgs> | null
    /**
     * Filter, which item to fetch.
     */
    where: itemWhereUniqueInput
  }

  /**
   * item findFirst
   */
  export type itemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the item
     */
    select?: itemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the item
     */
    omit?: itemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: itemInclude<ExtArgs> | null
    /**
     * Filter, which item to fetch.
     */
    where?: itemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of items to fetch.
     */
    orderBy?: itemOrderByWithRelationInput | itemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for items.
     */
    cursor?: itemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` items from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` items.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of items.
     */
    distinct?: ItemScalarFieldEnum | ItemScalarFieldEnum[]
  }

  /**
   * item findFirstOrThrow
   */
  export type itemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the item
     */
    select?: itemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the item
     */
    omit?: itemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: itemInclude<ExtArgs> | null
    /**
     * Filter, which item to fetch.
     */
    where?: itemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of items to fetch.
     */
    orderBy?: itemOrderByWithRelationInput | itemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for items.
     */
    cursor?: itemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` items from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` items.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of items.
     */
    distinct?: ItemScalarFieldEnum | ItemScalarFieldEnum[]
  }

  /**
   * item findMany
   */
  export type itemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the item
     */
    select?: itemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the item
     */
    omit?: itemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: itemInclude<ExtArgs> | null
    /**
     * Filter, which items to fetch.
     */
    where?: itemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of items to fetch.
     */
    orderBy?: itemOrderByWithRelationInput | itemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing items.
     */
    cursor?: itemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` items from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` items.
     */
    skip?: number
    distinct?: ItemScalarFieldEnum | ItemScalarFieldEnum[]
  }

  /**
   * item create
   */
  export type itemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the item
     */
    select?: itemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the item
     */
    omit?: itemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: itemInclude<ExtArgs> | null
    /**
     * The data needed to create a item.
     */
    data: XOR<itemCreateInput, itemUncheckedCreateInput>
  }

  /**
   * item createMany
   */
  export type itemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many items.
     */
    data: itemCreateManyInput | itemCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * item createManyAndReturn
   */
  export type itemCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the item
     */
    select?: itemSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the item
     */
    omit?: itemOmit<ExtArgs> | null
    /**
     * The data used to create many items.
     */
    data: itemCreateManyInput | itemCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: itemIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * item update
   */
  export type itemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the item
     */
    select?: itemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the item
     */
    omit?: itemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: itemInclude<ExtArgs> | null
    /**
     * The data needed to update a item.
     */
    data: XOR<itemUpdateInput, itemUncheckedUpdateInput>
    /**
     * Choose, which item to update.
     */
    where: itemWhereUniqueInput
  }

  /**
   * item updateMany
   */
  export type itemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update items.
     */
    data: XOR<itemUpdateManyMutationInput, itemUncheckedUpdateManyInput>
    /**
     * Filter which items to update
     */
    where?: itemWhereInput
    /**
     * Limit how many items to update.
     */
    limit?: number
  }

  /**
   * item updateManyAndReturn
   */
  export type itemUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the item
     */
    select?: itemSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the item
     */
    omit?: itemOmit<ExtArgs> | null
    /**
     * The data used to update items.
     */
    data: XOR<itemUpdateManyMutationInput, itemUncheckedUpdateManyInput>
    /**
     * Filter which items to update
     */
    where?: itemWhereInput
    /**
     * Limit how many items to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: itemIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * item upsert
   */
  export type itemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the item
     */
    select?: itemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the item
     */
    omit?: itemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: itemInclude<ExtArgs> | null
    /**
     * The filter to search for the item to update in case it exists.
     */
    where: itemWhereUniqueInput
    /**
     * In case the item found by the `where` argument doesn't exist, create a new item with this data.
     */
    create: XOR<itemCreateInput, itemUncheckedCreateInput>
    /**
     * In case the item was found with the provided `where` argument, update it with this data.
     */
    update: XOR<itemUpdateInput, itemUncheckedUpdateInput>
  }

  /**
   * item delete
   */
  export type itemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the item
     */
    select?: itemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the item
     */
    omit?: itemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: itemInclude<ExtArgs> | null
    /**
     * Filter which item to delete.
     */
    where: itemWhereUniqueInput
  }

  /**
   * item deleteMany
   */
  export type itemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which items to delete
     */
    where?: itemWhereInput
    /**
     * Limit how many items to delete.
     */
    limit?: number
  }

  /**
   * item.subbrand
   */
  export type item$subbrandArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the subbrand
     */
    select?: subbrandSelect<ExtArgs> | null
    /**
     * Omit specific fields from the subbrand
     */
    omit?: subbrandOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: subbrandInclude<ExtArgs> | null
    where?: subbrandWhereInput
  }

  /**
   * item.category
   */
  export type item$categoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the category
     */
    select?: categorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the category
     */
    omit?: categoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: categoryInclude<ExtArgs> | null
    where?: categoryWhereInput
  }

  /**
   * item.itemproductsales
   */
  export type item$itemproductsalesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the itemproductsale
     */
    select?: itemproductsaleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the itemproductsale
     */
    omit?: itemproductsaleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: itemproductsaleInclude<ExtArgs> | null
    where?: itemproductsaleWhereInput
    orderBy?: itemproductsaleOrderByWithRelationInput | itemproductsaleOrderByWithRelationInput[]
    cursor?: itemproductsaleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ItemproductsaleScalarFieldEnum | ItemproductsaleScalarFieldEnum[]
  }

  /**
   * item.itemitemproductsales
   */
  export type item$itemitemproductsalesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the itemitemproductsale
     */
    select?: itemitemproductsaleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the itemitemproductsale
     */
    omit?: itemitemproductsaleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: itemitemproductsaleInclude<ExtArgs> | null
    where?: itemitemproductsaleWhereInput
    orderBy?: itemitemproductsaleOrderByWithRelationInput | itemitemproductsaleOrderByWithRelationInput[]
    cursor?: itemitemproductsaleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ItemitemproductsaleScalarFieldEnum | ItemitemproductsaleScalarFieldEnum[]
  }

  /**
   * item without action
   */
  export type itemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the item
     */
    select?: itemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the item
     */
    omit?: itemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: itemInclude<ExtArgs> | null
  }


  /**
   * Model customer
   */

  export type AggregateCustomer = {
    _count: CustomerCountAggregateOutputType | null
    _avg: CustomerAvgAggregateOutputType | null
    _sum: CustomerSumAggregateOutputType | null
    _min: CustomerMinAggregateOutputType | null
    _max: CustomerMaxAggregateOutputType | null
  }

  export type CustomerAvgAggregateOutputType = {
    id: number | null
    store_id: number | null
    sub_brand_id: number | null
  }

  export type CustomerSumAggregateOutputType = {
    id: number | null
    store_id: number | null
    sub_brand_id: number | null
  }

  export type CustomerMinAggregateOutputType = {
    id: number | null
    customer_name: string | null
    email: string | null
    phone_number: string | null
    cpf: string | null
    birth_date: Date | null
    gender: string | null
    store_id: number | null
    sub_brand_id: number | null
    registration_origin: string | null
    agree_terms: boolean | null
    receive_promotions_email: boolean | null
    receive_promotions_sms: boolean | null
    created_at: Date | null
  }

  export type CustomerMaxAggregateOutputType = {
    id: number | null
    customer_name: string | null
    email: string | null
    phone_number: string | null
    cpf: string | null
    birth_date: Date | null
    gender: string | null
    store_id: number | null
    sub_brand_id: number | null
    registration_origin: string | null
    agree_terms: boolean | null
    receive_promotions_email: boolean | null
    receive_promotions_sms: boolean | null
    created_at: Date | null
  }

  export type CustomerCountAggregateOutputType = {
    id: number
    customer_name: number
    email: number
    phone_number: number
    cpf: number
    birth_date: number
    gender: number
    store_id: number
    sub_brand_id: number
    registration_origin: number
    agree_terms: number
    receive_promotions_email: number
    receive_promotions_sms: number
    created_at: number
    _all: number
  }


  export type CustomerAvgAggregateInputType = {
    id?: true
    store_id?: true
    sub_brand_id?: true
  }

  export type CustomerSumAggregateInputType = {
    id?: true
    store_id?: true
    sub_brand_id?: true
  }

  export type CustomerMinAggregateInputType = {
    id?: true
    customer_name?: true
    email?: true
    phone_number?: true
    cpf?: true
    birth_date?: true
    gender?: true
    store_id?: true
    sub_brand_id?: true
    registration_origin?: true
    agree_terms?: true
    receive_promotions_email?: true
    receive_promotions_sms?: true
    created_at?: true
  }

  export type CustomerMaxAggregateInputType = {
    id?: true
    customer_name?: true
    email?: true
    phone_number?: true
    cpf?: true
    birth_date?: true
    gender?: true
    store_id?: true
    sub_brand_id?: true
    registration_origin?: true
    agree_terms?: true
    receive_promotions_email?: true
    receive_promotions_sms?: true
    created_at?: true
  }

  export type CustomerCountAggregateInputType = {
    id?: true
    customer_name?: true
    email?: true
    phone_number?: true
    cpf?: true
    birth_date?: true
    gender?: true
    store_id?: true
    sub_brand_id?: true
    registration_origin?: true
    agree_terms?: true
    receive_promotions_email?: true
    receive_promotions_sms?: true
    created_at?: true
    _all?: true
  }

  export type CustomerAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which customer to aggregate.
     */
    where?: customerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of customers to fetch.
     */
    orderBy?: customerOrderByWithRelationInput | customerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: customerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` customers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` customers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned customers
    **/
    _count?: true | CustomerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CustomerAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CustomerSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CustomerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CustomerMaxAggregateInputType
  }

  export type GetCustomerAggregateType<T extends CustomerAggregateArgs> = {
        [P in keyof T & keyof AggregateCustomer]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCustomer[P]>
      : GetScalarType<T[P], AggregateCustomer[P]>
  }




  export type customerGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: customerWhereInput
    orderBy?: customerOrderByWithAggregationInput | customerOrderByWithAggregationInput[]
    by: CustomerScalarFieldEnum[] | CustomerScalarFieldEnum
    having?: customerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CustomerCountAggregateInputType | true
    _avg?: CustomerAvgAggregateInputType
    _sum?: CustomerSumAggregateInputType
    _min?: CustomerMinAggregateInputType
    _max?: CustomerMaxAggregateInputType
  }

  export type CustomerGroupByOutputType = {
    id: number
    customer_name: string | null
    email: string | null
    phone_number: string | null
    cpf: string | null
    birth_date: Date | null
    gender: string | null
    store_id: number | null
    sub_brand_id: number | null
    registration_origin: string | null
    agree_terms: boolean | null
    receive_promotions_email: boolean | null
    receive_promotions_sms: boolean | null
    created_at: Date | null
    _count: CustomerCountAggregateOutputType | null
    _avg: CustomerAvgAggregateOutputType | null
    _sum: CustomerSumAggregateOutputType | null
    _min: CustomerMinAggregateOutputType | null
    _max: CustomerMaxAggregateOutputType | null
  }

  type GetCustomerGroupByPayload<T extends customerGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CustomerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CustomerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CustomerGroupByOutputType[P]>
            : GetScalarType<T[P], CustomerGroupByOutputType[P]>
        }
      >
    >


  export type customerSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    customer_name?: boolean
    email?: boolean
    phone_number?: boolean
    cpf?: boolean
    birth_date?: boolean
    gender?: boolean
    store_id?: boolean
    sub_brand_id?: boolean
    registration_origin?: boolean
    agree_terms?: boolean
    receive_promotions_email?: boolean
    receive_promotions_sms?: boolean
    created_at?: boolean
    store?: boolean | customer$storeArgs<ExtArgs>
    subbrand?: boolean | customer$subbrandArgs<ExtArgs>
    sales?: boolean | customer$salesArgs<ExtArgs>
    _count?: boolean | CustomerCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["customer"]>

  export type customerSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    customer_name?: boolean
    email?: boolean
    phone_number?: boolean
    cpf?: boolean
    birth_date?: boolean
    gender?: boolean
    store_id?: boolean
    sub_brand_id?: boolean
    registration_origin?: boolean
    agree_terms?: boolean
    receive_promotions_email?: boolean
    receive_promotions_sms?: boolean
    created_at?: boolean
    store?: boolean | customer$storeArgs<ExtArgs>
    subbrand?: boolean | customer$subbrandArgs<ExtArgs>
  }, ExtArgs["result"]["customer"]>

  export type customerSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    customer_name?: boolean
    email?: boolean
    phone_number?: boolean
    cpf?: boolean
    birth_date?: boolean
    gender?: boolean
    store_id?: boolean
    sub_brand_id?: boolean
    registration_origin?: boolean
    agree_terms?: boolean
    receive_promotions_email?: boolean
    receive_promotions_sms?: boolean
    created_at?: boolean
    store?: boolean | customer$storeArgs<ExtArgs>
    subbrand?: boolean | customer$subbrandArgs<ExtArgs>
  }, ExtArgs["result"]["customer"]>

  export type customerSelectScalar = {
    id?: boolean
    customer_name?: boolean
    email?: boolean
    phone_number?: boolean
    cpf?: boolean
    birth_date?: boolean
    gender?: boolean
    store_id?: boolean
    sub_brand_id?: boolean
    registration_origin?: boolean
    agree_terms?: boolean
    receive_promotions_email?: boolean
    receive_promotions_sms?: boolean
    created_at?: boolean
  }

  export type customerOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "customer_name" | "email" | "phone_number" | "cpf" | "birth_date" | "gender" | "store_id" | "sub_brand_id" | "registration_origin" | "agree_terms" | "receive_promotions_email" | "receive_promotions_sms" | "created_at", ExtArgs["result"]["customer"]>
  export type customerInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    store?: boolean | customer$storeArgs<ExtArgs>
    subbrand?: boolean | customer$subbrandArgs<ExtArgs>
    sales?: boolean | customer$salesArgs<ExtArgs>
    _count?: boolean | CustomerCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type customerIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    store?: boolean | customer$storeArgs<ExtArgs>
    subbrand?: boolean | customer$subbrandArgs<ExtArgs>
  }
  export type customerIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    store?: boolean | customer$storeArgs<ExtArgs>
    subbrand?: boolean | customer$subbrandArgs<ExtArgs>
  }

  export type $customerPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "customer"
    objects: {
      store: Prisma.$storePayload<ExtArgs> | null
      subbrand: Prisma.$subbrandPayload<ExtArgs> | null
      sales: Prisma.$salePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      customer_name: string | null
      email: string | null
      phone_number: string | null
      cpf: string | null
      birth_date: Date | null
      gender: string | null
      store_id: number | null
      sub_brand_id: number | null
      registration_origin: string | null
      agree_terms: boolean | null
      receive_promotions_email: boolean | null
      receive_promotions_sms: boolean | null
      created_at: Date | null
    }, ExtArgs["result"]["customer"]>
    composites: {}
  }

  type customerGetPayload<S extends boolean | null | undefined | customerDefaultArgs> = $Result.GetResult<Prisma.$customerPayload, S>

  type customerCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<customerFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CustomerCountAggregateInputType | true
    }

  export interface customerDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['customer'], meta: { name: 'customer' } }
    /**
     * Find zero or one Customer that matches the filter.
     * @param {customerFindUniqueArgs} args - Arguments to find a Customer
     * @example
     * // Get one Customer
     * const customer = await prisma.customer.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends customerFindUniqueArgs>(args: SelectSubset<T, customerFindUniqueArgs<ExtArgs>>): Prisma__customerClient<$Result.GetResult<Prisma.$customerPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Customer that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {customerFindUniqueOrThrowArgs} args - Arguments to find a Customer
     * @example
     * // Get one Customer
     * const customer = await prisma.customer.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends customerFindUniqueOrThrowArgs>(args: SelectSubset<T, customerFindUniqueOrThrowArgs<ExtArgs>>): Prisma__customerClient<$Result.GetResult<Prisma.$customerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Customer that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {customerFindFirstArgs} args - Arguments to find a Customer
     * @example
     * // Get one Customer
     * const customer = await prisma.customer.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends customerFindFirstArgs>(args?: SelectSubset<T, customerFindFirstArgs<ExtArgs>>): Prisma__customerClient<$Result.GetResult<Prisma.$customerPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Customer that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {customerFindFirstOrThrowArgs} args - Arguments to find a Customer
     * @example
     * // Get one Customer
     * const customer = await prisma.customer.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends customerFindFirstOrThrowArgs>(args?: SelectSubset<T, customerFindFirstOrThrowArgs<ExtArgs>>): Prisma__customerClient<$Result.GetResult<Prisma.$customerPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Customers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {customerFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Customers
     * const customers = await prisma.customer.findMany()
     * 
     * // Get first 10 Customers
     * const customers = await prisma.customer.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const customerWithIdOnly = await prisma.customer.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends customerFindManyArgs>(args?: SelectSubset<T, customerFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$customerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Customer.
     * @param {customerCreateArgs} args - Arguments to create a Customer.
     * @example
     * // Create one Customer
     * const Customer = await prisma.customer.create({
     *   data: {
     *     // ... data to create a Customer
     *   }
     * })
     * 
     */
    create<T extends customerCreateArgs>(args: SelectSubset<T, customerCreateArgs<ExtArgs>>): Prisma__customerClient<$Result.GetResult<Prisma.$customerPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Customers.
     * @param {customerCreateManyArgs} args - Arguments to create many Customers.
     * @example
     * // Create many Customers
     * const customer = await prisma.customer.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends customerCreateManyArgs>(args?: SelectSubset<T, customerCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Customers and returns the data saved in the database.
     * @param {customerCreateManyAndReturnArgs} args - Arguments to create many Customers.
     * @example
     * // Create many Customers
     * const customer = await prisma.customer.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Customers and only return the `id`
     * const customerWithIdOnly = await prisma.customer.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends customerCreateManyAndReturnArgs>(args?: SelectSubset<T, customerCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$customerPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Customer.
     * @param {customerDeleteArgs} args - Arguments to delete one Customer.
     * @example
     * // Delete one Customer
     * const Customer = await prisma.customer.delete({
     *   where: {
     *     // ... filter to delete one Customer
     *   }
     * })
     * 
     */
    delete<T extends customerDeleteArgs>(args: SelectSubset<T, customerDeleteArgs<ExtArgs>>): Prisma__customerClient<$Result.GetResult<Prisma.$customerPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Customer.
     * @param {customerUpdateArgs} args - Arguments to update one Customer.
     * @example
     * // Update one Customer
     * const customer = await prisma.customer.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends customerUpdateArgs>(args: SelectSubset<T, customerUpdateArgs<ExtArgs>>): Prisma__customerClient<$Result.GetResult<Prisma.$customerPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Customers.
     * @param {customerDeleteManyArgs} args - Arguments to filter Customers to delete.
     * @example
     * // Delete a few Customers
     * const { count } = await prisma.customer.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends customerDeleteManyArgs>(args?: SelectSubset<T, customerDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Customers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {customerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Customers
     * const customer = await prisma.customer.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends customerUpdateManyArgs>(args: SelectSubset<T, customerUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Customers and returns the data updated in the database.
     * @param {customerUpdateManyAndReturnArgs} args - Arguments to update many Customers.
     * @example
     * // Update many Customers
     * const customer = await prisma.customer.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Customers and only return the `id`
     * const customerWithIdOnly = await prisma.customer.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends customerUpdateManyAndReturnArgs>(args: SelectSubset<T, customerUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$customerPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Customer.
     * @param {customerUpsertArgs} args - Arguments to update or create a Customer.
     * @example
     * // Update or create a Customer
     * const customer = await prisma.customer.upsert({
     *   create: {
     *     // ... data to create a Customer
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Customer we want to update
     *   }
     * })
     */
    upsert<T extends customerUpsertArgs>(args: SelectSubset<T, customerUpsertArgs<ExtArgs>>): Prisma__customerClient<$Result.GetResult<Prisma.$customerPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Customers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {customerCountArgs} args - Arguments to filter Customers to count.
     * @example
     * // Count the number of Customers
     * const count = await prisma.customer.count({
     *   where: {
     *     // ... the filter for the Customers we want to count
     *   }
     * })
    **/
    count<T extends customerCountArgs>(
      args?: Subset<T, customerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CustomerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Customer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CustomerAggregateArgs>(args: Subset<T, CustomerAggregateArgs>): Prisma.PrismaPromise<GetCustomerAggregateType<T>>

    /**
     * Group by Customer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {customerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends customerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: customerGroupByArgs['orderBy'] }
        : { orderBy?: customerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, customerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCustomerGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the customer model
   */
  readonly fields: customerFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for customer.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__customerClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    store<T extends customer$storeArgs<ExtArgs> = {}>(args?: Subset<T, customer$storeArgs<ExtArgs>>): Prisma__storeClient<$Result.GetResult<Prisma.$storePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    subbrand<T extends customer$subbrandArgs<ExtArgs> = {}>(args?: Subset<T, customer$subbrandArgs<ExtArgs>>): Prisma__subbrandClient<$Result.GetResult<Prisma.$subbrandPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    sales<T extends customer$salesArgs<ExtArgs> = {}>(args?: Subset<T, customer$salesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$salePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the customer model
   */
  interface customerFieldRefs {
    readonly id: FieldRef<"customer", 'Int'>
    readonly customer_name: FieldRef<"customer", 'String'>
    readonly email: FieldRef<"customer", 'String'>
    readonly phone_number: FieldRef<"customer", 'String'>
    readonly cpf: FieldRef<"customer", 'String'>
    readonly birth_date: FieldRef<"customer", 'DateTime'>
    readonly gender: FieldRef<"customer", 'String'>
    readonly store_id: FieldRef<"customer", 'Int'>
    readonly sub_brand_id: FieldRef<"customer", 'Int'>
    readonly registration_origin: FieldRef<"customer", 'String'>
    readonly agree_terms: FieldRef<"customer", 'Boolean'>
    readonly receive_promotions_email: FieldRef<"customer", 'Boolean'>
    readonly receive_promotions_sms: FieldRef<"customer", 'Boolean'>
    readonly created_at: FieldRef<"customer", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * customer findUnique
   */
  export type customerFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the customer
     */
    select?: customerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the customer
     */
    omit?: customerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: customerInclude<ExtArgs> | null
    /**
     * Filter, which customer to fetch.
     */
    where: customerWhereUniqueInput
  }

  /**
   * customer findUniqueOrThrow
   */
  export type customerFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the customer
     */
    select?: customerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the customer
     */
    omit?: customerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: customerInclude<ExtArgs> | null
    /**
     * Filter, which customer to fetch.
     */
    where: customerWhereUniqueInput
  }

  /**
   * customer findFirst
   */
  export type customerFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the customer
     */
    select?: customerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the customer
     */
    omit?: customerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: customerInclude<ExtArgs> | null
    /**
     * Filter, which customer to fetch.
     */
    where?: customerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of customers to fetch.
     */
    orderBy?: customerOrderByWithRelationInput | customerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for customers.
     */
    cursor?: customerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` customers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` customers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of customers.
     */
    distinct?: CustomerScalarFieldEnum | CustomerScalarFieldEnum[]
  }

  /**
   * customer findFirstOrThrow
   */
  export type customerFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the customer
     */
    select?: customerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the customer
     */
    omit?: customerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: customerInclude<ExtArgs> | null
    /**
     * Filter, which customer to fetch.
     */
    where?: customerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of customers to fetch.
     */
    orderBy?: customerOrderByWithRelationInput | customerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for customers.
     */
    cursor?: customerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` customers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` customers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of customers.
     */
    distinct?: CustomerScalarFieldEnum | CustomerScalarFieldEnum[]
  }

  /**
   * customer findMany
   */
  export type customerFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the customer
     */
    select?: customerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the customer
     */
    omit?: customerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: customerInclude<ExtArgs> | null
    /**
     * Filter, which customers to fetch.
     */
    where?: customerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of customers to fetch.
     */
    orderBy?: customerOrderByWithRelationInput | customerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing customers.
     */
    cursor?: customerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` customers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` customers.
     */
    skip?: number
    distinct?: CustomerScalarFieldEnum | CustomerScalarFieldEnum[]
  }

  /**
   * customer create
   */
  export type customerCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the customer
     */
    select?: customerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the customer
     */
    omit?: customerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: customerInclude<ExtArgs> | null
    /**
     * The data needed to create a customer.
     */
    data?: XOR<customerCreateInput, customerUncheckedCreateInput>
  }

  /**
   * customer createMany
   */
  export type customerCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many customers.
     */
    data: customerCreateManyInput | customerCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * customer createManyAndReturn
   */
  export type customerCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the customer
     */
    select?: customerSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the customer
     */
    omit?: customerOmit<ExtArgs> | null
    /**
     * The data used to create many customers.
     */
    data: customerCreateManyInput | customerCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: customerIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * customer update
   */
  export type customerUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the customer
     */
    select?: customerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the customer
     */
    omit?: customerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: customerInclude<ExtArgs> | null
    /**
     * The data needed to update a customer.
     */
    data: XOR<customerUpdateInput, customerUncheckedUpdateInput>
    /**
     * Choose, which customer to update.
     */
    where: customerWhereUniqueInput
  }

  /**
   * customer updateMany
   */
  export type customerUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update customers.
     */
    data: XOR<customerUpdateManyMutationInput, customerUncheckedUpdateManyInput>
    /**
     * Filter which customers to update
     */
    where?: customerWhereInput
    /**
     * Limit how many customers to update.
     */
    limit?: number
  }

  /**
   * customer updateManyAndReturn
   */
  export type customerUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the customer
     */
    select?: customerSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the customer
     */
    omit?: customerOmit<ExtArgs> | null
    /**
     * The data used to update customers.
     */
    data: XOR<customerUpdateManyMutationInput, customerUncheckedUpdateManyInput>
    /**
     * Filter which customers to update
     */
    where?: customerWhereInput
    /**
     * Limit how many customers to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: customerIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * customer upsert
   */
  export type customerUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the customer
     */
    select?: customerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the customer
     */
    omit?: customerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: customerInclude<ExtArgs> | null
    /**
     * The filter to search for the customer to update in case it exists.
     */
    where: customerWhereUniqueInput
    /**
     * In case the customer found by the `where` argument doesn't exist, create a new customer with this data.
     */
    create: XOR<customerCreateInput, customerUncheckedCreateInput>
    /**
     * In case the customer was found with the provided `where` argument, update it with this data.
     */
    update: XOR<customerUpdateInput, customerUncheckedUpdateInput>
  }

  /**
   * customer delete
   */
  export type customerDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the customer
     */
    select?: customerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the customer
     */
    omit?: customerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: customerInclude<ExtArgs> | null
    /**
     * Filter which customer to delete.
     */
    where: customerWhereUniqueInput
  }

  /**
   * customer deleteMany
   */
  export type customerDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which customers to delete
     */
    where?: customerWhereInput
    /**
     * Limit how many customers to delete.
     */
    limit?: number
  }

  /**
   * customer.store
   */
  export type customer$storeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the store
     */
    select?: storeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the store
     */
    omit?: storeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: storeInclude<ExtArgs> | null
    where?: storeWhereInput
  }

  /**
   * customer.subbrand
   */
  export type customer$subbrandArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the subbrand
     */
    select?: subbrandSelect<ExtArgs> | null
    /**
     * Omit specific fields from the subbrand
     */
    omit?: subbrandOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: subbrandInclude<ExtArgs> | null
    where?: subbrandWhereInput
  }

  /**
   * customer.sales
   */
  export type customer$salesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sale
     */
    select?: saleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sale
     */
    omit?: saleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: saleInclude<ExtArgs> | null
    where?: saleWhereInput
    orderBy?: saleOrderByWithRelationInput | saleOrderByWithRelationInput[]
    cursor?: saleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SaleScalarFieldEnum | SaleScalarFieldEnum[]
  }

  /**
   * customer without action
   */
  export type customerDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the customer
     */
    select?: customerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the customer
     */
    omit?: customerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: customerInclude<ExtArgs> | null
  }


  /**
   * Model sale
   */

  export type AggregateSale = {
    _count: SaleCountAggregateOutputType | null
    _avg: SaleAvgAggregateOutputType | null
    _sum: SaleSumAggregateOutputType | null
    _min: SaleMinAggregateOutputType | null
    _max: SaleMaxAggregateOutputType | null
  }

  export type SaleAvgAggregateOutputType = {
    id: number | null
    store_id: number | null
    sub_brand_id: number | null
    customer_id: number | null
    channel_id: number | null
    total_amount_items: Decimal | null
    total_discount: Decimal | null
    total_increase: Decimal | null
    delivery_fee: Decimal | null
    service_tax_fee: Decimal | null
    total_amount: Decimal | null
    value_paid: Decimal | null
    production_seconds: number | null
    delivery_seconds: number | null
    people_quantity: number | null
  }

  export type SaleSumAggregateOutputType = {
    id: number | null
    store_id: number | null
    sub_brand_id: number | null
    customer_id: number | null
    channel_id: number | null
    total_amount_items: Decimal | null
    total_discount: Decimal | null
    total_increase: Decimal | null
    delivery_fee: Decimal | null
    service_tax_fee: Decimal | null
    total_amount: Decimal | null
    value_paid: Decimal | null
    production_seconds: number | null
    delivery_seconds: number | null
    people_quantity: number | null
  }

  export type SaleMinAggregateOutputType = {
    id: number | null
    store_id: number | null
    sub_brand_id: number | null
    customer_id: number | null
    channel_id: number | null
    cod_sale1: string | null
    cod_sale2: string | null
    created_at: Date | null
    customer_name: string | null
    sale_status_desc: string | null
    total_amount_items: Decimal | null
    total_discount: Decimal | null
    total_increase: Decimal | null
    delivery_fee: Decimal | null
    service_tax_fee: Decimal | null
    total_amount: Decimal | null
    value_paid: Decimal | null
    production_seconds: number | null
    delivery_seconds: number | null
    people_quantity: number | null
    discount_reason: string | null
    increase_reason: string | null
    origin: string | null
  }

  export type SaleMaxAggregateOutputType = {
    id: number | null
    store_id: number | null
    sub_brand_id: number | null
    customer_id: number | null
    channel_id: number | null
    cod_sale1: string | null
    cod_sale2: string | null
    created_at: Date | null
    customer_name: string | null
    sale_status_desc: string | null
    total_amount_items: Decimal | null
    total_discount: Decimal | null
    total_increase: Decimal | null
    delivery_fee: Decimal | null
    service_tax_fee: Decimal | null
    total_amount: Decimal | null
    value_paid: Decimal | null
    production_seconds: number | null
    delivery_seconds: number | null
    people_quantity: number | null
    discount_reason: string | null
    increase_reason: string | null
    origin: string | null
  }

  export type SaleCountAggregateOutputType = {
    id: number
    store_id: number
    sub_brand_id: number
    customer_id: number
    channel_id: number
    cod_sale1: number
    cod_sale2: number
    created_at: number
    customer_name: number
    sale_status_desc: number
    total_amount_items: number
    total_discount: number
    total_increase: number
    delivery_fee: number
    service_tax_fee: number
    total_amount: number
    value_paid: number
    production_seconds: number
    delivery_seconds: number
    people_quantity: number
    discount_reason: number
    increase_reason: number
    origin: number
    _all: number
  }


  export type SaleAvgAggregateInputType = {
    id?: true
    store_id?: true
    sub_brand_id?: true
    customer_id?: true
    channel_id?: true
    total_amount_items?: true
    total_discount?: true
    total_increase?: true
    delivery_fee?: true
    service_tax_fee?: true
    total_amount?: true
    value_paid?: true
    production_seconds?: true
    delivery_seconds?: true
    people_quantity?: true
  }

  export type SaleSumAggregateInputType = {
    id?: true
    store_id?: true
    sub_brand_id?: true
    customer_id?: true
    channel_id?: true
    total_amount_items?: true
    total_discount?: true
    total_increase?: true
    delivery_fee?: true
    service_tax_fee?: true
    total_amount?: true
    value_paid?: true
    production_seconds?: true
    delivery_seconds?: true
    people_quantity?: true
  }

  export type SaleMinAggregateInputType = {
    id?: true
    store_id?: true
    sub_brand_id?: true
    customer_id?: true
    channel_id?: true
    cod_sale1?: true
    cod_sale2?: true
    created_at?: true
    customer_name?: true
    sale_status_desc?: true
    total_amount_items?: true
    total_discount?: true
    total_increase?: true
    delivery_fee?: true
    service_tax_fee?: true
    total_amount?: true
    value_paid?: true
    production_seconds?: true
    delivery_seconds?: true
    people_quantity?: true
    discount_reason?: true
    increase_reason?: true
    origin?: true
  }

  export type SaleMaxAggregateInputType = {
    id?: true
    store_id?: true
    sub_brand_id?: true
    customer_id?: true
    channel_id?: true
    cod_sale1?: true
    cod_sale2?: true
    created_at?: true
    customer_name?: true
    sale_status_desc?: true
    total_amount_items?: true
    total_discount?: true
    total_increase?: true
    delivery_fee?: true
    service_tax_fee?: true
    total_amount?: true
    value_paid?: true
    production_seconds?: true
    delivery_seconds?: true
    people_quantity?: true
    discount_reason?: true
    increase_reason?: true
    origin?: true
  }

  export type SaleCountAggregateInputType = {
    id?: true
    store_id?: true
    sub_brand_id?: true
    customer_id?: true
    channel_id?: true
    cod_sale1?: true
    cod_sale2?: true
    created_at?: true
    customer_name?: true
    sale_status_desc?: true
    total_amount_items?: true
    total_discount?: true
    total_increase?: true
    delivery_fee?: true
    service_tax_fee?: true
    total_amount?: true
    value_paid?: true
    production_seconds?: true
    delivery_seconds?: true
    people_quantity?: true
    discount_reason?: true
    increase_reason?: true
    origin?: true
    _all?: true
  }

  export type SaleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which sale to aggregate.
     */
    where?: saleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of sales to fetch.
     */
    orderBy?: saleOrderByWithRelationInput | saleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: saleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` sales from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` sales.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned sales
    **/
    _count?: true | SaleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SaleAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SaleSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SaleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SaleMaxAggregateInputType
  }

  export type GetSaleAggregateType<T extends SaleAggregateArgs> = {
        [P in keyof T & keyof AggregateSale]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSale[P]>
      : GetScalarType<T[P], AggregateSale[P]>
  }




  export type saleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: saleWhereInput
    orderBy?: saleOrderByWithAggregationInput | saleOrderByWithAggregationInput[]
    by: SaleScalarFieldEnum[] | SaleScalarFieldEnum
    having?: saleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SaleCountAggregateInputType | true
    _avg?: SaleAvgAggregateInputType
    _sum?: SaleSumAggregateInputType
    _min?: SaleMinAggregateInputType
    _max?: SaleMaxAggregateInputType
  }

  export type SaleGroupByOutputType = {
    id: number
    store_id: number
    sub_brand_id: number | null
    customer_id: number | null
    channel_id: number
    cod_sale1: string | null
    cod_sale2: string | null
    created_at: Date
    customer_name: string | null
    sale_status_desc: string
    total_amount_items: Decimal
    total_discount: Decimal | null
    total_increase: Decimal | null
    delivery_fee: Decimal | null
    service_tax_fee: Decimal | null
    total_amount: Decimal
    value_paid: Decimal | null
    production_seconds: number | null
    delivery_seconds: number | null
    people_quantity: number | null
    discount_reason: string | null
    increase_reason: string | null
    origin: string | null
    _count: SaleCountAggregateOutputType | null
    _avg: SaleAvgAggregateOutputType | null
    _sum: SaleSumAggregateOutputType | null
    _min: SaleMinAggregateOutputType | null
    _max: SaleMaxAggregateOutputType | null
  }

  type GetSaleGroupByPayload<T extends saleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SaleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SaleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SaleGroupByOutputType[P]>
            : GetScalarType<T[P], SaleGroupByOutputType[P]>
        }
      >
    >


  export type saleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    store_id?: boolean
    sub_brand_id?: boolean
    customer_id?: boolean
    channel_id?: boolean
    cod_sale1?: boolean
    cod_sale2?: boolean
    created_at?: boolean
    customer_name?: boolean
    sale_status_desc?: boolean
    total_amount_items?: boolean
    total_discount?: boolean
    total_increase?: boolean
    delivery_fee?: boolean
    service_tax_fee?: boolean
    total_amount?: boolean
    value_paid?: boolean
    production_seconds?: boolean
    delivery_seconds?: boolean
    people_quantity?: boolean
    discount_reason?: boolean
    increase_reason?: boolean
    origin?: boolean
    store?: boolean | storeDefaultArgs<ExtArgs>
    subbrand?: boolean | sale$subbrandArgs<ExtArgs>
    customer?: boolean | sale$customerArgs<ExtArgs>
    channel?: boolean | channelDefaultArgs<ExtArgs>
    productsales?: boolean | sale$productsalesArgs<ExtArgs>
    deliverysales?: boolean | sale$deliverysalesArgs<ExtArgs>
    deliveryaddress?: boolean | sale$deliveryaddressArgs<ExtArgs>
    payments?: boolean | sale$paymentsArgs<ExtArgs>
    couponsales?: boolean | sale$couponsalesArgs<ExtArgs>
    _count?: boolean | SaleCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["sale"]>

  export type saleSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    store_id?: boolean
    sub_brand_id?: boolean
    customer_id?: boolean
    channel_id?: boolean
    cod_sale1?: boolean
    cod_sale2?: boolean
    created_at?: boolean
    customer_name?: boolean
    sale_status_desc?: boolean
    total_amount_items?: boolean
    total_discount?: boolean
    total_increase?: boolean
    delivery_fee?: boolean
    service_tax_fee?: boolean
    total_amount?: boolean
    value_paid?: boolean
    production_seconds?: boolean
    delivery_seconds?: boolean
    people_quantity?: boolean
    discount_reason?: boolean
    increase_reason?: boolean
    origin?: boolean
    store?: boolean | storeDefaultArgs<ExtArgs>
    subbrand?: boolean | sale$subbrandArgs<ExtArgs>
    customer?: boolean | sale$customerArgs<ExtArgs>
    channel?: boolean | channelDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["sale"]>

  export type saleSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    store_id?: boolean
    sub_brand_id?: boolean
    customer_id?: boolean
    channel_id?: boolean
    cod_sale1?: boolean
    cod_sale2?: boolean
    created_at?: boolean
    customer_name?: boolean
    sale_status_desc?: boolean
    total_amount_items?: boolean
    total_discount?: boolean
    total_increase?: boolean
    delivery_fee?: boolean
    service_tax_fee?: boolean
    total_amount?: boolean
    value_paid?: boolean
    production_seconds?: boolean
    delivery_seconds?: boolean
    people_quantity?: boolean
    discount_reason?: boolean
    increase_reason?: boolean
    origin?: boolean
    store?: boolean | storeDefaultArgs<ExtArgs>
    subbrand?: boolean | sale$subbrandArgs<ExtArgs>
    customer?: boolean | sale$customerArgs<ExtArgs>
    channel?: boolean | channelDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["sale"]>

  export type saleSelectScalar = {
    id?: boolean
    store_id?: boolean
    sub_brand_id?: boolean
    customer_id?: boolean
    channel_id?: boolean
    cod_sale1?: boolean
    cod_sale2?: boolean
    created_at?: boolean
    customer_name?: boolean
    sale_status_desc?: boolean
    total_amount_items?: boolean
    total_discount?: boolean
    total_increase?: boolean
    delivery_fee?: boolean
    service_tax_fee?: boolean
    total_amount?: boolean
    value_paid?: boolean
    production_seconds?: boolean
    delivery_seconds?: boolean
    people_quantity?: boolean
    discount_reason?: boolean
    increase_reason?: boolean
    origin?: boolean
  }

  export type saleOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "store_id" | "sub_brand_id" | "customer_id" | "channel_id" | "cod_sale1" | "cod_sale2" | "created_at" | "customer_name" | "sale_status_desc" | "total_amount_items" | "total_discount" | "total_increase" | "delivery_fee" | "service_tax_fee" | "total_amount" | "value_paid" | "production_seconds" | "delivery_seconds" | "people_quantity" | "discount_reason" | "increase_reason" | "origin", ExtArgs["result"]["sale"]>
  export type saleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    store?: boolean | storeDefaultArgs<ExtArgs>
    subbrand?: boolean | sale$subbrandArgs<ExtArgs>
    customer?: boolean | sale$customerArgs<ExtArgs>
    channel?: boolean | channelDefaultArgs<ExtArgs>
    productsales?: boolean | sale$productsalesArgs<ExtArgs>
    deliverysales?: boolean | sale$deliverysalesArgs<ExtArgs>
    deliveryaddress?: boolean | sale$deliveryaddressArgs<ExtArgs>
    payments?: boolean | sale$paymentsArgs<ExtArgs>
    couponsales?: boolean | sale$couponsalesArgs<ExtArgs>
    _count?: boolean | SaleCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type saleIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    store?: boolean | storeDefaultArgs<ExtArgs>
    subbrand?: boolean | sale$subbrandArgs<ExtArgs>
    customer?: boolean | sale$customerArgs<ExtArgs>
    channel?: boolean | channelDefaultArgs<ExtArgs>
  }
  export type saleIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    store?: boolean | storeDefaultArgs<ExtArgs>
    subbrand?: boolean | sale$subbrandArgs<ExtArgs>
    customer?: boolean | sale$customerArgs<ExtArgs>
    channel?: boolean | channelDefaultArgs<ExtArgs>
  }

  export type $salePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "sale"
    objects: {
      store: Prisma.$storePayload<ExtArgs>
      subbrand: Prisma.$subbrandPayload<ExtArgs> | null
      customer: Prisma.$customerPayload<ExtArgs> | null
      channel: Prisma.$channelPayload<ExtArgs>
      productsales: Prisma.$productsalePayload<ExtArgs>[]
      deliverysales: Prisma.$deliverysalePayload<ExtArgs>[]
      deliveryaddress: Prisma.$deliveryaddressPayload<ExtArgs>[]
      payments: Prisma.$paymentPayload<ExtArgs>[]
      couponsales: Prisma.$couponsalePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      store_id: number
      sub_brand_id: number | null
      customer_id: number | null
      channel_id: number
      cod_sale1: string | null
      cod_sale2: string | null
      created_at: Date
      customer_name: string | null
      sale_status_desc: string
      total_amount_items: Prisma.Decimal
      total_discount: Prisma.Decimal | null
      total_increase: Prisma.Decimal | null
      delivery_fee: Prisma.Decimal | null
      service_tax_fee: Prisma.Decimal | null
      total_amount: Prisma.Decimal
      value_paid: Prisma.Decimal | null
      production_seconds: number | null
      delivery_seconds: number | null
      people_quantity: number | null
      discount_reason: string | null
      increase_reason: string | null
      origin: string | null
    }, ExtArgs["result"]["sale"]>
    composites: {}
  }

  type saleGetPayload<S extends boolean | null | undefined | saleDefaultArgs> = $Result.GetResult<Prisma.$salePayload, S>

  type saleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<saleFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SaleCountAggregateInputType | true
    }

  export interface saleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['sale'], meta: { name: 'sale' } }
    /**
     * Find zero or one Sale that matches the filter.
     * @param {saleFindUniqueArgs} args - Arguments to find a Sale
     * @example
     * // Get one Sale
     * const sale = await prisma.sale.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends saleFindUniqueArgs>(args: SelectSubset<T, saleFindUniqueArgs<ExtArgs>>): Prisma__saleClient<$Result.GetResult<Prisma.$salePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Sale that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {saleFindUniqueOrThrowArgs} args - Arguments to find a Sale
     * @example
     * // Get one Sale
     * const sale = await prisma.sale.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends saleFindUniqueOrThrowArgs>(args: SelectSubset<T, saleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__saleClient<$Result.GetResult<Prisma.$salePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Sale that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {saleFindFirstArgs} args - Arguments to find a Sale
     * @example
     * // Get one Sale
     * const sale = await prisma.sale.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends saleFindFirstArgs>(args?: SelectSubset<T, saleFindFirstArgs<ExtArgs>>): Prisma__saleClient<$Result.GetResult<Prisma.$salePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Sale that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {saleFindFirstOrThrowArgs} args - Arguments to find a Sale
     * @example
     * // Get one Sale
     * const sale = await prisma.sale.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends saleFindFirstOrThrowArgs>(args?: SelectSubset<T, saleFindFirstOrThrowArgs<ExtArgs>>): Prisma__saleClient<$Result.GetResult<Prisma.$salePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Sales that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {saleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Sales
     * const sales = await prisma.sale.findMany()
     * 
     * // Get first 10 Sales
     * const sales = await prisma.sale.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const saleWithIdOnly = await prisma.sale.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends saleFindManyArgs>(args?: SelectSubset<T, saleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$salePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Sale.
     * @param {saleCreateArgs} args - Arguments to create a Sale.
     * @example
     * // Create one Sale
     * const Sale = await prisma.sale.create({
     *   data: {
     *     // ... data to create a Sale
     *   }
     * })
     * 
     */
    create<T extends saleCreateArgs>(args: SelectSubset<T, saleCreateArgs<ExtArgs>>): Prisma__saleClient<$Result.GetResult<Prisma.$salePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Sales.
     * @param {saleCreateManyArgs} args - Arguments to create many Sales.
     * @example
     * // Create many Sales
     * const sale = await prisma.sale.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends saleCreateManyArgs>(args?: SelectSubset<T, saleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Sales and returns the data saved in the database.
     * @param {saleCreateManyAndReturnArgs} args - Arguments to create many Sales.
     * @example
     * // Create many Sales
     * const sale = await prisma.sale.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Sales and only return the `id`
     * const saleWithIdOnly = await prisma.sale.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends saleCreateManyAndReturnArgs>(args?: SelectSubset<T, saleCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$salePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Sale.
     * @param {saleDeleteArgs} args - Arguments to delete one Sale.
     * @example
     * // Delete one Sale
     * const Sale = await prisma.sale.delete({
     *   where: {
     *     // ... filter to delete one Sale
     *   }
     * })
     * 
     */
    delete<T extends saleDeleteArgs>(args: SelectSubset<T, saleDeleteArgs<ExtArgs>>): Prisma__saleClient<$Result.GetResult<Prisma.$salePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Sale.
     * @param {saleUpdateArgs} args - Arguments to update one Sale.
     * @example
     * // Update one Sale
     * const sale = await prisma.sale.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends saleUpdateArgs>(args: SelectSubset<T, saleUpdateArgs<ExtArgs>>): Prisma__saleClient<$Result.GetResult<Prisma.$salePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Sales.
     * @param {saleDeleteManyArgs} args - Arguments to filter Sales to delete.
     * @example
     * // Delete a few Sales
     * const { count } = await prisma.sale.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends saleDeleteManyArgs>(args?: SelectSubset<T, saleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sales.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {saleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Sales
     * const sale = await prisma.sale.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends saleUpdateManyArgs>(args: SelectSubset<T, saleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sales and returns the data updated in the database.
     * @param {saleUpdateManyAndReturnArgs} args - Arguments to update many Sales.
     * @example
     * // Update many Sales
     * const sale = await prisma.sale.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Sales and only return the `id`
     * const saleWithIdOnly = await prisma.sale.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends saleUpdateManyAndReturnArgs>(args: SelectSubset<T, saleUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$salePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Sale.
     * @param {saleUpsertArgs} args - Arguments to update or create a Sale.
     * @example
     * // Update or create a Sale
     * const sale = await prisma.sale.upsert({
     *   create: {
     *     // ... data to create a Sale
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Sale we want to update
     *   }
     * })
     */
    upsert<T extends saleUpsertArgs>(args: SelectSubset<T, saleUpsertArgs<ExtArgs>>): Prisma__saleClient<$Result.GetResult<Prisma.$salePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Sales.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {saleCountArgs} args - Arguments to filter Sales to count.
     * @example
     * // Count the number of Sales
     * const count = await prisma.sale.count({
     *   where: {
     *     // ... the filter for the Sales we want to count
     *   }
     * })
    **/
    count<T extends saleCountArgs>(
      args?: Subset<T, saleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SaleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Sale.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SaleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SaleAggregateArgs>(args: Subset<T, SaleAggregateArgs>): Prisma.PrismaPromise<GetSaleAggregateType<T>>

    /**
     * Group by Sale.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {saleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends saleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: saleGroupByArgs['orderBy'] }
        : { orderBy?: saleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, saleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSaleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the sale model
   */
  readonly fields: saleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for sale.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__saleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    store<T extends storeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, storeDefaultArgs<ExtArgs>>): Prisma__storeClient<$Result.GetResult<Prisma.$storePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    subbrand<T extends sale$subbrandArgs<ExtArgs> = {}>(args?: Subset<T, sale$subbrandArgs<ExtArgs>>): Prisma__subbrandClient<$Result.GetResult<Prisma.$subbrandPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    customer<T extends sale$customerArgs<ExtArgs> = {}>(args?: Subset<T, sale$customerArgs<ExtArgs>>): Prisma__customerClient<$Result.GetResult<Prisma.$customerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    channel<T extends channelDefaultArgs<ExtArgs> = {}>(args?: Subset<T, channelDefaultArgs<ExtArgs>>): Prisma__channelClient<$Result.GetResult<Prisma.$channelPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    productsales<T extends sale$productsalesArgs<ExtArgs> = {}>(args?: Subset<T, sale$productsalesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$productsalePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    deliverysales<T extends sale$deliverysalesArgs<ExtArgs> = {}>(args?: Subset<T, sale$deliverysalesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$deliverysalePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    deliveryaddress<T extends sale$deliveryaddressArgs<ExtArgs> = {}>(args?: Subset<T, sale$deliveryaddressArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$deliveryaddressPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    payments<T extends sale$paymentsArgs<ExtArgs> = {}>(args?: Subset<T, sale$paymentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$paymentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    couponsales<T extends sale$couponsalesArgs<ExtArgs> = {}>(args?: Subset<T, sale$couponsalesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$couponsalePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the sale model
   */
  interface saleFieldRefs {
    readonly id: FieldRef<"sale", 'Int'>
    readonly store_id: FieldRef<"sale", 'Int'>
    readonly sub_brand_id: FieldRef<"sale", 'Int'>
    readonly customer_id: FieldRef<"sale", 'Int'>
    readonly channel_id: FieldRef<"sale", 'Int'>
    readonly cod_sale1: FieldRef<"sale", 'String'>
    readonly cod_sale2: FieldRef<"sale", 'String'>
    readonly created_at: FieldRef<"sale", 'DateTime'>
    readonly customer_name: FieldRef<"sale", 'String'>
    readonly sale_status_desc: FieldRef<"sale", 'String'>
    readonly total_amount_items: FieldRef<"sale", 'Decimal'>
    readonly total_discount: FieldRef<"sale", 'Decimal'>
    readonly total_increase: FieldRef<"sale", 'Decimal'>
    readonly delivery_fee: FieldRef<"sale", 'Decimal'>
    readonly service_tax_fee: FieldRef<"sale", 'Decimal'>
    readonly total_amount: FieldRef<"sale", 'Decimal'>
    readonly value_paid: FieldRef<"sale", 'Decimal'>
    readonly production_seconds: FieldRef<"sale", 'Int'>
    readonly delivery_seconds: FieldRef<"sale", 'Int'>
    readonly people_quantity: FieldRef<"sale", 'Int'>
    readonly discount_reason: FieldRef<"sale", 'String'>
    readonly increase_reason: FieldRef<"sale", 'String'>
    readonly origin: FieldRef<"sale", 'String'>
  }
    

  // Custom InputTypes
  /**
   * sale findUnique
   */
  export type saleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sale
     */
    select?: saleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sale
     */
    omit?: saleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: saleInclude<ExtArgs> | null
    /**
     * Filter, which sale to fetch.
     */
    where: saleWhereUniqueInput
  }

  /**
   * sale findUniqueOrThrow
   */
  export type saleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sale
     */
    select?: saleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sale
     */
    omit?: saleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: saleInclude<ExtArgs> | null
    /**
     * Filter, which sale to fetch.
     */
    where: saleWhereUniqueInput
  }

  /**
   * sale findFirst
   */
  export type saleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sale
     */
    select?: saleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sale
     */
    omit?: saleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: saleInclude<ExtArgs> | null
    /**
     * Filter, which sale to fetch.
     */
    where?: saleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of sales to fetch.
     */
    orderBy?: saleOrderByWithRelationInput | saleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for sales.
     */
    cursor?: saleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` sales from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` sales.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of sales.
     */
    distinct?: SaleScalarFieldEnum | SaleScalarFieldEnum[]
  }

  /**
   * sale findFirstOrThrow
   */
  export type saleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sale
     */
    select?: saleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sale
     */
    omit?: saleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: saleInclude<ExtArgs> | null
    /**
     * Filter, which sale to fetch.
     */
    where?: saleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of sales to fetch.
     */
    orderBy?: saleOrderByWithRelationInput | saleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for sales.
     */
    cursor?: saleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` sales from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` sales.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of sales.
     */
    distinct?: SaleScalarFieldEnum | SaleScalarFieldEnum[]
  }

  /**
   * sale findMany
   */
  export type saleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sale
     */
    select?: saleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sale
     */
    omit?: saleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: saleInclude<ExtArgs> | null
    /**
     * Filter, which sales to fetch.
     */
    where?: saleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of sales to fetch.
     */
    orderBy?: saleOrderByWithRelationInput | saleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing sales.
     */
    cursor?: saleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` sales from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` sales.
     */
    skip?: number
    distinct?: SaleScalarFieldEnum | SaleScalarFieldEnum[]
  }

  /**
   * sale create
   */
  export type saleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sale
     */
    select?: saleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sale
     */
    omit?: saleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: saleInclude<ExtArgs> | null
    /**
     * The data needed to create a sale.
     */
    data: XOR<saleCreateInput, saleUncheckedCreateInput>
  }

  /**
   * sale createMany
   */
  export type saleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many sales.
     */
    data: saleCreateManyInput | saleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * sale createManyAndReturn
   */
  export type saleCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sale
     */
    select?: saleSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the sale
     */
    omit?: saleOmit<ExtArgs> | null
    /**
     * The data used to create many sales.
     */
    data: saleCreateManyInput | saleCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: saleIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * sale update
   */
  export type saleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sale
     */
    select?: saleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sale
     */
    omit?: saleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: saleInclude<ExtArgs> | null
    /**
     * The data needed to update a sale.
     */
    data: XOR<saleUpdateInput, saleUncheckedUpdateInput>
    /**
     * Choose, which sale to update.
     */
    where: saleWhereUniqueInput
  }

  /**
   * sale updateMany
   */
  export type saleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update sales.
     */
    data: XOR<saleUpdateManyMutationInput, saleUncheckedUpdateManyInput>
    /**
     * Filter which sales to update
     */
    where?: saleWhereInput
    /**
     * Limit how many sales to update.
     */
    limit?: number
  }

  /**
   * sale updateManyAndReturn
   */
  export type saleUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sale
     */
    select?: saleSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the sale
     */
    omit?: saleOmit<ExtArgs> | null
    /**
     * The data used to update sales.
     */
    data: XOR<saleUpdateManyMutationInput, saleUncheckedUpdateManyInput>
    /**
     * Filter which sales to update
     */
    where?: saleWhereInput
    /**
     * Limit how many sales to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: saleIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * sale upsert
   */
  export type saleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sale
     */
    select?: saleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sale
     */
    omit?: saleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: saleInclude<ExtArgs> | null
    /**
     * The filter to search for the sale to update in case it exists.
     */
    where: saleWhereUniqueInput
    /**
     * In case the sale found by the `where` argument doesn't exist, create a new sale with this data.
     */
    create: XOR<saleCreateInput, saleUncheckedCreateInput>
    /**
     * In case the sale was found with the provided `where` argument, update it with this data.
     */
    update: XOR<saleUpdateInput, saleUncheckedUpdateInput>
  }

  /**
   * sale delete
   */
  export type saleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sale
     */
    select?: saleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sale
     */
    omit?: saleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: saleInclude<ExtArgs> | null
    /**
     * Filter which sale to delete.
     */
    where: saleWhereUniqueInput
  }

  /**
   * sale deleteMany
   */
  export type saleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which sales to delete
     */
    where?: saleWhereInput
    /**
     * Limit how many sales to delete.
     */
    limit?: number
  }

  /**
   * sale.subbrand
   */
  export type sale$subbrandArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the subbrand
     */
    select?: subbrandSelect<ExtArgs> | null
    /**
     * Omit specific fields from the subbrand
     */
    omit?: subbrandOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: subbrandInclude<ExtArgs> | null
    where?: subbrandWhereInput
  }

  /**
   * sale.customer
   */
  export type sale$customerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the customer
     */
    select?: customerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the customer
     */
    omit?: customerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: customerInclude<ExtArgs> | null
    where?: customerWhereInput
  }

  /**
   * sale.productsales
   */
  export type sale$productsalesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the productsale
     */
    select?: productsaleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the productsale
     */
    omit?: productsaleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: productsaleInclude<ExtArgs> | null
    where?: productsaleWhereInput
    orderBy?: productsaleOrderByWithRelationInput | productsaleOrderByWithRelationInput[]
    cursor?: productsaleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductsaleScalarFieldEnum | ProductsaleScalarFieldEnum[]
  }

  /**
   * sale.deliverysales
   */
  export type sale$deliverysalesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the deliverysale
     */
    select?: deliverysaleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the deliverysale
     */
    omit?: deliverysaleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: deliverysaleInclude<ExtArgs> | null
    where?: deliverysaleWhereInput
    orderBy?: deliverysaleOrderByWithRelationInput | deliverysaleOrderByWithRelationInput[]
    cursor?: deliverysaleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DeliverysaleScalarFieldEnum | DeliverysaleScalarFieldEnum[]
  }

  /**
   * sale.deliveryaddress
   */
  export type sale$deliveryaddressArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the deliveryaddress
     */
    select?: deliveryaddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the deliveryaddress
     */
    omit?: deliveryaddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: deliveryaddressInclude<ExtArgs> | null
    where?: deliveryaddressWhereInput
    orderBy?: deliveryaddressOrderByWithRelationInput | deliveryaddressOrderByWithRelationInput[]
    cursor?: deliveryaddressWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DeliveryaddressScalarFieldEnum | DeliveryaddressScalarFieldEnum[]
  }

  /**
   * sale.payments
   */
  export type sale$paymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payment
     */
    select?: paymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payment
     */
    omit?: paymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: paymentInclude<ExtArgs> | null
    where?: paymentWhereInput
    orderBy?: paymentOrderByWithRelationInput | paymentOrderByWithRelationInput[]
    cursor?: paymentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * sale.couponsales
   */
  export type sale$couponsalesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the couponsale
     */
    select?: couponsaleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the couponsale
     */
    omit?: couponsaleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: couponsaleInclude<ExtArgs> | null
    where?: couponsaleWhereInput
    orderBy?: couponsaleOrderByWithRelationInput | couponsaleOrderByWithRelationInput[]
    cursor?: couponsaleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CouponsaleScalarFieldEnum | CouponsaleScalarFieldEnum[]
  }

  /**
   * sale without action
   */
  export type saleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sale
     */
    select?: saleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sale
     */
    omit?: saleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: saleInclude<ExtArgs> | null
  }


  /**
   * Model productsale
   */

  export type AggregateProductsale = {
    _count: ProductsaleCountAggregateOutputType | null
    _avg: ProductsaleAvgAggregateOutputType | null
    _sum: ProductsaleSumAggregateOutputType | null
    _min: ProductsaleMinAggregateOutputType | null
    _max: ProductsaleMaxAggregateOutputType | null
  }

  export type ProductsaleAvgAggregateOutputType = {
    id: number | null
    sale_id: number | null
    product_id: number | null
    quantity: number | null
    base_price: number | null
    total_price: number | null
  }

  export type ProductsaleSumAggregateOutputType = {
    id: number | null
    sale_id: number | null
    product_id: number | null
    quantity: number | null
    base_price: number | null
    total_price: number | null
  }

  export type ProductsaleMinAggregateOutputType = {
    id: number | null
    sale_id: number | null
    product_id: number | null
    quantity: number | null
    base_price: number | null
    total_price: number | null
    observations: string | null
  }

  export type ProductsaleMaxAggregateOutputType = {
    id: number | null
    sale_id: number | null
    product_id: number | null
    quantity: number | null
    base_price: number | null
    total_price: number | null
    observations: string | null
  }

  export type ProductsaleCountAggregateOutputType = {
    id: number
    sale_id: number
    product_id: number
    quantity: number
    base_price: number
    total_price: number
    observations: number
    _all: number
  }


  export type ProductsaleAvgAggregateInputType = {
    id?: true
    sale_id?: true
    product_id?: true
    quantity?: true
    base_price?: true
    total_price?: true
  }

  export type ProductsaleSumAggregateInputType = {
    id?: true
    sale_id?: true
    product_id?: true
    quantity?: true
    base_price?: true
    total_price?: true
  }

  export type ProductsaleMinAggregateInputType = {
    id?: true
    sale_id?: true
    product_id?: true
    quantity?: true
    base_price?: true
    total_price?: true
    observations?: true
  }

  export type ProductsaleMaxAggregateInputType = {
    id?: true
    sale_id?: true
    product_id?: true
    quantity?: true
    base_price?: true
    total_price?: true
    observations?: true
  }

  export type ProductsaleCountAggregateInputType = {
    id?: true
    sale_id?: true
    product_id?: true
    quantity?: true
    base_price?: true
    total_price?: true
    observations?: true
    _all?: true
  }

  export type ProductsaleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which productsale to aggregate.
     */
    where?: productsaleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of productsales to fetch.
     */
    orderBy?: productsaleOrderByWithRelationInput | productsaleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: productsaleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` productsales from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` productsales.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned productsales
    **/
    _count?: true | ProductsaleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProductsaleAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProductsaleSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProductsaleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProductsaleMaxAggregateInputType
  }

  export type GetProductsaleAggregateType<T extends ProductsaleAggregateArgs> = {
        [P in keyof T & keyof AggregateProductsale]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProductsale[P]>
      : GetScalarType<T[P], AggregateProductsale[P]>
  }




  export type productsaleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: productsaleWhereInput
    orderBy?: productsaleOrderByWithAggregationInput | productsaleOrderByWithAggregationInput[]
    by: ProductsaleScalarFieldEnum[] | ProductsaleScalarFieldEnum
    having?: productsaleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProductsaleCountAggregateInputType | true
    _avg?: ProductsaleAvgAggregateInputType
    _sum?: ProductsaleSumAggregateInputType
    _min?: ProductsaleMinAggregateInputType
    _max?: ProductsaleMaxAggregateInputType
  }

  export type ProductsaleGroupByOutputType = {
    id: number
    sale_id: number
    product_id: number
    quantity: number
    base_price: number
    total_price: number
    observations: string | null
    _count: ProductsaleCountAggregateOutputType | null
    _avg: ProductsaleAvgAggregateOutputType | null
    _sum: ProductsaleSumAggregateOutputType | null
    _min: ProductsaleMinAggregateOutputType | null
    _max: ProductsaleMaxAggregateOutputType | null
  }

  type GetProductsaleGroupByPayload<T extends productsaleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProductsaleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProductsaleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProductsaleGroupByOutputType[P]>
            : GetScalarType<T[P], ProductsaleGroupByOutputType[P]>
        }
      >
    >


  export type productsaleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sale_id?: boolean
    product_id?: boolean
    quantity?: boolean
    base_price?: boolean
    total_price?: boolean
    observations?: boolean
    sale?: boolean | saleDefaultArgs<ExtArgs>
    product?: boolean | productDefaultArgs<ExtArgs>
    itemproductsales?: boolean | productsale$itemproductsalesArgs<ExtArgs>
    _count?: boolean | ProductsaleCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["productsale"]>

  export type productsaleSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sale_id?: boolean
    product_id?: boolean
    quantity?: boolean
    base_price?: boolean
    total_price?: boolean
    observations?: boolean
    sale?: boolean | saleDefaultArgs<ExtArgs>
    product?: boolean | productDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["productsale"]>

  export type productsaleSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sale_id?: boolean
    product_id?: boolean
    quantity?: boolean
    base_price?: boolean
    total_price?: boolean
    observations?: boolean
    sale?: boolean | saleDefaultArgs<ExtArgs>
    product?: boolean | productDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["productsale"]>

  export type productsaleSelectScalar = {
    id?: boolean
    sale_id?: boolean
    product_id?: boolean
    quantity?: boolean
    base_price?: boolean
    total_price?: boolean
    observations?: boolean
  }

  export type productsaleOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "sale_id" | "product_id" | "quantity" | "base_price" | "total_price" | "observations", ExtArgs["result"]["productsale"]>
  export type productsaleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sale?: boolean | saleDefaultArgs<ExtArgs>
    product?: boolean | productDefaultArgs<ExtArgs>
    itemproductsales?: boolean | productsale$itemproductsalesArgs<ExtArgs>
    _count?: boolean | ProductsaleCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type productsaleIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sale?: boolean | saleDefaultArgs<ExtArgs>
    product?: boolean | productDefaultArgs<ExtArgs>
  }
  export type productsaleIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sale?: boolean | saleDefaultArgs<ExtArgs>
    product?: boolean | productDefaultArgs<ExtArgs>
  }

  export type $productsalePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "productsale"
    objects: {
      sale: Prisma.$salePayload<ExtArgs>
      product: Prisma.$productPayload<ExtArgs>
      itemproductsales: Prisma.$itemproductsalePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      sale_id: number
      product_id: number
      quantity: number
      base_price: number
      total_price: number
      observations: string | null
    }, ExtArgs["result"]["productsale"]>
    composites: {}
  }

  type productsaleGetPayload<S extends boolean | null | undefined | productsaleDefaultArgs> = $Result.GetResult<Prisma.$productsalePayload, S>

  type productsaleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<productsaleFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProductsaleCountAggregateInputType | true
    }

  export interface productsaleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['productsale'], meta: { name: 'productsale' } }
    /**
     * Find zero or one Productsale that matches the filter.
     * @param {productsaleFindUniqueArgs} args - Arguments to find a Productsale
     * @example
     * // Get one Productsale
     * const productsale = await prisma.productsale.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends productsaleFindUniqueArgs>(args: SelectSubset<T, productsaleFindUniqueArgs<ExtArgs>>): Prisma__productsaleClient<$Result.GetResult<Prisma.$productsalePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Productsale that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {productsaleFindUniqueOrThrowArgs} args - Arguments to find a Productsale
     * @example
     * // Get one Productsale
     * const productsale = await prisma.productsale.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends productsaleFindUniqueOrThrowArgs>(args: SelectSubset<T, productsaleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__productsaleClient<$Result.GetResult<Prisma.$productsalePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Productsale that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {productsaleFindFirstArgs} args - Arguments to find a Productsale
     * @example
     * // Get one Productsale
     * const productsale = await prisma.productsale.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends productsaleFindFirstArgs>(args?: SelectSubset<T, productsaleFindFirstArgs<ExtArgs>>): Prisma__productsaleClient<$Result.GetResult<Prisma.$productsalePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Productsale that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {productsaleFindFirstOrThrowArgs} args - Arguments to find a Productsale
     * @example
     * // Get one Productsale
     * const productsale = await prisma.productsale.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends productsaleFindFirstOrThrowArgs>(args?: SelectSubset<T, productsaleFindFirstOrThrowArgs<ExtArgs>>): Prisma__productsaleClient<$Result.GetResult<Prisma.$productsalePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Productsales that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {productsaleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Productsales
     * const productsales = await prisma.productsale.findMany()
     * 
     * // Get first 10 Productsales
     * const productsales = await prisma.productsale.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const productsaleWithIdOnly = await prisma.productsale.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends productsaleFindManyArgs>(args?: SelectSubset<T, productsaleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$productsalePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Productsale.
     * @param {productsaleCreateArgs} args - Arguments to create a Productsale.
     * @example
     * // Create one Productsale
     * const Productsale = await prisma.productsale.create({
     *   data: {
     *     // ... data to create a Productsale
     *   }
     * })
     * 
     */
    create<T extends productsaleCreateArgs>(args: SelectSubset<T, productsaleCreateArgs<ExtArgs>>): Prisma__productsaleClient<$Result.GetResult<Prisma.$productsalePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Productsales.
     * @param {productsaleCreateManyArgs} args - Arguments to create many Productsales.
     * @example
     * // Create many Productsales
     * const productsale = await prisma.productsale.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends productsaleCreateManyArgs>(args?: SelectSubset<T, productsaleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Productsales and returns the data saved in the database.
     * @param {productsaleCreateManyAndReturnArgs} args - Arguments to create many Productsales.
     * @example
     * // Create many Productsales
     * const productsale = await prisma.productsale.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Productsales and only return the `id`
     * const productsaleWithIdOnly = await prisma.productsale.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends productsaleCreateManyAndReturnArgs>(args?: SelectSubset<T, productsaleCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$productsalePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Productsale.
     * @param {productsaleDeleteArgs} args - Arguments to delete one Productsale.
     * @example
     * // Delete one Productsale
     * const Productsale = await prisma.productsale.delete({
     *   where: {
     *     // ... filter to delete one Productsale
     *   }
     * })
     * 
     */
    delete<T extends productsaleDeleteArgs>(args: SelectSubset<T, productsaleDeleteArgs<ExtArgs>>): Prisma__productsaleClient<$Result.GetResult<Prisma.$productsalePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Productsale.
     * @param {productsaleUpdateArgs} args - Arguments to update one Productsale.
     * @example
     * // Update one Productsale
     * const productsale = await prisma.productsale.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends productsaleUpdateArgs>(args: SelectSubset<T, productsaleUpdateArgs<ExtArgs>>): Prisma__productsaleClient<$Result.GetResult<Prisma.$productsalePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Productsales.
     * @param {productsaleDeleteManyArgs} args - Arguments to filter Productsales to delete.
     * @example
     * // Delete a few Productsales
     * const { count } = await prisma.productsale.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends productsaleDeleteManyArgs>(args?: SelectSubset<T, productsaleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Productsales.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {productsaleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Productsales
     * const productsale = await prisma.productsale.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends productsaleUpdateManyArgs>(args: SelectSubset<T, productsaleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Productsales and returns the data updated in the database.
     * @param {productsaleUpdateManyAndReturnArgs} args - Arguments to update many Productsales.
     * @example
     * // Update many Productsales
     * const productsale = await prisma.productsale.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Productsales and only return the `id`
     * const productsaleWithIdOnly = await prisma.productsale.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends productsaleUpdateManyAndReturnArgs>(args: SelectSubset<T, productsaleUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$productsalePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Productsale.
     * @param {productsaleUpsertArgs} args - Arguments to update or create a Productsale.
     * @example
     * // Update or create a Productsale
     * const productsale = await prisma.productsale.upsert({
     *   create: {
     *     // ... data to create a Productsale
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Productsale we want to update
     *   }
     * })
     */
    upsert<T extends productsaleUpsertArgs>(args: SelectSubset<T, productsaleUpsertArgs<ExtArgs>>): Prisma__productsaleClient<$Result.GetResult<Prisma.$productsalePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Productsales.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {productsaleCountArgs} args - Arguments to filter Productsales to count.
     * @example
     * // Count the number of Productsales
     * const count = await prisma.productsale.count({
     *   where: {
     *     // ... the filter for the Productsales we want to count
     *   }
     * })
    **/
    count<T extends productsaleCountArgs>(
      args?: Subset<T, productsaleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProductsaleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Productsale.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductsaleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProductsaleAggregateArgs>(args: Subset<T, ProductsaleAggregateArgs>): Prisma.PrismaPromise<GetProductsaleAggregateType<T>>

    /**
     * Group by Productsale.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {productsaleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends productsaleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: productsaleGroupByArgs['orderBy'] }
        : { orderBy?: productsaleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, productsaleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProductsaleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the productsale model
   */
  readonly fields: productsaleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for productsale.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__productsaleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    sale<T extends saleDefaultArgs<ExtArgs> = {}>(args?: Subset<T, saleDefaultArgs<ExtArgs>>): Prisma__saleClient<$Result.GetResult<Prisma.$salePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    product<T extends productDefaultArgs<ExtArgs> = {}>(args?: Subset<T, productDefaultArgs<ExtArgs>>): Prisma__productClient<$Result.GetResult<Prisma.$productPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    itemproductsales<T extends productsale$itemproductsalesArgs<ExtArgs> = {}>(args?: Subset<T, productsale$itemproductsalesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$itemproductsalePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the productsale model
   */
  interface productsaleFieldRefs {
    readonly id: FieldRef<"productsale", 'Int'>
    readonly sale_id: FieldRef<"productsale", 'Int'>
    readonly product_id: FieldRef<"productsale", 'Int'>
    readonly quantity: FieldRef<"productsale", 'Float'>
    readonly base_price: FieldRef<"productsale", 'Float'>
    readonly total_price: FieldRef<"productsale", 'Float'>
    readonly observations: FieldRef<"productsale", 'String'>
  }
    

  // Custom InputTypes
  /**
   * productsale findUnique
   */
  export type productsaleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the productsale
     */
    select?: productsaleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the productsale
     */
    omit?: productsaleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: productsaleInclude<ExtArgs> | null
    /**
     * Filter, which productsale to fetch.
     */
    where: productsaleWhereUniqueInput
  }

  /**
   * productsale findUniqueOrThrow
   */
  export type productsaleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the productsale
     */
    select?: productsaleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the productsale
     */
    omit?: productsaleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: productsaleInclude<ExtArgs> | null
    /**
     * Filter, which productsale to fetch.
     */
    where: productsaleWhereUniqueInput
  }

  /**
   * productsale findFirst
   */
  export type productsaleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the productsale
     */
    select?: productsaleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the productsale
     */
    omit?: productsaleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: productsaleInclude<ExtArgs> | null
    /**
     * Filter, which productsale to fetch.
     */
    where?: productsaleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of productsales to fetch.
     */
    orderBy?: productsaleOrderByWithRelationInput | productsaleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for productsales.
     */
    cursor?: productsaleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` productsales from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` productsales.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of productsales.
     */
    distinct?: ProductsaleScalarFieldEnum | ProductsaleScalarFieldEnum[]
  }

  /**
   * productsale findFirstOrThrow
   */
  export type productsaleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the productsale
     */
    select?: productsaleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the productsale
     */
    omit?: productsaleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: productsaleInclude<ExtArgs> | null
    /**
     * Filter, which productsale to fetch.
     */
    where?: productsaleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of productsales to fetch.
     */
    orderBy?: productsaleOrderByWithRelationInput | productsaleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for productsales.
     */
    cursor?: productsaleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` productsales from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` productsales.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of productsales.
     */
    distinct?: ProductsaleScalarFieldEnum | ProductsaleScalarFieldEnum[]
  }

  /**
   * productsale findMany
   */
  export type productsaleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the productsale
     */
    select?: productsaleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the productsale
     */
    omit?: productsaleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: productsaleInclude<ExtArgs> | null
    /**
     * Filter, which productsales to fetch.
     */
    where?: productsaleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of productsales to fetch.
     */
    orderBy?: productsaleOrderByWithRelationInput | productsaleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing productsales.
     */
    cursor?: productsaleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` productsales from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` productsales.
     */
    skip?: number
    distinct?: ProductsaleScalarFieldEnum | ProductsaleScalarFieldEnum[]
  }

  /**
   * productsale create
   */
  export type productsaleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the productsale
     */
    select?: productsaleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the productsale
     */
    omit?: productsaleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: productsaleInclude<ExtArgs> | null
    /**
     * The data needed to create a productsale.
     */
    data: XOR<productsaleCreateInput, productsaleUncheckedCreateInput>
  }

  /**
   * productsale createMany
   */
  export type productsaleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many productsales.
     */
    data: productsaleCreateManyInput | productsaleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * productsale createManyAndReturn
   */
  export type productsaleCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the productsale
     */
    select?: productsaleSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the productsale
     */
    omit?: productsaleOmit<ExtArgs> | null
    /**
     * The data used to create many productsales.
     */
    data: productsaleCreateManyInput | productsaleCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: productsaleIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * productsale update
   */
  export type productsaleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the productsale
     */
    select?: productsaleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the productsale
     */
    omit?: productsaleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: productsaleInclude<ExtArgs> | null
    /**
     * The data needed to update a productsale.
     */
    data: XOR<productsaleUpdateInput, productsaleUncheckedUpdateInput>
    /**
     * Choose, which productsale to update.
     */
    where: productsaleWhereUniqueInput
  }

  /**
   * productsale updateMany
   */
  export type productsaleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update productsales.
     */
    data: XOR<productsaleUpdateManyMutationInput, productsaleUncheckedUpdateManyInput>
    /**
     * Filter which productsales to update
     */
    where?: productsaleWhereInput
    /**
     * Limit how many productsales to update.
     */
    limit?: number
  }

  /**
   * productsale updateManyAndReturn
   */
  export type productsaleUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the productsale
     */
    select?: productsaleSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the productsale
     */
    omit?: productsaleOmit<ExtArgs> | null
    /**
     * The data used to update productsales.
     */
    data: XOR<productsaleUpdateManyMutationInput, productsaleUncheckedUpdateManyInput>
    /**
     * Filter which productsales to update
     */
    where?: productsaleWhereInput
    /**
     * Limit how many productsales to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: productsaleIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * productsale upsert
   */
  export type productsaleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the productsale
     */
    select?: productsaleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the productsale
     */
    omit?: productsaleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: productsaleInclude<ExtArgs> | null
    /**
     * The filter to search for the productsale to update in case it exists.
     */
    where: productsaleWhereUniqueInput
    /**
     * In case the productsale found by the `where` argument doesn't exist, create a new productsale with this data.
     */
    create: XOR<productsaleCreateInput, productsaleUncheckedCreateInput>
    /**
     * In case the productsale was found with the provided `where` argument, update it with this data.
     */
    update: XOR<productsaleUpdateInput, productsaleUncheckedUpdateInput>
  }

  /**
   * productsale delete
   */
  export type productsaleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the productsale
     */
    select?: productsaleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the productsale
     */
    omit?: productsaleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: productsaleInclude<ExtArgs> | null
    /**
     * Filter which productsale to delete.
     */
    where: productsaleWhereUniqueInput
  }

  /**
   * productsale deleteMany
   */
  export type productsaleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which productsales to delete
     */
    where?: productsaleWhereInput
    /**
     * Limit how many productsales to delete.
     */
    limit?: number
  }

  /**
   * productsale.itemproductsales
   */
  export type productsale$itemproductsalesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the itemproductsale
     */
    select?: itemproductsaleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the itemproductsale
     */
    omit?: itemproductsaleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: itemproductsaleInclude<ExtArgs> | null
    where?: itemproductsaleWhereInput
    orderBy?: itemproductsaleOrderByWithRelationInput | itemproductsaleOrderByWithRelationInput[]
    cursor?: itemproductsaleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ItemproductsaleScalarFieldEnum | ItemproductsaleScalarFieldEnum[]
  }

  /**
   * productsale without action
   */
  export type productsaleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the productsale
     */
    select?: productsaleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the productsale
     */
    omit?: productsaleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: productsaleInclude<ExtArgs> | null
  }


  /**
   * Model itemproductsale
   */

  export type AggregateItemproductsale = {
    _count: ItemproductsaleCountAggregateOutputType | null
    _avg: ItemproductsaleAvgAggregateOutputType | null
    _sum: ItemproductsaleSumAggregateOutputType | null
    _min: ItemproductsaleMinAggregateOutputType | null
    _max: ItemproductsaleMaxAggregateOutputType | null
  }

  export type ItemproductsaleAvgAggregateOutputType = {
    id: number | null
    product_sale_id: number | null
    item_id: number | null
    option_group_id: number | null
    quantity: number | null
    additional_price: number | null
    price: number | null
    amount: number | null
  }

  export type ItemproductsaleSumAggregateOutputType = {
    id: number | null
    product_sale_id: number | null
    item_id: number | null
    option_group_id: number | null
    quantity: number | null
    additional_price: number | null
    price: number | null
    amount: number | null
  }

  export type ItemproductsaleMinAggregateOutputType = {
    id: number | null
    product_sale_id: number | null
    item_id: number | null
    option_group_id: number | null
    quantity: number | null
    additional_price: number | null
    price: number | null
    amount: number | null
    observations: string | null
  }

  export type ItemproductsaleMaxAggregateOutputType = {
    id: number | null
    product_sale_id: number | null
    item_id: number | null
    option_group_id: number | null
    quantity: number | null
    additional_price: number | null
    price: number | null
    amount: number | null
    observations: string | null
  }

  export type ItemproductsaleCountAggregateOutputType = {
    id: number
    product_sale_id: number
    item_id: number
    option_group_id: number
    quantity: number
    additional_price: number
    price: number
    amount: number
    observations: number
    _all: number
  }


  export type ItemproductsaleAvgAggregateInputType = {
    id?: true
    product_sale_id?: true
    item_id?: true
    option_group_id?: true
    quantity?: true
    additional_price?: true
    price?: true
    amount?: true
  }

  export type ItemproductsaleSumAggregateInputType = {
    id?: true
    product_sale_id?: true
    item_id?: true
    option_group_id?: true
    quantity?: true
    additional_price?: true
    price?: true
    amount?: true
  }

  export type ItemproductsaleMinAggregateInputType = {
    id?: true
    product_sale_id?: true
    item_id?: true
    option_group_id?: true
    quantity?: true
    additional_price?: true
    price?: true
    amount?: true
    observations?: true
  }

  export type ItemproductsaleMaxAggregateInputType = {
    id?: true
    product_sale_id?: true
    item_id?: true
    option_group_id?: true
    quantity?: true
    additional_price?: true
    price?: true
    amount?: true
    observations?: true
  }

  export type ItemproductsaleCountAggregateInputType = {
    id?: true
    product_sale_id?: true
    item_id?: true
    option_group_id?: true
    quantity?: true
    additional_price?: true
    price?: true
    amount?: true
    observations?: true
    _all?: true
  }

  export type ItemproductsaleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which itemproductsale to aggregate.
     */
    where?: itemproductsaleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of itemproductsales to fetch.
     */
    orderBy?: itemproductsaleOrderByWithRelationInput | itemproductsaleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: itemproductsaleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` itemproductsales from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` itemproductsales.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned itemproductsales
    **/
    _count?: true | ItemproductsaleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ItemproductsaleAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ItemproductsaleSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ItemproductsaleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ItemproductsaleMaxAggregateInputType
  }

  export type GetItemproductsaleAggregateType<T extends ItemproductsaleAggregateArgs> = {
        [P in keyof T & keyof AggregateItemproductsale]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateItemproductsale[P]>
      : GetScalarType<T[P], AggregateItemproductsale[P]>
  }




  export type itemproductsaleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: itemproductsaleWhereInput
    orderBy?: itemproductsaleOrderByWithAggregationInput | itemproductsaleOrderByWithAggregationInput[]
    by: ItemproductsaleScalarFieldEnum[] | ItemproductsaleScalarFieldEnum
    having?: itemproductsaleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ItemproductsaleCountAggregateInputType | true
    _avg?: ItemproductsaleAvgAggregateInputType
    _sum?: ItemproductsaleSumAggregateInputType
    _min?: ItemproductsaleMinAggregateInputType
    _max?: ItemproductsaleMaxAggregateInputType
  }

  export type ItemproductsaleGroupByOutputType = {
    id: number
    product_sale_id: number
    item_id: number
    option_group_id: number | null
    quantity: number
    additional_price: number
    price: number
    amount: number | null
    observations: string | null
    _count: ItemproductsaleCountAggregateOutputType | null
    _avg: ItemproductsaleAvgAggregateOutputType | null
    _sum: ItemproductsaleSumAggregateOutputType | null
    _min: ItemproductsaleMinAggregateOutputType | null
    _max: ItemproductsaleMaxAggregateOutputType | null
  }

  type GetItemproductsaleGroupByPayload<T extends itemproductsaleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ItemproductsaleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ItemproductsaleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ItemproductsaleGroupByOutputType[P]>
            : GetScalarType<T[P], ItemproductsaleGroupByOutputType[P]>
        }
      >
    >


  export type itemproductsaleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    product_sale_id?: boolean
    item_id?: boolean
    option_group_id?: boolean
    quantity?: boolean
    additional_price?: boolean
    price?: boolean
    amount?: boolean
    observations?: boolean
    productsale?: boolean | productsaleDefaultArgs<ExtArgs>
    item?: boolean | itemDefaultArgs<ExtArgs>
    optiongroup?: boolean | itemproductsale$optiongroupArgs<ExtArgs>
    itemitemproductsales?: boolean | itemproductsale$itemitemproductsalesArgs<ExtArgs>
    _count?: boolean | ItemproductsaleCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["itemproductsale"]>

  export type itemproductsaleSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    product_sale_id?: boolean
    item_id?: boolean
    option_group_id?: boolean
    quantity?: boolean
    additional_price?: boolean
    price?: boolean
    amount?: boolean
    observations?: boolean
    productsale?: boolean | productsaleDefaultArgs<ExtArgs>
    item?: boolean | itemDefaultArgs<ExtArgs>
    optiongroup?: boolean | itemproductsale$optiongroupArgs<ExtArgs>
  }, ExtArgs["result"]["itemproductsale"]>

  export type itemproductsaleSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    product_sale_id?: boolean
    item_id?: boolean
    option_group_id?: boolean
    quantity?: boolean
    additional_price?: boolean
    price?: boolean
    amount?: boolean
    observations?: boolean
    productsale?: boolean | productsaleDefaultArgs<ExtArgs>
    item?: boolean | itemDefaultArgs<ExtArgs>
    optiongroup?: boolean | itemproductsale$optiongroupArgs<ExtArgs>
  }, ExtArgs["result"]["itemproductsale"]>

  export type itemproductsaleSelectScalar = {
    id?: boolean
    product_sale_id?: boolean
    item_id?: boolean
    option_group_id?: boolean
    quantity?: boolean
    additional_price?: boolean
    price?: boolean
    amount?: boolean
    observations?: boolean
  }

  export type itemproductsaleOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "product_sale_id" | "item_id" | "option_group_id" | "quantity" | "additional_price" | "price" | "amount" | "observations", ExtArgs["result"]["itemproductsale"]>
  export type itemproductsaleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    productsale?: boolean | productsaleDefaultArgs<ExtArgs>
    item?: boolean | itemDefaultArgs<ExtArgs>
    optiongroup?: boolean | itemproductsale$optiongroupArgs<ExtArgs>
    itemitemproductsales?: boolean | itemproductsale$itemitemproductsalesArgs<ExtArgs>
    _count?: boolean | ItemproductsaleCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type itemproductsaleIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    productsale?: boolean | productsaleDefaultArgs<ExtArgs>
    item?: boolean | itemDefaultArgs<ExtArgs>
    optiongroup?: boolean | itemproductsale$optiongroupArgs<ExtArgs>
  }
  export type itemproductsaleIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    productsale?: boolean | productsaleDefaultArgs<ExtArgs>
    item?: boolean | itemDefaultArgs<ExtArgs>
    optiongroup?: boolean | itemproductsale$optiongroupArgs<ExtArgs>
  }

  export type $itemproductsalePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "itemproductsale"
    objects: {
      productsale: Prisma.$productsalePayload<ExtArgs>
      item: Prisma.$itemPayload<ExtArgs>
      optiongroup: Prisma.$optiongroupPayload<ExtArgs> | null
      itemitemproductsales: Prisma.$itemitemproductsalePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      product_sale_id: number
      item_id: number
      option_group_id: number | null
      quantity: number
      additional_price: number
      price: number
      amount: number | null
      observations: string | null
    }, ExtArgs["result"]["itemproductsale"]>
    composites: {}
  }

  type itemproductsaleGetPayload<S extends boolean | null | undefined | itemproductsaleDefaultArgs> = $Result.GetResult<Prisma.$itemproductsalePayload, S>

  type itemproductsaleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<itemproductsaleFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ItemproductsaleCountAggregateInputType | true
    }

  export interface itemproductsaleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['itemproductsale'], meta: { name: 'itemproductsale' } }
    /**
     * Find zero or one Itemproductsale that matches the filter.
     * @param {itemproductsaleFindUniqueArgs} args - Arguments to find a Itemproductsale
     * @example
     * // Get one Itemproductsale
     * const itemproductsale = await prisma.itemproductsale.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends itemproductsaleFindUniqueArgs>(args: SelectSubset<T, itemproductsaleFindUniqueArgs<ExtArgs>>): Prisma__itemproductsaleClient<$Result.GetResult<Prisma.$itemproductsalePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Itemproductsale that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {itemproductsaleFindUniqueOrThrowArgs} args - Arguments to find a Itemproductsale
     * @example
     * // Get one Itemproductsale
     * const itemproductsale = await prisma.itemproductsale.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends itemproductsaleFindUniqueOrThrowArgs>(args: SelectSubset<T, itemproductsaleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__itemproductsaleClient<$Result.GetResult<Prisma.$itemproductsalePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Itemproductsale that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {itemproductsaleFindFirstArgs} args - Arguments to find a Itemproductsale
     * @example
     * // Get one Itemproductsale
     * const itemproductsale = await prisma.itemproductsale.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends itemproductsaleFindFirstArgs>(args?: SelectSubset<T, itemproductsaleFindFirstArgs<ExtArgs>>): Prisma__itemproductsaleClient<$Result.GetResult<Prisma.$itemproductsalePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Itemproductsale that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {itemproductsaleFindFirstOrThrowArgs} args - Arguments to find a Itemproductsale
     * @example
     * // Get one Itemproductsale
     * const itemproductsale = await prisma.itemproductsale.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends itemproductsaleFindFirstOrThrowArgs>(args?: SelectSubset<T, itemproductsaleFindFirstOrThrowArgs<ExtArgs>>): Prisma__itemproductsaleClient<$Result.GetResult<Prisma.$itemproductsalePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Itemproductsales that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {itemproductsaleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Itemproductsales
     * const itemproductsales = await prisma.itemproductsale.findMany()
     * 
     * // Get first 10 Itemproductsales
     * const itemproductsales = await prisma.itemproductsale.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const itemproductsaleWithIdOnly = await prisma.itemproductsale.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends itemproductsaleFindManyArgs>(args?: SelectSubset<T, itemproductsaleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$itemproductsalePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Itemproductsale.
     * @param {itemproductsaleCreateArgs} args - Arguments to create a Itemproductsale.
     * @example
     * // Create one Itemproductsale
     * const Itemproductsale = await prisma.itemproductsale.create({
     *   data: {
     *     // ... data to create a Itemproductsale
     *   }
     * })
     * 
     */
    create<T extends itemproductsaleCreateArgs>(args: SelectSubset<T, itemproductsaleCreateArgs<ExtArgs>>): Prisma__itemproductsaleClient<$Result.GetResult<Prisma.$itemproductsalePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Itemproductsales.
     * @param {itemproductsaleCreateManyArgs} args - Arguments to create many Itemproductsales.
     * @example
     * // Create many Itemproductsales
     * const itemproductsale = await prisma.itemproductsale.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends itemproductsaleCreateManyArgs>(args?: SelectSubset<T, itemproductsaleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Itemproductsales and returns the data saved in the database.
     * @param {itemproductsaleCreateManyAndReturnArgs} args - Arguments to create many Itemproductsales.
     * @example
     * // Create many Itemproductsales
     * const itemproductsale = await prisma.itemproductsale.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Itemproductsales and only return the `id`
     * const itemproductsaleWithIdOnly = await prisma.itemproductsale.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends itemproductsaleCreateManyAndReturnArgs>(args?: SelectSubset<T, itemproductsaleCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$itemproductsalePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Itemproductsale.
     * @param {itemproductsaleDeleteArgs} args - Arguments to delete one Itemproductsale.
     * @example
     * // Delete one Itemproductsale
     * const Itemproductsale = await prisma.itemproductsale.delete({
     *   where: {
     *     // ... filter to delete one Itemproductsale
     *   }
     * })
     * 
     */
    delete<T extends itemproductsaleDeleteArgs>(args: SelectSubset<T, itemproductsaleDeleteArgs<ExtArgs>>): Prisma__itemproductsaleClient<$Result.GetResult<Prisma.$itemproductsalePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Itemproductsale.
     * @param {itemproductsaleUpdateArgs} args - Arguments to update one Itemproductsale.
     * @example
     * // Update one Itemproductsale
     * const itemproductsale = await prisma.itemproductsale.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends itemproductsaleUpdateArgs>(args: SelectSubset<T, itemproductsaleUpdateArgs<ExtArgs>>): Prisma__itemproductsaleClient<$Result.GetResult<Prisma.$itemproductsalePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Itemproductsales.
     * @param {itemproductsaleDeleteManyArgs} args - Arguments to filter Itemproductsales to delete.
     * @example
     * // Delete a few Itemproductsales
     * const { count } = await prisma.itemproductsale.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends itemproductsaleDeleteManyArgs>(args?: SelectSubset<T, itemproductsaleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Itemproductsales.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {itemproductsaleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Itemproductsales
     * const itemproductsale = await prisma.itemproductsale.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends itemproductsaleUpdateManyArgs>(args: SelectSubset<T, itemproductsaleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Itemproductsales and returns the data updated in the database.
     * @param {itemproductsaleUpdateManyAndReturnArgs} args - Arguments to update many Itemproductsales.
     * @example
     * // Update many Itemproductsales
     * const itemproductsale = await prisma.itemproductsale.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Itemproductsales and only return the `id`
     * const itemproductsaleWithIdOnly = await prisma.itemproductsale.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends itemproductsaleUpdateManyAndReturnArgs>(args: SelectSubset<T, itemproductsaleUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$itemproductsalePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Itemproductsale.
     * @param {itemproductsaleUpsertArgs} args - Arguments to update or create a Itemproductsale.
     * @example
     * // Update or create a Itemproductsale
     * const itemproductsale = await prisma.itemproductsale.upsert({
     *   create: {
     *     // ... data to create a Itemproductsale
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Itemproductsale we want to update
     *   }
     * })
     */
    upsert<T extends itemproductsaleUpsertArgs>(args: SelectSubset<T, itemproductsaleUpsertArgs<ExtArgs>>): Prisma__itemproductsaleClient<$Result.GetResult<Prisma.$itemproductsalePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Itemproductsales.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {itemproductsaleCountArgs} args - Arguments to filter Itemproductsales to count.
     * @example
     * // Count the number of Itemproductsales
     * const count = await prisma.itemproductsale.count({
     *   where: {
     *     // ... the filter for the Itemproductsales we want to count
     *   }
     * })
    **/
    count<T extends itemproductsaleCountArgs>(
      args?: Subset<T, itemproductsaleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ItemproductsaleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Itemproductsale.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemproductsaleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ItemproductsaleAggregateArgs>(args: Subset<T, ItemproductsaleAggregateArgs>): Prisma.PrismaPromise<GetItemproductsaleAggregateType<T>>

    /**
     * Group by Itemproductsale.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {itemproductsaleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends itemproductsaleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: itemproductsaleGroupByArgs['orderBy'] }
        : { orderBy?: itemproductsaleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, itemproductsaleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetItemproductsaleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the itemproductsale model
   */
  readonly fields: itemproductsaleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for itemproductsale.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__itemproductsaleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    productsale<T extends productsaleDefaultArgs<ExtArgs> = {}>(args?: Subset<T, productsaleDefaultArgs<ExtArgs>>): Prisma__productsaleClient<$Result.GetResult<Prisma.$productsalePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    item<T extends itemDefaultArgs<ExtArgs> = {}>(args?: Subset<T, itemDefaultArgs<ExtArgs>>): Prisma__itemClient<$Result.GetResult<Prisma.$itemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    optiongroup<T extends itemproductsale$optiongroupArgs<ExtArgs> = {}>(args?: Subset<T, itemproductsale$optiongroupArgs<ExtArgs>>): Prisma__optiongroupClient<$Result.GetResult<Prisma.$optiongroupPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    itemitemproductsales<T extends itemproductsale$itemitemproductsalesArgs<ExtArgs> = {}>(args?: Subset<T, itemproductsale$itemitemproductsalesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$itemitemproductsalePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the itemproductsale model
   */
  interface itemproductsaleFieldRefs {
    readonly id: FieldRef<"itemproductsale", 'Int'>
    readonly product_sale_id: FieldRef<"itemproductsale", 'Int'>
    readonly item_id: FieldRef<"itemproductsale", 'Int'>
    readonly option_group_id: FieldRef<"itemproductsale", 'Int'>
    readonly quantity: FieldRef<"itemproductsale", 'Float'>
    readonly additional_price: FieldRef<"itemproductsale", 'Float'>
    readonly price: FieldRef<"itemproductsale", 'Float'>
    readonly amount: FieldRef<"itemproductsale", 'Float'>
    readonly observations: FieldRef<"itemproductsale", 'String'>
  }
    

  // Custom InputTypes
  /**
   * itemproductsale findUnique
   */
  export type itemproductsaleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the itemproductsale
     */
    select?: itemproductsaleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the itemproductsale
     */
    omit?: itemproductsaleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: itemproductsaleInclude<ExtArgs> | null
    /**
     * Filter, which itemproductsale to fetch.
     */
    where: itemproductsaleWhereUniqueInput
  }

  /**
   * itemproductsale findUniqueOrThrow
   */
  export type itemproductsaleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the itemproductsale
     */
    select?: itemproductsaleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the itemproductsale
     */
    omit?: itemproductsaleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: itemproductsaleInclude<ExtArgs> | null
    /**
     * Filter, which itemproductsale to fetch.
     */
    where: itemproductsaleWhereUniqueInput
  }

  /**
   * itemproductsale findFirst
   */
  export type itemproductsaleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the itemproductsale
     */
    select?: itemproductsaleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the itemproductsale
     */
    omit?: itemproductsaleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: itemproductsaleInclude<ExtArgs> | null
    /**
     * Filter, which itemproductsale to fetch.
     */
    where?: itemproductsaleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of itemproductsales to fetch.
     */
    orderBy?: itemproductsaleOrderByWithRelationInput | itemproductsaleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for itemproductsales.
     */
    cursor?: itemproductsaleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` itemproductsales from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` itemproductsales.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of itemproductsales.
     */
    distinct?: ItemproductsaleScalarFieldEnum | ItemproductsaleScalarFieldEnum[]
  }

  /**
   * itemproductsale findFirstOrThrow
   */
  export type itemproductsaleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the itemproductsale
     */
    select?: itemproductsaleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the itemproductsale
     */
    omit?: itemproductsaleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: itemproductsaleInclude<ExtArgs> | null
    /**
     * Filter, which itemproductsale to fetch.
     */
    where?: itemproductsaleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of itemproductsales to fetch.
     */
    orderBy?: itemproductsaleOrderByWithRelationInput | itemproductsaleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for itemproductsales.
     */
    cursor?: itemproductsaleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` itemproductsales from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` itemproductsales.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of itemproductsales.
     */
    distinct?: ItemproductsaleScalarFieldEnum | ItemproductsaleScalarFieldEnum[]
  }

  /**
   * itemproductsale findMany
   */
  export type itemproductsaleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the itemproductsale
     */
    select?: itemproductsaleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the itemproductsale
     */
    omit?: itemproductsaleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: itemproductsaleInclude<ExtArgs> | null
    /**
     * Filter, which itemproductsales to fetch.
     */
    where?: itemproductsaleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of itemproductsales to fetch.
     */
    orderBy?: itemproductsaleOrderByWithRelationInput | itemproductsaleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing itemproductsales.
     */
    cursor?: itemproductsaleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` itemproductsales from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` itemproductsales.
     */
    skip?: number
    distinct?: ItemproductsaleScalarFieldEnum | ItemproductsaleScalarFieldEnum[]
  }

  /**
   * itemproductsale create
   */
  export type itemproductsaleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the itemproductsale
     */
    select?: itemproductsaleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the itemproductsale
     */
    omit?: itemproductsaleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: itemproductsaleInclude<ExtArgs> | null
    /**
     * The data needed to create a itemproductsale.
     */
    data: XOR<itemproductsaleCreateInput, itemproductsaleUncheckedCreateInput>
  }

  /**
   * itemproductsale createMany
   */
  export type itemproductsaleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many itemproductsales.
     */
    data: itemproductsaleCreateManyInput | itemproductsaleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * itemproductsale createManyAndReturn
   */
  export type itemproductsaleCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the itemproductsale
     */
    select?: itemproductsaleSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the itemproductsale
     */
    omit?: itemproductsaleOmit<ExtArgs> | null
    /**
     * The data used to create many itemproductsales.
     */
    data: itemproductsaleCreateManyInput | itemproductsaleCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: itemproductsaleIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * itemproductsale update
   */
  export type itemproductsaleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the itemproductsale
     */
    select?: itemproductsaleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the itemproductsale
     */
    omit?: itemproductsaleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: itemproductsaleInclude<ExtArgs> | null
    /**
     * The data needed to update a itemproductsale.
     */
    data: XOR<itemproductsaleUpdateInput, itemproductsaleUncheckedUpdateInput>
    /**
     * Choose, which itemproductsale to update.
     */
    where: itemproductsaleWhereUniqueInput
  }

  /**
   * itemproductsale updateMany
   */
  export type itemproductsaleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update itemproductsales.
     */
    data: XOR<itemproductsaleUpdateManyMutationInput, itemproductsaleUncheckedUpdateManyInput>
    /**
     * Filter which itemproductsales to update
     */
    where?: itemproductsaleWhereInput
    /**
     * Limit how many itemproductsales to update.
     */
    limit?: number
  }

  /**
   * itemproductsale updateManyAndReturn
   */
  export type itemproductsaleUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the itemproductsale
     */
    select?: itemproductsaleSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the itemproductsale
     */
    omit?: itemproductsaleOmit<ExtArgs> | null
    /**
     * The data used to update itemproductsales.
     */
    data: XOR<itemproductsaleUpdateManyMutationInput, itemproductsaleUncheckedUpdateManyInput>
    /**
     * Filter which itemproductsales to update
     */
    where?: itemproductsaleWhereInput
    /**
     * Limit how many itemproductsales to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: itemproductsaleIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * itemproductsale upsert
   */
  export type itemproductsaleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the itemproductsale
     */
    select?: itemproductsaleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the itemproductsale
     */
    omit?: itemproductsaleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: itemproductsaleInclude<ExtArgs> | null
    /**
     * The filter to search for the itemproductsale to update in case it exists.
     */
    where: itemproductsaleWhereUniqueInput
    /**
     * In case the itemproductsale found by the `where` argument doesn't exist, create a new itemproductsale with this data.
     */
    create: XOR<itemproductsaleCreateInput, itemproductsaleUncheckedCreateInput>
    /**
     * In case the itemproductsale was found with the provided `where` argument, update it with this data.
     */
    update: XOR<itemproductsaleUpdateInput, itemproductsaleUncheckedUpdateInput>
  }

  /**
   * itemproductsale delete
   */
  export type itemproductsaleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the itemproductsale
     */
    select?: itemproductsaleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the itemproductsale
     */
    omit?: itemproductsaleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: itemproductsaleInclude<ExtArgs> | null
    /**
     * Filter which itemproductsale to delete.
     */
    where: itemproductsaleWhereUniqueInput
  }

  /**
   * itemproductsale deleteMany
   */
  export type itemproductsaleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which itemproductsales to delete
     */
    where?: itemproductsaleWhereInput
    /**
     * Limit how many itemproductsales to delete.
     */
    limit?: number
  }

  /**
   * itemproductsale.optiongroup
   */
  export type itemproductsale$optiongroupArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the optiongroup
     */
    select?: optiongroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the optiongroup
     */
    omit?: optiongroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: optiongroupInclude<ExtArgs> | null
    where?: optiongroupWhereInput
  }

  /**
   * itemproductsale.itemitemproductsales
   */
  export type itemproductsale$itemitemproductsalesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the itemitemproductsale
     */
    select?: itemitemproductsaleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the itemitemproductsale
     */
    omit?: itemitemproductsaleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: itemitemproductsaleInclude<ExtArgs> | null
    where?: itemitemproductsaleWhereInput
    orderBy?: itemitemproductsaleOrderByWithRelationInput | itemitemproductsaleOrderByWithRelationInput[]
    cursor?: itemitemproductsaleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ItemitemproductsaleScalarFieldEnum | ItemitemproductsaleScalarFieldEnum[]
  }

  /**
   * itemproductsale without action
   */
  export type itemproductsaleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the itemproductsale
     */
    select?: itemproductsaleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the itemproductsale
     */
    omit?: itemproductsaleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: itemproductsaleInclude<ExtArgs> | null
  }


  /**
   * Model itemitemproductsale
   */

  export type AggregateItemitemproductsale = {
    _count: ItemitemproductsaleCountAggregateOutputType | null
    _avg: ItemitemproductsaleAvgAggregateOutputType | null
    _sum: ItemitemproductsaleSumAggregateOutputType | null
    _min: ItemitemproductsaleMinAggregateOutputType | null
    _max: ItemitemproductsaleMaxAggregateOutputType | null
  }

  export type ItemitemproductsaleAvgAggregateOutputType = {
    id: number | null
    item_product_sale_id: number | null
    item_id: number | null
    option_group_id: number | null
    quantity: number | null
    additional_price: number | null
    price: number | null
    amount: number | null
  }

  export type ItemitemproductsaleSumAggregateOutputType = {
    id: number | null
    item_product_sale_id: number | null
    item_id: number | null
    option_group_id: number | null
    quantity: number | null
    additional_price: number | null
    price: number | null
    amount: number | null
  }

  export type ItemitemproductsaleMinAggregateOutputType = {
    id: number | null
    item_product_sale_id: number | null
    item_id: number | null
    option_group_id: number | null
    quantity: number | null
    additional_price: number | null
    price: number | null
    amount: number | null
  }

  export type ItemitemproductsaleMaxAggregateOutputType = {
    id: number | null
    item_product_sale_id: number | null
    item_id: number | null
    option_group_id: number | null
    quantity: number | null
    additional_price: number | null
    price: number | null
    amount: number | null
  }

  export type ItemitemproductsaleCountAggregateOutputType = {
    id: number
    item_product_sale_id: number
    item_id: number
    option_group_id: number
    quantity: number
    additional_price: number
    price: number
    amount: number
    _all: number
  }


  export type ItemitemproductsaleAvgAggregateInputType = {
    id?: true
    item_product_sale_id?: true
    item_id?: true
    option_group_id?: true
    quantity?: true
    additional_price?: true
    price?: true
    amount?: true
  }

  export type ItemitemproductsaleSumAggregateInputType = {
    id?: true
    item_product_sale_id?: true
    item_id?: true
    option_group_id?: true
    quantity?: true
    additional_price?: true
    price?: true
    amount?: true
  }

  export type ItemitemproductsaleMinAggregateInputType = {
    id?: true
    item_product_sale_id?: true
    item_id?: true
    option_group_id?: true
    quantity?: true
    additional_price?: true
    price?: true
    amount?: true
  }

  export type ItemitemproductsaleMaxAggregateInputType = {
    id?: true
    item_product_sale_id?: true
    item_id?: true
    option_group_id?: true
    quantity?: true
    additional_price?: true
    price?: true
    amount?: true
  }

  export type ItemitemproductsaleCountAggregateInputType = {
    id?: true
    item_product_sale_id?: true
    item_id?: true
    option_group_id?: true
    quantity?: true
    additional_price?: true
    price?: true
    amount?: true
    _all?: true
  }

  export type ItemitemproductsaleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which itemitemproductsale to aggregate.
     */
    where?: itemitemproductsaleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of itemitemproductsales to fetch.
     */
    orderBy?: itemitemproductsaleOrderByWithRelationInput | itemitemproductsaleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: itemitemproductsaleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` itemitemproductsales from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` itemitemproductsales.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned itemitemproductsales
    **/
    _count?: true | ItemitemproductsaleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ItemitemproductsaleAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ItemitemproductsaleSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ItemitemproductsaleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ItemitemproductsaleMaxAggregateInputType
  }

  export type GetItemitemproductsaleAggregateType<T extends ItemitemproductsaleAggregateArgs> = {
        [P in keyof T & keyof AggregateItemitemproductsale]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateItemitemproductsale[P]>
      : GetScalarType<T[P], AggregateItemitemproductsale[P]>
  }




  export type itemitemproductsaleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: itemitemproductsaleWhereInput
    orderBy?: itemitemproductsaleOrderByWithAggregationInput | itemitemproductsaleOrderByWithAggregationInput[]
    by: ItemitemproductsaleScalarFieldEnum[] | ItemitemproductsaleScalarFieldEnum
    having?: itemitemproductsaleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ItemitemproductsaleCountAggregateInputType | true
    _avg?: ItemitemproductsaleAvgAggregateInputType
    _sum?: ItemitemproductsaleSumAggregateInputType
    _min?: ItemitemproductsaleMinAggregateInputType
    _max?: ItemitemproductsaleMaxAggregateInputType
  }

  export type ItemitemproductsaleGroupByOutputType = {
    id: number
    item_product_sale_id: number
    item_id: number
    option_group_id: number | null
    quantity: number
    additional_price: number
    price: number
    amount: number | null
    _count: ItemitemproductsaleCountAggregateOutputType | null
    _avg: ItemitemproductsaleAvgAggregateOutputType | null
    _sum: ItemitemproductsaleSumAggregateOutputType | null
    _min: ItemitemproductsaleMinAggregateOutputType | null
    _max: ItemitemproductsaleMaxAggregateOutputType | null
  }

  type GetItemitemproductsaleGroupByPayload<T extends itemitemproductsaleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ItemitemproductsaleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ItemitemproductsaleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ItemitemproductsaleGroupByOutputType[P]>
            : GetScalarType<T[P], ItemitemproductsaleGroupByOutputType[P]>
        }
      >
    >


  export type itemitemproductsaleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    item_product_sale_id?: boolean
    item_id?: boolean
    option_group_id?: boolean
    quantity?: boolean
    additional_price?: boolean
    price?: boolean
    amount?: boolean
    itemproductsale?: boolean | itemproductsaleDefaultArgs<ExtArgs>
    item?: boolean | itemDefaultArgs<ExtArgs>
    optiongroup?: boolean | itemitemproductsale$optiongroupArgs<ExtArgs>
  }, ExtArgs["result"]["itemitemproductsale"]>

  export type itemitemproductsaleSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    item_product_sale_id?: boolean
    item_id?: boolean
    option_group_id?: boolean
    quantity?: boolean
    additional_price?: boolean
    price?: boolean
    amount?: boolean
    itemproductsale?: boolean | itemproductsaleDefaultArgs<ExtArgs>
    item?: boolean | itemDefaultArgs<ExtArgs>
    optiongroup?: boolean | itemitemproductsale$optiongroupArgs<ExtArgs>
  }, ExtArgs["result"]["itemitemproductsale"]>

  export type itemitemproductsaleSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    item_product_sale_id?: boolean
    item_id?: boolean
    option_group_id?: boolean
    quantity?: boolean
    additional_price?: boolean
    price?: boolean
    amount?: boolean
    itemproductsale?: boolean | itemproductsaleDefaultArgs<ExtArgs>
    item?: boolean | itemDefaultArgs<ExtArgs>
    optiongroup?: boolean | itemitemproductsale$optiongroupArgs<ExtArgs>
  }, ExtArgs["result"]["itemitemproductsale"]>

  export type itemitemproductsaleSelectScalar = {
    id?: boolean
    item_product_sale_id?: boolean
    item_id?: boolean
    option_group_id?: boolean
    quantity?: boolean
    additional_price?: boolean
    price?: boolean
    amount?: boolean
  }

  export type itemitemproductsaleOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "item_product_sale_id" | "item_id" | "option_group_id" | "quantity" | "additional_price" | "price" | "amount", ExtArgs["result"]["itemitemproductsale"]>
  export type itemitemproductsaleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    itemproductsale?: boolean | itemproductsaleDefaultArgs<ExtArgs>
    item?: boolean | itemDefaultArgs<ExtArgs>
    optiongroup?: boolean | itemitemproductsale$optiongroupArgs<ExtArgs>
  }
  export type itemitemproductsaleIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    itemproductsale?: boolean | itemproductsaleDefaultArgs<ExtArgs>
    item?: boolean | itemDefaultArgs<ExtArgs>
    optiongroup?: boolean | itemitemproductsale$optiongroupArgs<ExtArgs>
  }
  export type itemitemproductsaleIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    itemproductsale?: boolean | itemproductsaleDefaultArgs<ExtArgs>
    item?: boolean | itemDefaultArgs<ExtArgs>
    optiongroup?: boolean | itemitemproductsale$optiongroupArgs<ExtArgs>
  }

  export type $itemitemproductsalePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "itemitemproductsale"
    objects: {
      itemproductsale: Prisma.$itemproductsalePayload<ExtArgs>
      item: Prisma.$itemPayload<ExtArgs>
      optiongroup: Prisma.$optiongroupPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      item_product_sale_id: number
      item_id: number
      option_group_id: number | null
      quantity: number
      additional_price: number
      price: number
      amount: number | null
    }, ExtArgs["result"]["itemitemproductsale"]>
    composites: {}
  }

  type itemitemproductsaleGetPayload<S extends boolean | null | undefined | itemitemproductsaleDefaultArgs> = $Result.GetResult<Prisma.$itemitemproductsalePayload, S>

  type itemitemproductsaleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<itemitemproductsaleFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ItemitemproductsaleCountAggregateInputType | true
    }

  export interface itemitemproductsaleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['itemitemproductsale'], meta: { name: 'itemitemproductsale' } }
    /**
     * Find zero or one Itemitemproductsale that matches the filter.
     * @param {itemitemproductsaleFindUniqueArgs} args - Arguments to find a Itemitemproductsale
     * @example
     * // Get one Itemitemproductsale
     * const itemitemproductsale = await prisma.itemitemproductsale.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends itemitemproductsaleFindUniqueArgs>(args: SelectSubset<T, itemitemproductsaleFindUniqueArgs<ExtArgs>>): Prisma__itemitemproductsaleClient<$Result.GetResult<Prisma.$itemitemproductsalePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Itemitemproductsale that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {itemitemproductsaleFindUniqueOrThrowArgs} args - Arguments to find a Itemitemproductsale
     * @example
     * // Get one Itemitemproductsale
     * const itemitemproductsale = await prisma.itemitemproductsale.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends itemitemproductsaleFindUniqueOrThrowArgs>(args: SelectSubset<T, itemitemproductsaleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__itemitemproductsaleClient<$Result.GetResult<Prisma.$itemitemproductsalePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Itemitemproductsale that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {itemitemproductsaleFindFirstArgs} args - Arguments to find a Itemitemproductsale
     * @example
     * // Get one Itemitemproductsale
     * const itemitemproductsale = await prisma.itemitemproductsale.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends itemitemproductsaleFindFirstArgs>(args?: SelectSubset<T, itemitemproductsaleFindFirstArgs<ExtArgs>>): Prisma__itemitemproductsaleClient<$Result.GetResult<Prisma.$itemitemproductsalePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Itemitemproductsale that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {itemitemproductsaleFindFirstOrThrowArgs} args - Arguments to find a Itemitemproductsale
     * @example
     * // Get one Itemitemproductsale
     * const itemitemproductsale = await prisma.itemitemproductsale.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends itemitemproductsaleFindFirstOrThrowArgs>(args?: SelectSubset<T, itemitemproductsaleFindFirstOrThrowArgs<ExtArgs>>): Prisma__itemitemproductsaleClient<$Result.GetResult<Prisma.$itemitemproductsalePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Itemitemproductsales that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {itemitemproductsaleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Itemitemproductsales
     * const itemitemproductsales = await prisma.itemitemproductsale.findMany()
     * 
     * // Get first 10 Itemitemproductsales
     * const itemitemproductsales = await prisma.itemitemproductsale.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const itemitemproductsaleWithIdOnly = await prisma.itemitemproductsale.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends itemitemproductsaleFindManyArgs>(args?: SelectSubset<T, itemitemproductsaleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$itemitemproductsalePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Itemitemproductsale.
     * @param {itemitemproductsaleCreateArgs} args - Arguments to create a Itemitemproductsale.
     * @example
     * // Create one Itemitemproductsale
     * const Itemitemproductsale = await prisma.itemitemproductsale.create({
     *   data: {
     *     // ... data to create a Itemitemproductsale
     *   }
     * })
     * 
     */
    create<T extends itemitemproductsaleCreateArgs>(args: SelectSubset<T, itemitemproductsaleCreateArgs<ExtArgs>>): Prisma__itemitemproductsaleClient<$Result.GetResult<Prisma.$itemitemproductsalePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Itemitemproductsales.
     * @param {itemitemproductsaleCreateManyArgs} args - Arguments to create many Itemitemproductsales.
     * @example
     * // Create many Itemitemproductsales
     * const itemitemproductsale = await prisma.itemitemproductsale.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends itemitemproductsaleCreateManyArgs>(args?: SelectSubset<T, itemitemproductsaleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Itemitemproductsales and returns the data saved in the database.
     * @param {itemitemproductsaleCreateManyAndReturnArgs} args - Arguments to create many Itemitemproductsales.
     * @example
     * // Create many Itemitemproductsales
     * const itemitemproductsale = await prisma.itemitemproductsale.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Itemitemproductsales and only return the `id`
     * const itemitemproductsaleWithIdOnly = await prisma.itemitemproductsale.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends itemitemproductsaleCreateManyAndReturnArgs>(args?: SelectSubset<T, itemitemproductsaleCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$itemitemproductsalePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Itemitemproductsale.
     * @param {itemitemproductsaleDeleteArgs} args - Arguments to delete one Itemitemproductsale.
     * @example
     * // Delete one Itemitemproductsale
     * const Itemitemproductsale = await prisma.itemitemproductsale.delete({
     *   where: {
     *     // ... filter to delete one Itemitemproductsale
     *   }
     * })
     * 
     */
    delete<T extends itemitemproductsaleDeleteArgs>(args: SelectSubset<T, itemitemproductsaleDeleteArgs<ExtArgs>>): Prisma__itemitemproductsaleClient<$Result.GetResult<Prisma.$itemitemproductsalePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Itemitemproductsale.
     * @param {itemitemproductsaleUpdateArgs} args - Arguments to update one Itemitemproductsale.
     * @example
     * // Update one Itemitemproductsale
     * const itemitemproductsale = await prisma.itemitemproductsale.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends itemitemproductsaleUpdateArgs>(args: SelectSubset<T, itemitemproductsaleUpdateArgs<ExtArgs>>): Prisma__itemitemproductsaleClient<$Result.GetResult<Prisma.$itemitemproductsalePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Itemitemproductsales.
     * @param {itemitemproductsaleDeleteManyArgs} args - Arguments to filter Itemitemproductsales to delete.
     * @example
     * // Delete a few Itemitemproductsales
     * const { count } = await prisma.itemitemproductsale.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends itemitemproductsaleDeleteManyArgs>(args?: SelectSubset<T, itemitemproductsaleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Itemitemproductsales.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {itemitemproductsaleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Itemitemproductsales
     * const itemitemproductsale = await prisma.itemitemproductsale.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends itemitemproductsaleUpdateManyArgs>(args: SelectSubset<T, itemitemproductsaleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Itemitemproductsales and returns the data updated in the database.
     * @param {itemitemproductsaleUpdateManyAndReturnArgs} args - Arguments to update many Itemitemproductsales.
     * @example
     * // Update many Itemitemproductsales
     * const itemitemproductsale = await prisma.itemitemproductsale.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Itemitemproductsales and only return the `id`
     * const itemitemproductsaleWithIdOnly = await prisma.itemitemproductsale.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends itemitemproductsaleUpdateManyAndReturnArgs>(args: SelectSubset<T, itemitemproductsaleUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$itemitemproductsalePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Itemitemproductsale.
     * @param {itemitemproductsaleUpsertArgs} args - Arguments to update or create a Itemitemproductsale.
     * @example
     * // Update or create a Itemitemproductsale
     * const itemitemproductsale = await prisma.itemitemproductsale.upsert({
     *   create: {
     *     // ... data to create a Itemitemproductsale
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Itemitemproductsale we want to update
     *   }
     * })
     */
    upsert<T extends itemitemproductsaleUpsertArgs>(args: SelectSubset<T, itemitemproductsaleUpsertArgs<ExtArgs>>): Prisma__itemitemproductsaleClient<$Result.GetResult<Prisma.$itemitemproductsalePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Itemitemproductsales.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {itemitemproductsaleCountArgs} args - Arguments to filter Itemitemproductsales to count.
     * @example
     * // Count the number of Itemitemproductsales
     * const count = await prisma.itemitemproductsale.count({
     *   where: {
     *     // ... the filter for the Itemitemproductsales we want to count
     *   }
     * })
    **/
    count<T extends itemitemproductsaleCountArgs>(
      args?: Subset<T, itemitemproductsaleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ItemitemproductsaleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Itemitemproductsale.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemitemproductsaleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ItemitemproductsaleAggregateArgs>(args: Subset<T, ItemitemproductsaleAggregateArgs>): Prisma.PrismaPromise<GetItemitemproductsaleAggregateType<T>>

    /**
     * Group by Itemitemproductsale.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {itemitemproductsaleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends itemitemproductsaleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: itemitemproductsaleGroupByArgs['orderBy'] }
        : { orderBy?: itemitemproductsaleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, itemitemproductsaleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetItemitemproductsaleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the itemitemproductsale model
   */
  readonly fields: itemitemproductsaleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for itemitemproductsale.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__itemitemproductsaleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    itemproductsale<T extends itemproductsaleDefaultArgs<ExtArgs> = {}>(args?: Subset<T, itemproductsaleDefaultArgs<ExtArgs>>): Prisma__itemproductsaleClient<$Result.GetResult<Prisma.$itemproductsalePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    item<T extends itemDefaultArgs<ExtArgs> = {}>(args?: Subset<T, itemDefaultArgs<ExtArgs>>): Prisma__itemClient<$Result.GetResult<Prisma.$itemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    optiongroup<T extends itemitemproductsale$optiongroupArgs<ExtArgs> = {}>(args?: Subset<T, itemitemproductsale$optiongroupArgs<ExtArgs>>): Prisma__optiongroupClient<$Result.GetResult<Prisma.$optiongroupPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the itemitemproductsale model
   */
  interface itemitemproductsaleFieldRefs {
    readonly id: FieldRef<"itemitemproductsale", 'Int'>
    readonly item_product_sale_id: FieldRef<"itemitemproductsale", 'Int'>
    readonly item_id: FieldRef<"itemitemproductsale", 'Int'>
    readonly option_group_id: FieldRef<"itemitemproductsale", 'Int'>
    readonly quantity: FieldRef<"itemitemproductsale", 'Float'>
    readonly additional_price: FieldRef<"itemitemproductsale", 'Float'>
    readonly price: FieldRef<"itemitemproductsale", 'Float'>
    readonly amount: FieldRef<"itemitemproductsale", 'Float'>
  }
    

  // Custom InputTypes
  /**
   * itemitemproductsale findUnique
   */
  export type itemitemproductsaleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the itemitemproductsale
     */
    select?: itemitemproductsaleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the itemitemproductsale
     */
    omit?: itemitemproductsaleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: itemitemproductsaleInclude<ExtArgs> | null
    /**
     * Filter, which itemitemproductsale to fetch.
     */
    where: itemitemproductsaleWhereUniqueInput
  }

  /**
   * itemitemproductsale findUniqueOrThrow
   */
  export type itemitemproductsaleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the itemitemproductsale
     */
    select?: itemitemproductsaleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the itemitemproductsale
     */
    omit?: itemitemproductsaleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: itemitemproductsaleInclude<ExtArgs> | null
    /**
     * Filter, which itemitemproductsale to fetch.
     */
    where: itemitemproductsaleWhereUniqueInput
  }

  /**
   * itemitemproductsale findFirst
   */
  export type itemitemproductsaleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the itemitemproductsale
     */
    select?: itemitemproductsaleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the itemitemproductsale
     */
    omit?: itemitemproductsaleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: itemitemproductsaleInclude<ExtArgs> | null
    /**
     * Filter, which itemitemproductsale to fetch.
     */
    where?: itemitemproductsaleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of itemitemproductsales to fetch.
     */
    orderBy?: itemitemproductsaleOrderByWithRelationInput | itemitemproductsaleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for itemitemproductsales.
     */
    cursor?: itemitemproductsaleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` itemitemproductsales from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` itemitemproductsales.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of itemitemproductsales.
     */
    distinct?: ItemitemproductsaleScalarFieldEnum | ItemitemproductsaleScalarFieldEnum[]
  }

  /**
   * itemitemproductsale findFirstOrThrow
   */
  export type itemitemproductsaleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the itemitemproductsale
     */
    select?: itemitemproductsaleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the itemitemproductsale
     */
    omit?: itemitemproductsaleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: itemitemproductsaleInclude<ExtArgs> | null
    /**
     * Filter, which itemitemproductsale to fetch.
     */
    where?: itemitemproductsaleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of itemitemproductsales to fetch.
     */
    orderBy?: itemitemproductsaleOrderByWithRelationInput | itemitemproductsaleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for itemitemproductsales.
     */
    cursor?: itemitemproductsaleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` itemitemproductsales from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` itemitemproductsales.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of itemitemproductsales.
     */
    distinct?: ItemitemproductsaleScalarFieldEnum | ItemitemproductsaleScalarFieldEnum[]
  }

  /**
   * itemitemproductsale findMany
   */
  export type itemitemproductsaleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the itemitemproductsale
     */
    select?: itemitemproductsaleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the itemitemproductsale
     */
    omit?: itemitemproductsaleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: itemitemproductsaleInclude<ExtArgs> | null
    /**
     * Filter, which itemitemproductsales to fetch.
     */
    where?: itemitemproductsaleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of itemitemproductsales to fetch.
     */
    orderBy?: itemitemproductsaleOrderByWithRelationInput | itemitemproductsaleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing itemitemproductsales.
     */
    cursor?: itemitemproductsaleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` itemitemproductsales from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` itemitemproductsales.
     */
    skip?: number
    distinct?: ItemitemproductsaleScalarFieldEnum | ItemitemproductsaleScalarFieldEnum[]
  }

  /**
   * itemitemproductsale create
   */
  export type itemitemproductsaleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the itemitemproductsale
     */
    select?: itemitemproductsaleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the itemitemproductsale
     */
    omit?: itemitemproductsaleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: itemitemproductsaleInclude<ExtArgs> | null
    /**
     * The data needed to create a itemitemproductsale.
     */
    data: XOR<itemitemproductsaleCreateInput, itemitemproductsaleUncheckedCreateInput>
  }

  /**
   * itemitemproductsale createMany
   */
  export type itemitemproductsaleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many itemitemproductsales.
     */
    data: itemitemproductsaleCreateManyInput | itemitemproductsaleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * itemitemproductsale createManyAndReturn
   */
  export type itemitemproductsaleCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the itemitemproductsale
     */
    select?: itemitemproductsaleSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the itemitemproductsale
     */
    omit?: itemitemproductsaleOmit<ExtArgs> | null
    /**
     * The data used to create many itemitemproductsales.
     */
    data: itemitemproductsaleCreateManyInput | itemitemproductsaleCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: itemitemproductsaleIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * itemitemproductsale update
   */
  export type itemitemproductsaleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the itemitemproductsale
     */
    select?: itemitemproductsaleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the itemitemproductsale
     */
    omit?: itemitemproductsaleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: itemitemproductsaleInclude<ExtArgs> | null
    /**
     * The data needed to update a itemitemproductsale.
     */
    data: XOR<itemitemproductsaleUpdateInput, itemitemproductsaleUncheckedUpdateInput>
    /**
     * Choose, which itemitemproductsale to update.
     */
    where: itemitemproductsaleWhereUniqueInput
  }

  /**
   * itemitemproductsale updateMany
   */
  export type itemitemproductsaleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update itemitemproductsales.
     */
    data: XOR<itemitemproductsaleUpdateManyMutationInput, itemitemproductsaleUncheckedUpdateManyInput>
    /**
     * Filter which itemitemproductsales to update
     */
    where?: itemitemproductsaleWhereInput
    /**
     * Limit how many itemitemproductsales to update.
     */
    limit?: number
  }

  /**
   * itemitemproductsale updateManyAndReturn
   */
  export type itemitemproductsaleUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the itemitemproductsale
     */
    select?: itemitemproductsaleSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the itemitemproductsale
     */
    omit?: itemitemproductsaleOmit<ExtArgs> | null
    /**
     * The data used to update itemitemproductsales.
     */
    data: XOR<itemitemproductsaleUpdateManyMutationInput, itemitemproductsaleUncheckedUpdateManyInput>
    /**
     * Filter which itemitemproductsales to update
     */
    where?: itemitemproductsaleWhereInput
    /**
     * Limit how many itemitemproductsales to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: itemitemproductsaleIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * itemitemproductsale upsert
   */
  export type itemitemproductsaleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the itemitemproductsale
     */
    select?: itemitemproductsaleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the itemitemproductsale
     */
    omit?: itemitemproductsaleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: itemitemproductsaleInclude<ExtArgs> | null
    /**
     * The filter to search for the itemitemproductsale to update in case it exists.
     */
    where: itemitemproductsaleWhereUniqueInput
    /**
     * In case the itemitemproductsale found by the `where` argument doesn't exist, create a new itemitemproductsale with this data.
     */
    create: XOR<itemitemproductsaleCreateInput, itemitemproductsaleUncheckedCreateInput>
    /**
     * In case the itemitemproductsale was found with the provided `where` argument, update it with this data.
     */
    update: XOR<itemitemproductsaleUpdateInput, itemitemproductsaleUncheckedUpdateInput>
  }

  /**
   * itemitemproductsale delete
   */
  export type itemitemproductsaleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the itemitemproductsale
     */
    select?: itemitemproductsaleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the itemitemproductsale
     */
    omit?: itemitemproductsaleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: itemitemproductsaleInclude<ExtArgs> | null
    /**
     * Filter which itemitemproductsale to delete.
     */
    where: itemitemproductsaleWhereUniqueInput
  }

  /**
   * itemitemproductsale deleteMany
   */
  export type itemitemproductsaleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which itemitemproductsales to delete
     */
    where?: itemitemproductsaleWhereInput
    /**
     * Limit how many itemitemproductsales to delete.
     */
    limit?: number
  }

  /**
   * itemitemproductsale.optiongroup
   */
  export type itemitemproductsale$optiongroupArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the optiongroup
     */
    select?: optiongroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the optiongroup
     */
    omit?: optiongroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: optiongroupInclude<ExtArgs> | null
    where?: optiongroupWhereInput
  }

  /**
   * itemitemproductsale without action
   */
  export type itemitemproductsaleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the itemitemproductsale
     */
    select?: itemitemproductsaleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the itemitemproductsale
     */
    omit?: itemitemproductsaleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: itemitemproductsaleInclude<ExtArgs> | null
  }


  /**
   * Model deliverysale
   */

  export type AggregateDeliverysale = {
    _count: DeliverysaleCountAggregateOutputType | null
    _avg: DeliverysaleAvgAggregateOutputType | null
    _sum: DeliverysaleSumAggregateOutputType | null
    _min: DeliverysaleMinAggregateOutputType | null
    _max: DeliverysaleMaxAggregateOutputType | null
  }

  export type DeliverysaleAvgAggregateOutputType = {
    id: number | null
    sale_id: number | null
    delivery_fee: number | null
    courier_fee: number | null
  }

  export type DeliverysaleSumAggregateOutputType = {
    id: number | null
    sale_id: number | null
    delivery_fee: number | null
    courier_fee: number | null
  }

  export type DeliverysaleMinAggregateOutputType = {
    id: number | null
    sale_id: number | null
    courier_id: string | null
    courier_name: string | null
    courier_phone: string | null
    courier_type: string | null
    delivered_by: string | null
    delivery_type: string | null
    status: string | null
    delivery_fee: number | null
    courier_fee: number | null
    timing: string | null
    mode: string | null
  }

  export type DeliverysaleMaxAggregateOutputType = {
    id: number | null
    sale_id: number | null
    courier_id: string | null
    courier_name: string | null
    courier_phone: string | null
    courier_type: string | null
    delivered_by: string | null
    delivery_type: string | null
    status: string | null
    delivery_fee: number | null
    courier_fee: number | null
    timing: string | null
    mode: string | null
  }

  export type DeliverysaleCountAggregateOutputType = {
    id: number
    sale_id: number
    courier_id: number
    courier_name: number
    courier_phone: number
    courier_type: number
    delivered_by: number
    delivery_type: number
    status: number
    delivery_fee: number
    courier_fee: number
    timing: number
    mode: number
    _all: number
  }


  export type DeliverysaleAvgAggregateInputType = {
    id?: true
    sale_id?: true
    delivery_fee?: true
    courier_fee?: true
  }

  export type DeliverysaleSumAggregateInputType = {
    id?: true
    sale_id?: true
    delivery_fee?: true
    courier_fee?: true
  }

  export type DeliverysaleMinAggregateInputType = {
    id?: true
    sale_id?: true
    courier_id?: true
    courier_name?: true
    courier_phone?: true
    courier_type?: true
    delivered_by?: true
    delivery_type?: true
    status?: true
    delivery_fee?: true
    courier_fee?: true
    timing?: true
    mode?: true
  }

  export type DeliverysaleMaxAggregateInputType = {
    id?: true
    sale_id?: true
    courier_id?: true
    courier_name?: true
    courier_phone?: true
    courier_type?: true
    delivered_by?: true
    delivery_type?: true
    status?: true
    delivery_fee?: true
    courier_fee?: true
    timing?: true
    mode?: true
  }

  export type DeliverysaleCountAggregateInputType = {
    id?: true
    sale_id?: true
    courier_id?: true
    courier_name?: true
    courier_phone?: true
    courier_type?: true
    delivered_by?: true
    delivery_type?: true
    status?: true
    delivery_fee?: true
    courier_fee?: true
    timing?: true
    mode?: true
    _all?: true
  }

  export type DeliverysaleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which deliverysale to aggregate.
     */
    where?: deliverysaleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of deliverysales to fetch.
     */
    orderBy?: deliverysaleOrderByWithRelationInput | deliverysaleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: deliverysaleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` deliverysales from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` deliverysales.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned deliverysales
    **/
    _count?: true | DeliverysaleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DeliverysaleAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DeliverysaleSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DeliverysaleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DeliverysaleMaxAggregateInputType
  }

  export type GetDeliverysaleAggregateType<T extends DeliverysaleAggregateArgs> = {
        [P in keyof T & keyof AggregateDeliverysale]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDeliverysale[P]>
      : GetScalarType<T[P], AggregateDeliverysale[P]>
  }




  export type deliverysaleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: deliverysaleWhereInput
    orderBy?: deliverysaleOrderByWithAggregationInput | deliverysaleOrderByWithAggregationInput[]
    by: DeliverysaleScalarFieldEnum[] | DeliverysaleScalarFieldEnum
    having?: deliverysaleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DeliverysaleCountAggregateInputType | true
    _avg?: DeliverysaleAvgAggregateInputType
    _sum?: DeliverysaleSumAggregateInputType
    _min?: DeliverysaleMinAggregateInputType
    _max?: DeliverysaleMaxAggregateInputType
  }

  export type DeliverysaleGroupByOutputType = {
    id: number
    sale_id: number
    courier_id: string | null
    courier_name: string | null
    courier_phone: string | null
    courier_type: string | null
    delivered_by: string | null
    delivery_type: string | null
    status: string | null
    delivery_fee: number | null
    courier_fee: number | null
    timing: string | null
    mode: string | null
    _count: DeliverysaleCountAggregateOutputType | null
    _avg: DeliverysaleAvgAggregateOutputType | null
    _sum: DeliverysaleSumAggregateOutputType | null
    _min: DeliverysaleMinAggregateOutputType | null
    _max: DeliverysaleMaxAggregateOutputType | null
  }

  type GetDeliverysaleGroupByPayload<T extends deliverysaleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DeliverysaleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DeliverysaleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DeliverysaleGroupByOutputType[P]>
            : GetScalarType<T[P], DeliverysaleGroupByOutputType[P]>
        }
      >
    >


  export type deliverysaleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sale_id?: boolean
    courier_id?: boolean
    courier_name?: boolean
    courier_phone?: boolean
    courier_type?: boolean
    delivered_by?: boolean
    delivery_type?: boolean
    status?: boolean
    delivery_fee?: boolean
    courier_fee?: boolean
    timing?: boolean
    mode?: boolean
    sale?: boolean | saleDefaultArgs<ExtArgs>
    deliveryaddresses?: boolean | deliverysale$deliveryaddressesArgs<ExtArgs>
    _count?: boolean | DeliverysaleCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["deliverysale"]>

  export type deliverysaleSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sale_id?: boolean
    courier_id?: boolean
    courier_name?: boolean
    courier_phone?: boolean
    courier_type?: boolean
    delivered_by?: boolean
    delivery_type?: boolean
    status?: boolean
    delivery_fee?: boolean
    courier_fee?: boolean
    timing?: boolean
    mode?: boolean
    sale?: boolean | saleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["deliverysale"]>

  export type deliverysaleSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sale_id?: boolean
    courier_id?: boolean
    courier_name?: boolean
    courier_phone?: boolean
    courier_type?: boolean
    delivered_by?: boolean
    delivery_type?: boolean
    status?: boolean
    delivery_fee?: boolean
    courier_fee?: boolean
    timing?: boolean
    mode?: boolean
    sale?: boolean | saleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["deliverysale"]>

  export type deliverysaleSelectScalar = {
    id?: boolean
    sale_id?: boolean
    courier_id?: boolean
    courier_name?: boolean
    courier_phone?: boolean
    courier_type?: boolean
    delivered_by?: boolean
    delivery_type?: boolean
    status?: boolean
    delivery_fee?: boolean
    courier_fee?: boolean
    timing?: boolean
    mode?: boolean
  }

  export type deliverysaleOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "sale_id" | "courier_id" | "courier_name" | "courier_phone" | "courier_type" | "delivered_by" | "delivery_type" | "status" | "delivery_fee" | "courier_fee" | "timing" | "mode", ExtArgs["result"]["deliverysale"]>
  export type deliverysaleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sale?: boolean | saleDefaultArgs<ExtArgs>
    deliveryaddresses?: boolean | deliverysale$deliveryaddressesArgs<ExtArgs>
    _count?: boolean | DeliverysaleCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type deliverysaleIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sale?: boolean | saleDefaultArgs<ExtArgs>
  }
  export type deliverysaleIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sale?: boolean | saleDefaultArgs<ExtArgs>
  }

  export type $deliverysalePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "deliverysale"
    objects: {
      sale: Prisma.$salePayload<ExtArgs>
      deliveryaddresses: Prisma.$deliveryaddressPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      sale_id: number
      courier_id: string | null
      courier_name: string | null
      courier_phone: string | null
      courier_type: string | null
      delivered_by: string | null
      delivery_type: string | null
      status: string | null
      delivery_fee: number | null
      courier_fee: number | null
      timing: string | null
      mode: string | null
    }, ExtArgs["result"]["deliverysale"]>
    composites: {}
  }

  type deliverysaleGetPayload<S extends boolean | null | undefined | deliverysaleDefaultArgs> = $Result.GetResult<Prisma.$deliverysalePayload, S>

  type deliverysaleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<deliverysaleFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DeliverysaleCountAggregateInputType | true
    }

  export interface deliverysaleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['deliverysale'], meta: { name: 'deliverysale' } }
    /**
     * Find zero or one Deliverysale that matches the filter.
     * @param {deliverysaleFindUniqueArgs} args - Arguments to find a Deliverysale
     * @example
     * // Get one Deliverysale
     * const deliverysale = await prisma.deliverysale.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends deliverysaleFindUniqueArgs>(args: SelectSubset<T, deliverysaleFindUniqueArgs<ExtArgs>>): Prisma__deliverysaleClient<$Result.GetResult<Prisma.$deliverysalePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Deliverysale that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {deliverysaleFindUniqueOrThrowArgs} args - Arguments to find a Deliverysale
     * @example
     * // Get one Deliverysale
     * const deliverysale = await prisma.deliverysale.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends deliverysaleFindUniqueOrThrowArgs>(args: SelectSubset<T, deliverysaleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__deliverysaleClient<$Result.GetResult<Prisma.$deliverysalePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Deliverysale that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {deliverysaleFindFirstArgs} args - Arguments to find a Deliverysale
     * @example
     * // Get one Deliverysale
     * const deliverysale = await prisma.deliverysale.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends deliverysaleFindFirstArgs>(args?: SelectSubset<T, deliverysaleFindFirstArgs<ExtArgs>>): Prisma__deliverysaleClient<$Result.GetResult<Prisma.$deliverysalePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Deliverysale that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {deliverysaleFindFirstOrThrowArgs} args - Arguments to find a Deliverysale
     * @example
     * // Get one Deliverysale
     * const deliverysale = await prisma.deliverysale.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends deliverysaleFindFirstOrThrowArgs>(args?: SelectSubset<T, deliverysaleFindFirstOrThrowArgs<ExtArgs>>): Prisma__deliverysaleClient<$Result.GetResult<Prisma.$deliverysalePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Deliverysales that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {deliverysaleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Deliverysales
     * const deliverysales = await prisma.deliverysale.findMany()
     * 
     * // Get first 10 Deliverysales
     * const deliverysales = await prisma.deliverysale.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const deliverysaleWithIdOnly = await prisma.deliverysale.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends deliverysaleFindManyArgs>(args?: SelectSubset<T, deliverysaleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$deliverysalePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Deliverysale.
     * @param {deliverysaleCreateArgs} args - Arguments to create a Deliverysale.
     * @example
     * // Create one Deliverysale
     * const Deliverysale = await prisma.deliverysale.create({
     *   data: {
     *     // ... data to create a Deliverysale
     *   }
     * })
     * 
     */
    create<T extends deliverysaleCreateArgs>(args: SelectSubset<T, deliverysaleCreateArgs<ExtArgs>>): Prisma__deliverysaleClient<$Result.GetResult<Prisma.$deliverysalePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Deliverysales.
     * @param {deliverysaleCreateManyArgs} args - Arguments to create many Deliverysales.
     * @example
     * // Create many Deliverysales
     * const deliverysale = await prisma.deliverysale.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends deliverysaleCreateManyArgs>(args?: SelectSubset<T, deliverysaleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Deliverysales and returns the data saved in the database.
     * @param {deliverysaleCreateManyAndReturnArgs} args - Arguments to create many Deliverysales.
     * @example
     * // Create many Deliverysales
     * const deliverysale = await prisma.deliverysale.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Deliverysales and only return the `id`
     * const deliverysaleWithIdOnly = await prisma.deliverysale.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends deliverysaleCreateManyAndReturnArgs>(args?: SelectSubset<T, deliverysaleCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$deliverysalePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Deliverysale.
     * @param {deliverysaleDeleteArgs} args - Arguments to delete one Deliverysale.
     * @example
     * // Delete one Deliverysale
     * const Deliverysale = await prisma.deliverysale.delete({
     *   where: {
     *     // ... filter to delete one Deliverysale
     *   }
     * })
     * 
     */
    delete<T extends deliverysaleDeleteArgs>(args: SelectSubset<T, deliverysaleDeleteArgs<ExtArgs>>): Prisma__deliverysaleClient<$Result.GetResult<Prisma.$deliverysalePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Deliverysale.
     * @param {deliverysaleUpdateArgs} args - Arguments to update one Deliverysale.
     * @example
     * // Update one Deliverysale
     * const deliverysale = await prisma.deliverysale.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends deliverysaleUpdateArgs>(args: SelectSubset<T, deliverysaleUpdateArgs<ExtArgs>>): Prisma__deliverysaleClient<$Result.GetResult<Prisma.$deliverysalePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Deliverysales.
     * @param {deliverysaleDeleteManyArgs} args - Arguments to filter Deliverysales to delete.
     * @example
     * // Delete a few Deliverysales
     * const { count } = await prisma.deliverysale.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends deliverysaleDeleteManyArgs>(args?: SelectSubset<T, deliverysaleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Deliverysales.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {deliverysaleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Deliverysales
     * const deliverysale = await prisma.deliverysale.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends deliverysaleUpdateManyArgs>(args: SelectSubset<T, deliverysaleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Deliverysales and returns the data updated in the database.
     * @param {deliverysaleUpdateManyAndReturnArgs} args - Arguments to update many Deliverysales.
     * @example
     * // Update many Deliverysales
     * const deliverysale = await prisma.deliverysale.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Deliverysales and only return the `id`
     * const deliverysaleWithIdOnly = await prisma.deliverysale.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends deliverysaleUpdateManyAndReturnArgs>(args: SelectSubset<T, deliverysaleUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$deliverysalePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Deliverysale.
     * @param {deliverysaleUpsertArgs} args - Arguments to update or create a Deliverysale.
     * @example
     * // Update or create a Deliverysale
     * const deliverysale = await prisma.deliverysale.upsert({
     *   create: {
     *     // ... data to create a Deliverysale
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Deliverysale we want to update
     *   }
     * })
     */
    upsert<T extends deliverysaleUpsertArgs>(args: SelectSubset<T, deliverysaleUpsertArgs<ExtArgs>>): Prisma__deliverysaleClient<$Result.GetResult<Prisma.$deliverysalePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Deliverysales.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {deliverysaleCountArgs} args - Arguments to filter Deliverysales to count.
     * @example
     * // Count the number of Deliverysales
     * const count = await prisma.deliverysale.count({
     *   where: {
     *     // ... the filter for the Deliverysales we want to count
     *   }
     * })
    **/
    count<T extends deliverysaleCountArgs>(
      args?: Subset<T, deliverysaleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DeliverysaleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Deliverysale.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeliverysaleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DeliverysaleAggregateArgs>(args: Subset<T, DeliverysaleAggregateArgs>): Prisma.PrismaPromise<GetDeliverysaleAggregateType<T>>

    /**
     * Group by Deliverysale.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {deliverysaleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends deliverysaleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: deliverysaleGroupByArgs['orderBy'] }
        : { orderBy?: deliverysaleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, deliverysaleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDeliverysaleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the deliverysale model
   */
  readonly fields: deliverysaleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for deliverysale.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__deliverysaleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    sale<T extends saleDefaultArgs<ExtArgs> = {}>(args?: Subset<T, saleDefaultArgs<ExtArgs>>): Prisma__saleClient<$Result.GetResult<Prisma.$salePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    deliveryaddresses<T extends deliverysale$deliveryaddressesArgs<ExtArgs> = {}>(args?: Subset<T, deliverysale$deliveryaddressesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$deliveryaddressPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the deliverysale model
   */
  interface deliverysaleFieldRefs {
    readonly id: FieldRef<"deliverysale", 'Int'>
    readonly sale_id: FieldRef<"deliverysale", 'Int'>
    readonly courier_id: FieldRef<"deliverysale", 'String'>
    readonly courier_name: FieldRef<"deliverysale", 'String'>
    readonly courier_phone: FieldRef<"deliverysale", 'String'>
    readonly courier_type: FieldRef<"deliverysale", 'String'>
    readonly delivered_by: FieldRef<"deliverysale", 'String'>
    readonly delivery_type: FieldRef<"deliverysale", 'String'>
    readonly status: FieldRef<"deliverysale", 'String'>
    readonly delivery_fee: FieldRef<"deliverysale", 'Float'>
    readonly courier_fee: FieldRef<"deliverysale", 'Float'>
    readonly timing: FieldRef<"deliverysale", 'String'>
    readonly mode: FieldRef<"deliverysale", 'String'>
  }
    

  // Custom InputTypes
  /**
   * deliverysale findUnique
   */
  export type deliverysaleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the deliverysale
     */
    select?: deliverysaleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the deliverysale
     */
    omit?: deliverysaleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: deliverysaleInclude<ExtArgs> | null
    /**
     * Filter, which deliverysale to fetch.
     */
    where: deliverysaleWhereUniqueInput
  }

  /**
   * deliverysale findUniqueOrThrow
   */
  export type deliverysaleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the deliverysale
     */
    select?: deliverysaleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the deliverysale
     */
    omit?: deliverysaleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: deliverysaleInclude<ExtArgs> | null
    /**
     * Filter, which deliverysale to fetch.
     */
    where: deliverysaleWhereUniqueInput
  }

  /**
   * deliverysale findFirst
   */
  export type deliverysaleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the deliverysale
     */
    select?: deliverysaleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the deliverysale
     */
    omit?: deliverysaleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: deliverysaleInclude<ExtArgs> | null
    /**
     * Filter, which deliverysale to fetch.
     */
    where?: deliverysaleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of deliverysales to fetch.
     */
    orderBy?: deliverysaleOrderByWithRelationInput | deliverysaleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for deliverysales.
     */
    cursor?: deliverysaleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` deliverysales from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` deliverysales.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of deliverysales.
     */
    distinct?: DeliverysaleScalarFieldEnum | DeliverysaleScalarFieldEnum[]
  }

  /**
   * deliverysale findFirstOrThrow
   */
  export type deliverysaleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the deliverysale
     */
    select?: deliverysaleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the deliverysale
     */
    omit?: deliverysaleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: deliverysaleInclude<ExtArgs> | null
    /**
     * Filter, which deliverysale to fetch.
     */
    where?: deliverysaleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of deliverysales to fetch.
     */
    orderBy?: deliverysaleOrderByWithRelationInput | deliverysaleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for deliverysales.
     */
    cursor?: deliverysaleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` deliverysales from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` deliverysales.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of deliverysales.
     */
    distinct?: DeliverysaleScalarFieldEnum | DeliverysaleScalarFieldEnum[]
  }

  /**
   * deliverysale findMany
   */
  export type deliverysaleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the deliverysale
     */
    select?: deliverysaleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the deliverysale
     */
    omit?: deliverysaleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: deliverysaleInclude<ExtArgs> | null
    /**
     * Filter, which deliverysales to fetch.
     */
    where?: deliverysaleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of deliverysales to fetch.
     */
    orderBy?: deliverysaleOrderByWithRelationInput | deliverysaleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing deliverysales.
     */
    cursor?: deliverysaleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` deliverysales from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` deliverysales.
     */
    skip?: number
    distinct?: DeliverysaleScalarFieldEnum | DeliverysaleScalarFieldEnum[]
  }

  /**
   * deliverysale create
   */
  export type deliverysaleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the deliverysale
     */
    select?: deliverysaleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the deliverysale
     */
    omit?: deliverysaleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: deliverysaleInclude<ExtArgs> | null
    /**
     * The data needed to create a deliverysale.
     */
    data: XOR<deliverysaleCreateInput, deliverysaleUncheckedCreateInput>
  }

  /**
   * deliverysale createMany
   */
  export type deliverysaleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many deliverysales.
     */
    data: deliverysaleCreateManyInput | deliverysaleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * deliverysale createManyAndReturn
   */
  export type deliverysaleCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the deliverysale
     */
    select?: deliverysaleSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the deliverysale
     */
    omit?: deliverysaleOmit<ExtArgs> | null
    /**
     * The data used to create many deliverysales.
     */
    data: deliverysaleCreateManyInput | deliverysaleCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: deliverysaleIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * deliverysale update
   */
  export type deliverysaleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the deliverysale
     */
    select?: deliverysaleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the deliverysale
     */
    omit?: deliverysaleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: deliverysaleInclude<ExtArgs> | null
    /**
     * The data needed to update a deliverysale.
     */
    data: XOR<deliverysaleUpdateInput, deliverysaleUncheckedUpdateInput>
    /**
     * Choose, which deliverysale to update.
     */
    where: deliverysaleWhereUniqueInput
  }

  /**
   * deliverysale updateMany
   */
  export type deliverysaleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update deliverysales.
     */
    data: XOR<deliverysaleUpdateManyMutationInput, deliverysaleUncheckedUpdateManyInput>
    /**
     * Filter which deliverysales to update
     */
    where?: deliverysaleWhereInput
    /**
     * Limit how many deliverysales to update.
     */
    limit?: number
  }

  /**
   * deliverysale updateManyAndReturn
   */
  export type deliverysaleUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the deliverysale
     */
    select?: deliverysaleSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the deliverysale
     */
    omit?: deliverysaleOmit<ExtArgs> | null
    /**
     * The data used to update deliverysales.
     */
    data: XOR<deliverysaleUpdateManyMutationInput, deliverysaleUncheckedUpdateManyInput>
    /**
     * Filter which deliverysales to update
     */
    where?: deliverysaleWhereInput
    /**
     * Limit how many deliverysales to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: deliverysaleIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * deliverysale upsert
   */
  export type deliverysaleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the deliverysale
     */
    select?: deliverysaleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the deliverysale
     */
    omit?: deliverysaleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: deliverysaleInclude<ExtArgs> | null
    /**
     * The filter to search for the deliverysale to update in case it exists.
     */
    where: deliverysaleWhereUniqueInput
    /**
     * In case the deliverysale found by the `where` argument doesn't exist, create a new deliverysale with this data.
     */
    create: XOR<deliverysaleCreateInput, deliverysaleUncheckedCreateInput>
    /**
     * In case the deliverysale was found with the provided `where` argument, update it with this data.
     */
    update: XOR<deliverysaleUpdateInput, deliverysaleUncheckedUpdateInput>
  }

  /**
   * deliverysale delete
   */
  export type deliverysaleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the deliverysale
     */
    select?: deliverysaleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the deliverysale
     */
    omit?: deliverysaleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: deliverysaleInclude<ExtArgs> | null
    /**
     * Filter which deliverysale to delete.
     */
    where: deliverysaleWhereUniqueInput
  }

  /**
   * deliverysale deleteMany
   */
  export type deliverysaleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which deliverysales to delete
     */
    where?: deliverysaleWhereInput
    /**
     * Limit how many deliverysales to delete.
     */
    limit?: number
  }

  /**
   * deliverysale.deliveryaddresses
   */
  export type deliverysale$deliveryaddressesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the deliveryaddress
     */
    select?: deliveryaddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the deliveryaddress
     */
    omit?: deliveryaddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: deliveryaddressInclude<ExtArgs> | null
    where?: deliveryaddressWhereInput
    orderBy?: deliveryaddressOrderByWithRelationInput | deliveryaddressOrderByWithRelationInput[]
    cursor?: deliveryaddressWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DeliveryaddressScalarFieldEnum | DeliveryaddressScalarFieldEnum[]
  }

  /**
   * deliverysale without action
   */
  export type deliverysaleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the deliverysale
     */
    select?: deliverysaleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the deliverysale
     */
    omit?: deliverysaleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: deliverysaleInclude<ExtArgs> | null
  }


  /**
   * Model deliveryaddress
   */

  export type AggregateDeliveryaddress = {
    _count: DeliveryaddressCountAggregateOutputType | null
    _avg: DeliveryaddressAvgAggregateOutputType | null
    _sum: DeliveryaddressSumAggregateOutputType | null
    _min: DeliveryaddressMinAggregateOutputType | null
    _max: DeliveryaddressMaxAggregateOutputType | null
  }

  export type DeliveryaddressAvgAggregateOutputType = {
    id: number | null
    sale_id: number | null
    delivery_sale_id: number | null
    latitude: number | null
    longitude: number | null
  }

  export type DeliveryaddressSumAggregateOutputType = {
    id: number | null
    sale_id: number | null
    delivery_sale_id: number | null
    latitude: number | null
    longitude: number | null
  }

  export type DeliveryaddressMinAggregateOutputType = {
    id: number | null
    sale_id: number | null
    delivery_sale_id: number | null
    street: string | null
    number: string | null
    complement: string | null
    formatted_address: string | null
    neighborhood: string | null
    city: string | null
    state: string | null
    country: string | null
    postal_code: string | null
    reference: string | null
    latitude: number | null
    longitude: number | null
  }

  export type DeliveryaddressMaxAggregateOutputType = {
    id: number | null
    sale_id: number | null
    delivery_sale_id: number | null
    street: string | null
    number: string | null
    complement: string | null
    formatted_address: string | null
    neighborhood: string | null
    city: string | null
    state: string | null
    country: string | null
    postal_code: string | null
    reference: string | null
    latitude: number | null
    longitude: number | null
  }

  export type DeliveryaddressCountAggregateOutputType = {
    id: number
    sale_id: number
    delivery_sale_id: number
    street: number
    number: number
    complement: number
    formatted_address: number
    neighborhood: number
    city: number
    state: number
    country: number
    postal_code: number
    reference: number
    latitude: number
    longitude: number
    _all: number
  }


  export type DeliveryaddressAvgAggregateInputType = {
    id?: true
    sale_id?: true
    delivery_sale_id?: true
    latitude?: true
    longitude?: true
  }

  export type DeliveryaddressSumAggregateInputType = {
    id?: true
    sale_id?: true
    delivery_sale_id?: true
    latitude?: true
    longitude?: true
  }

  export type DeliveryaddressMinAggregateInputType = {
    id?: true
    sale_id?: true
    delivery_sale_id?: true
    street?: true
    number?: true
    complement?: true
    formatted_address?: true
    neighborhood?: true
    city?: true
    state?: true
    country?: true
    postal_code?: true
    reference?: true
    latitude?: true
    longitude?: true
  }

  export type DeliveryaddressMaxAggregateInputType = {
    id?: true
    sale_id?: true
    delivery_sale_id?: true
    street?: true
    number?: true
    complement?: true
    formatted_address?: true
    neighborhood?: true
    city?: true
    state?: true
    country?: true
    postal_code?: true
    reference?: true
    latitude?: true
    longitude?: true
  }

  export type DeliveryaddressCountAggregateInputType = {
    id?: true
    sale_id?: true
    delivery_sale_id?: true
    street?: true
    number?: true
    complement?: true
    formatted_address?: true
    neighborhood?: true
    city?: true
    state?: true
    country?: true
    postal_code?: true
    reference?: true
    latitude?: true
    longitude?: true
    _all?: true
  }

  export type DeliveryaddressAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which deliveryaddress to aggregate.
     */
    where?: deliveryaddressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of deliveryaddresses to fetch.
     */
    orderBy?: deliveryaddressOrderByWithRelationInput | deliveryaddressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: deliveryaddressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` deliveryaddresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` deliveryaddresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned deliveryaddresses
    **/
    _count?: true | DeliveryaddressCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DeliveryaddressAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DeliveryaddressSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DeliveryaddressMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DeliveryaddressMaxAggregateInputType
  }

  export type GetDeliveryaddressAggregateType<T extends DeliveryaddressAggregateArgs> = {
        [P in keyof T & keyof AggregateDeliveryaddress]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDeliveryaddress[P]>
      : GetScalarType<T[P], AggregateDeliveryaddress[P]>
  }




  export type deliveryaddressGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: deliveryaddressWhereInput
    orderBy?: deliveryaddressOrderByWithAggregationInput | deliveryaddressOrderByWithAggregationInput[]
    by: DeliveryaddressScalarFieldEnum[] | DeliveryaddressScalarFieldEnum
    having?: deliveryaddressScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DeliveryaddressCountAggregateInputType | true
    _avg?: DeliveryaddressAvgAggregateInputType
    _sum?: DeliveryaddressSumAggregateInputType
    _min?: DeliveryaddressMinAggregateInputType
    _max?: DeliveryaddressMaxAggregateInputType
  }

  export type DeliveryaddressGroupByOutputType = {
    id: number
    sale_id: number
    delivery_sale_id: number | null
    street: string | null
    number: string | null
    complement: string | null
    formatted_address: string | null
    neighborhood: string | null
    city: string | null
    state: string | null
    country: string | null
    postal_code: string | null
    reference: string | null
    latitude: number | null
    longitude: number | null
    _count: DeliveryaddressCountAggregateOutputType | null
    _avg: DeliveryaddressAvgAggregateOutputType | null
    _sum: DeliveryaddressSumAggregateOutputType | null
    _min: DeliveryaddressMinAggregateOutputType | null
    _max: DeliveryaddressMaxAggregateOutputType | null
  }

  type GetDeliveryaddressGroupByPayload<T extends deliveryaddressGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DeliveryaddressGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DeliveryaddressGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DeliveryaddressGroupByOutputType[P]>
            : GetScalarType<T[P], DeliveryaddressGroupByOutputType[P]>
        }
      >
    >


  export type deliveryaddressSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sale_id?: boolean
    delivery_sale_id?: boolean
    street?: boolean
    number?: boolean
    complement?: boolean
    formatted_address?: boolean
    neighborhood?: boolean
    city?: boolean
    state?: boolean
    country?: boolean
    postal_code?: boolean
    reference?: boolean
    latitude?: boolean
    longitude?: boolean
    sale?: boolean | saleDefaultArgs<ExtArgs>
    deliverysale?: boolean | deliveryaddress$deliverysaleArgs<ExtArgs>
  }, ExtArgs["result"]["deliveryaddress"]>

  export type deliveryaddressSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sale_id?: boolean
    delivery_sale_id?: boolean
    street?: boolean
    number?: boolean
    complement?: boolean
    formatted_address?: boolean
    neighborhood?: boolean
    city?: boolean
    state?: boolean
    country?: boolean
    postal_code?: boolean
    reference?: boolean
    latitude?: boolean
    longitude?: boolean
    sale?: boolean | saleDefaultArgs<ExtArgs>
    deliverysale?: boolean | deliveryaddress$deliverysaleArgs<ExtArgs>
  }, ExtArgs["result"]["deliveryaddress"]>

  export type deliveryaddressSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sale_id?: boolean
    delivery_sale_id?: boolean
    street?: boolean
    number?: boolean
    complement?: boolean
    formatted_address?: boolean
    neighborhood?: boolean
    city?: boolean
    state?: boolean
    country?: boolean
    postal_code?: boolean
    reference?: boolean
    latitude?: boolean
    longitude?: boolean
    sale?: boolean | saleDefaultArgs<ExtArgs>
    deliverysale?: boolean | deliveryaddress$deliverysaleArgs<ExtArgs>
  }, ExtArgs["result"]["deliveryaddress"]>

  export type deliveryaddressSelectScalar = {
    id?: boolean
    sale_id?: boolean
    delivery_sale_id?: boolean
    street?: boolean
    number?: boolean
    complement?: boolean
    formatted_address?: boolean
    neighborhood?: boolean
    city?: boolean
    state?: boolean
    country?: boolean
    postal_code?: boolean
    reference?: boolean
    latitude?: boolean
    longitude?: boolean
  }

  export type deliveryaddressOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "sale_id" | "delivery_sale_id" | "street" | "number" | "complement" | "formatted_address" | "neighborhood" | "city" | "state" | "country" | "postal_code" | "reference" | "latitude" | "longitude", ExtArgs["result"]["deliveryaddress"]>
  export type deliveryaddressInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sale?: boolean | saleDefaultArgs<ExtArgs>
    deliverysale?: boolean | deliveryaddress$deliverysaleArgs<ExtArgs>
  }
  export type deliveryaddressIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sale?: boolean | saleDefaultArgs<ExtArgs>
    deliverysale?: boolean | deliveryaddress$deliverysaleArgs<ExtArgs>
  }
  export type deliveryaddressIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sale?: boolean | saleDefaultArgs<ExtArgs>
    deliverysale?: boolean | deliveryaddress$deliverysaleArgs<ExtArgs>
  }

  export type $deliveryaddressPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "deliveryaddress"
    objects: {
      sale: Prisma.$salePayload<ExtArgs>
      deliverysale: Prisma.$deliverysalePayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      sale_id: number
      delivery_sale_id: number | null
      street: string | null
      number: string | null
      complement: string | null
      formatted_address: string | null
      neighborhood: string | null
      city: string | null
      state: string | null
      country: string | null
      postal_code: string | null
      reference: string | null
      latitude: number | null
      longitude: number | null
    }, ExtArgs["result"]["deliveryaddress"]>
    composites: {}
  }

  type deliveryaddressGetPayload<S extends boolean | null | undefined | deliveryaddressDefaultArgs> = $Result.GetResult<Prisma.$deliveryaddressPayload, S>

  type deliveryaddressCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<deliveryaddressFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DeliveryaddressCountAggregateInputType | true
    }

  export interface deliveryaddressDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['deliveryaddress'], meta: { name: 'deliveryaddress' } }
    /**
     * Find zero or one Deliveryaddress that matches the filter.
     * @param {deliveryaddressFindUniqueArgs} args - Arguments to find a Deliveryaddress
     * @example
     * // Get one Deliveryaddress
     * const deliveryaddress = await prisma.deliveryaddress.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends deliveryaddressFindUniqueArgs>(args: SelectSubset<T, deliveryaddressFindUniqueArgs<ExtArgs>>): Prisma__deliveryaddressClient<$Result.GetResult<Prisma.$deliveryaddressPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Deliveryaddress that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {deliveryaddressFindUniqueOrThrowArgs} args - Arguments to find a Deliveryaddress
     * @example
     * // Get one Deliveryaddress
     * const deliveryaddress = await prisma.deliveryaddress.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends deliveryaddressFindUniqueOrThrowArgs>(args: SelectSubset<T, deliveryaddressFindUniqueOrThrowArgs<ExtArgs>>): Prisma__deliveryaddressClient<$Result.GetResult<Prisma.$deliveryaddressPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Deliveryaddress that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {deliveryaddressFindFirstArgs} args - Arguments to find a Deliveryaddress
     * @example
     * // Get one Deliveryaddress
     * const deliveryaddress = await prisma.deliveryaddress.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends deliveryaddressFindFirstArgs>(args?: SelectSubset<T, deliveryaddressFindFirstArgs<ExtArgs>>): Prisma__deliveryaddressClient<$Result.GetResult<Prisma.$deliveryaddressPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Deliveryaddress that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {deliveryaddressFindFirstOrThrowArgs} args - Arguments to find a Deliveryaddress
     * @example
     * // Get one Deliveryaddress
     * const deliveryaddress = await prisma.deliveryaddress.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends deliveryaddressFindFirstOrThrowArgs>(args?: SelectSubset<T, deliveryaddressFindFirstOrThrowArgs<ExtArgs>>): Prisma__deliveryaddressClient<$Result.GetResult<Prisma.$deliveryaddressPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Deliveryaddresses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {deliveryaddressFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Deliveryaddresses
     * const deliveryaddresses = await prisma.deliveryaddress.findMany()
     * 
     * // Get first 10 Deliveryaddresses
     * const deliveryaddresses = await prisma.deliveryaddress.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const deliveryaddressWithIdOnly = await prisma.deliveryaddress.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends deliveryaddressFindManyArgs>(args?: SelectSubset<T, deliveryaddressFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$deliveryaddressPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Deliveryaddress.
     * @param {deliveryaddressCreateArgs} args - Arguments to create a Deliveryaddress.
     * @example
     * // Create one Deliveryaddress
     * const Deliveryaddress = await prisma.deliveryaddress.create({
     *   data: {
     *     // ... data to create a Deliveryaddress
     *   }
     * })
     * 
     */
    create<T extends deliveryaddressCreateArgs>(args: SelectSubset<T, deliveryaddressCreateArgs<ExtArgs>>): Prisma__deliveryaddressClient<$Result.GetResult<Prisma.$deliveryaddressPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Deliveryaddresses.
     * @param {deliveryaddressCreateManyArgs} args - Arguments to create many Deliveryaddresses.
     * @example
     * // Create many Deliveryaddresses
     * const deliveryaddress = await prisma.deliveryaddress.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends deliveryaddressCreateManyArgs>(args?: SelectSubset<T, deliveryaddressCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Deliveryaddresses and returns the data saved in the database.
     * @param {deliveryaddressCreateManyAndReturnArgs} args - Arguments to create many Deliveryaddresses.
     * @example
     * // Create many Deliveryaddresses
     * const deliveryaddress = await prisma.deliveryaddress.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Deliveryaddresses and only return the `id`
     * const deliveryaddressWithIdOnly = await prisma.deliveryaddress.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends deliveryaddressCreateManyAndReturnArgs>(args?: SelectSubset<T, deliveryaddressCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$deliveryaddressPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Deliveryaddress.
     * @param {deliveryaddressDeleteArgs} args - Arguments to delete one Deliveryaddress.
     * @example
     * // Delete one Deliveryaddress
     * const Deliveryaddress = await prisma.deliveryaddress.delete({
     *   where: {
     *     // ... filter to delete one Deliveryaddress
     *   }
     * })
     * 
     */
    delete<T extends deliveryaddressDeleteArgs>(args: SelectSubset<T, deliveryaddressDeleteArgs<ExtArgs>>): Prisma__deliveryaddressClient<$Result.GetResult<Prisma.$deliveryaddressPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Deliveryaddress.
     * @param {deliveryaddressUpdateArgs} args - Arguments to update one Deliveryaddress.
     * @example
     * // Update one Deliveryaddress
     * const deliveryaddress = await prisma.deliveryaddress.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends deliveryaddressUpdateArgs>(args: SelectSubset<T, deliveryaddressUpdateArgs<ExtArgs>>): Prisma__deliveryaddressClient<$Result.GetResult<Prisma.$deliveryaddressPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Deliveryaddresses.
     * @param {deliveryaddressDeleteManyArgs} args - Arguments to filter Deliveryaddresses to delete.
     * @example
     * // Delete a few Deliveryaddresses
     * const { count } = await prisma.deliveryaddress.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends deliveryaddressDeleteManyArgs>(args?: SelectSubset<T, deliveryaddressDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Deliveryaddresses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {deliveryaddressUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Deliveryaddresses
     * const deliveryaddress = await prisma.deliveryaddress.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends deliveryaddressUpdateManyArgs>(args: SelectSubset<T, deliveryaddressUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Deliveryaddresses and returns the data updated in the database.
     * @param {deliveryaddressUpdateManyAndReturnArgs} args - Arguments to update many Deliveryaddresses.
     * @example
     * // Update many Deliveryaddresses
     * const deliveryaddress = await prisma.deliveryaddress.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Deliveryaddresses and only return the `id`
     * const deliveryaddressWithIdOnly = await prisma.deliveryaddress.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends deliveryaddressUpdateManyAndReturnArgs>(args: SelectSubset<T, deliveryaddressUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$deliveryaddressPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Deliveryaddress.
     * @param {deliveryaddressUpsertArgs} args - Arguments to update or create a Deliveryaddress.
     * @example
     * // Update or create a Deliveryaddress
     * const deliveryaddress = await prisma.deliveryaddress.upsert({
     *   create: {
     *     // ... data to create a Deliveryaddress
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Deliveryaddress we want to update
     *   }
     * })
     */
    upsert<T extends deliveryaddressUpsertArgs>(args: SelectSubset<T, deliveryaddressUpsertArgs<ExtArgs>>): Prisma__deliveryaddressClient<$Result.GetResult<Prisma.$deliveryaddressPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Deliveryaddresses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {deliveryaddressCountArgs} args - Arguments to filter Deliveryaddresses to count.
     * @example
     * // Count the number of Deliveryaddresses
     * const count = await prisma.deliveryaddress.count({
     *   where: {
     *     // ... the filter for the Deliveryaddresses we want to count
     *   }
     * })
    **/
    count<T extends deliveryaddressCountArgs>(
      args?: Subset<T, deliveryaddressCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DeliveryaddressCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Deliveryaddress.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeliveryaddressAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DeliveryaddressAggregateArgs>(args: Subset<T, DeliveryaddressAggregateArgs>): Prisma.PrismaPromise<GetDeliveryaddressAggregateType<T>>

    /**
     * Group by Deliveryaddress.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {deliveryaddressGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends deliveryaddressGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: deliveryaddressGroupByArgs['orderBy'] }
        : { orderBy?: deliveryaddressGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, deliveryaddressGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDeliveryaddressGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the deliveryaddress model
   */
  readonly fields: deliveryaddressFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for deliveryaddress.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__deliveryaddressClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    sale<T extends saleDefaultArgs<ExtArgs> = {}>(args?: Subset<T, saleDefaultArgs<ExtArgs>>): Prisma__saleClient<$Result.GetResult<Prisma.$salePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    deliverysale<T extends deliveryaddress$deliverysaleArgs<ExtArgs> = {}>(args?: Subset<T, deliveryaddress$deliverysaleArgs<ExtArgs>>): Prisma__deliverysaleClient<$Result.GetResult<Prisma.$deliverysalePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the deliveryaddress model
   */
  interface deliveryaddressFieldRefs {
    readonly id: FieldRef<"deliveryaddress", 'Int'>
    readonly sale_id: FieldRef<"deliveryaddress", 'Int'>
    readonly delivery_sale_id: FieldRef<"deliveryaddress", 'Int'>
    readonly street: FieldRef<"deliveryaddress", 'String'>
    readonly number: FieldRef<"deliveryaddress", 'String'>
    readonly complement: FieldRef<"deliveryaddress", 'String'>
    readonly formatted_address: FieldRef<"deliveryaddress", 'String'>
    readonly neighborhood: FieldRef<"deliveryaddress", 'String'>
    readonly city: FieldRef<"deliveryaddress", 'String'>
    readonly state: FieldRef<"deliveryaddress", 'String'>
    readonly country: FieldRef<"deliveryaddress", 'String'>
    readonly postal_code: FieldRef<"deliveryaddress", 'String'>
    readonly reference: FieldRef<"deliveryaddress", 'String'>
    readonly latitude: FieldRef<"deliveryaddress", 'Float'>
    readonly longitude: FieldRef<"deliveryaddress", 'Float'>
  }
    

  // Custom InputTypes
  /**
   * deliveryaddress findUnique
   */
  export type deliveryaddressFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the deliveryaddress
     */
    select?: deliveryaddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the deliveryaddress
     */
    omit?: deliveryaddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: deliveryaddressInclude<ExtArgs> | null
    /**
     * Filter, which deliveryaddress to fetch.
     */
    where: deliveryaddressWhereUniqueInput
  }

  /**
   * deliveryaddress findUniqueOrThrow
   */
  export type deliveryaddressFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the deliveryaddress
     */
    select?: deliveryaddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the deliveryaddress
     */
    omit?: deliveryaddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: deliveryaddressInclude<ExtArgs> | null
    /**
     * Filter, which deliveryaddress to fetch.
     */
    where: deliveryaddressWhereUniqueInput
  }

  /**
   * deliveryaddress findFirst
   */
  export type deliveryaddressFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the deliveryaddress
     */
    select?: deliveryaddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the deliveryaddress
     */
    omit?: deliveryaddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: deliveryaddressInclude<ExtArgs> | null
    /**
     * Filter, which deliveryaddress to fetch.
     */
    where?: deliveryaddressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of deliveryaddresses to fetch.
     */
    orderBy?: deliveryaddressOrderByWithRelationInput | deliveryaddressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for deliveryaddresses.
     */
    cursor?: deliveryaddressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` deliveryaddresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` deliveryaddresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of deliveryaddresses.
     */
    distinct?: DeliveryaddressScalarFieldEnum | DeliveryaddressScalarFieldEnum[]
  }

  /**
   * deliveryaddress findFirstOrThrow
   */
  export type deliveryaddressFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the deliveryaddress
     */
    select?: deliveryaddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the deliveryaddress
     */
    omit?: deliveryaddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: deliveryaddressInclude<ExtArgs> | null
    /**
     * Filter, which deliveryaddress to fetch.
     */
    where?: deliveryaddressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of deliveryaddresses to fetch.
     */
    orderBy?: deliveryaddressOrderByWithRelationInput | deliveryaddressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for deliveryaddresses.
     */
    cursor?: deliveryaddressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` deliveryaddresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` deliveryaddresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of deliveryaddresses.
     */
    distinct?: DeliveryaddressScalarFieldEnum | DeliveryaddressScalarFieldEnum[]
  }

  /**
   * deliveryaddress findMany
   */
  export type deliveryaddressFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the deliveryaddress
     */
    select?: deliveryaddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the deliveryaddress
     */
    omit?: deliveryaddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: deliveryaddressInclude<ExtArgs> | null
    /**
     * Filter, which deliveryaddresses to fetch.
     */
    where?: deliveryaddressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of deliveryaddresses to fetch.
     */
    orderBy?: deliveryaddressOrderByWithRelationInput | deliveryaddressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing deliveryaddresses.
     */
    cursor?: deliveryaddressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` deliveryaddresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` deliveryaddresses.
     */
    skip?: number
    distinct?: DeliveryaddressScalarFieldEnum | DeliveryaddressScalarFieldEnum[]
  }

  /**
   * deliveryaddress create
   */
  export type deliveryaddressCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the deliveryaddress
     */
    select?: deliveryaddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the deliveryaddress
     */
    omit?: deliveryaddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: deliveryaddressInclude<ExtArgs> | null
    /**
     * The data needed to create a deliveryaddress.
     */
    data: XOR<deliveryaddressCreateInput, deliveryaddressUncheckedCreateInput>
  }

  /**
   * deliveryaddress createMany
   */
  export type deliveryaddressCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many deliveryaddresses.
     */
    data: deliveryaddressCreateManyInput | deliveryaddressCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * deliveryaddress createManyAndReturn
   */
  export type deliveryaddressCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the deliveryaddress
     */
    select?: deliveryaddressSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the deliveryaddress
     */
    omit?: deliveryaddressOmit<ExtArgs> | null
    /**
     * The data used to create many deliveryaddresses.
     */
    data: deliveryaddressCreateManyInput | deliveryaddressCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: deliveryaddressIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * deliveryaddress update
   */
  export type deliveryaddressUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the deliveryaddress
     */
    select?: deliveryaddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the deliveryaddress
     */
    omit?: deliveryaddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: deliveryaddressInclude<ExtArgs> | null
    /**
     * The data needed to update a deliveryaddress.
     */
    data: XOR<deliveryaddressUpdateInput, deliveryaddressUncheckedUpdateInput>
    /**
     * Choose, which deliveryaddress to update.
     */
    where: deliveryaddressWhereUniqueInput
  }

  /**
   * deliveryaddress updateMany
   */
  export type deliveryaddressUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update deliveryaddresses.
     */
    data: XOR<deliveryaddressUpdateManyMutationInput, deliveryaddressUncheckedUpdateManyInput>
    /**
     * Filter which deliveryaddresses to update
     */
    where?: deliveryaddressWhereInput
    /**
     * Limit how many deliveryaddresses to update.
     */
    limit?: number
  }

  /**
   * deliveryaddress updateManyAndReturn
   */
  export type deliveryaddressUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the deliveryaddress
     */
    select?: deliveryaddressSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the deliveryaddress
     */
    omit?: deliveryaddressOmit<ExtArgs> | null
    /**
     * The data used to update deliveryaddresses.
     */
    data: XOR<deliveryaddressUpdateManyMutationInput, deliveryaddressUncheckedUpdateManyInput>
    /**
     * Filter which deliveryaddresses to update
     */
    where?: deliveryaddressWhereInput
    /**
     * Limit how many deliveryaddresses to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: deliveryaddressIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * deliveryaddress upsert
   */
  export type deliveryaddressUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the deliveryaddress
     */
    select?: deliveryaddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the deliveryaddress
     */
    omit?: deliveryaddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: deliveryaddressInclude<ExtArgs> | null
    /**
     * The filter to search for the deliveryaddress to update in case it exists.
     */
    where: deliveryaddressWhereUniqueInput
    /**
     * In case the deliveryaddress found by the `where` argument doesn't exist, create a new deliveryaddress with this data.
     */
    create: XOR<deliveryaddressCreateInput, deliveryaddressUncheckedCreateInput>
    /**
     * In case the deliveryaddress was found with the provided `where` argument, update it with this data.
     */
    update: XOR<deliveryaddressUpdateInput, deliveryaddressUncheckedUpdateInput>
  }

  /**
   * deliveryaddress delete
   */
  export type deliveryaddressDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the deliveryaddress
     */
    select?: deliveryaddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the deliveryaddress
     */
    omit?: deliveryaddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: deliveryaddressInclude<ExtArgs> | null
    /**
     * Filter which deliveryaddress to delete.
     */
    where: deliveryaddressWhereUniqueInput
  }

  /**
   * deliveryaddress deleteMany
   */
  export type deliveryaddressDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which deliveryaddresses to delete
     */
    where?: deliveryaddressWhereInput
    /**
     * Limit how many deliveryaddresses to delete.
     */
    limit?: number
  }

  /**
   * deliveryaddress.deliverysale
   */
  export type deliveryaddress$deliverysaleArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the deliverysale
     */
    select?: deliverysaleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the deliverysale
     */
    omit?: deliverysaleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: deliverysaleInclude<ExtArgs> | null
    where?: deliverysaleWhereInput
  }

  /**
   * deliveryaddress without action
   */
  export type deliveryaddressDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the deliveryaddress
     */
    select?: deliveryaddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the deliveryaddress
     */
    omit?: deliveryaddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: deliveryaddressInclude<ExtArgs> | null
  }


  /**
   * Model paymenttype
   */

  export type AggregatePaymenttype = {
    _count: PaymenttypeCountAggregateOutputType | null
    _avg: PaymenttypeAvgAggregateOutputType | null
    _sum: PaymenttypeSumAggregateOutputType | null
    _min: PaymenttypeMinAggregateOutputType | null
    _max: PaymenttypeMaxAggregateOutputType | null
  }

  export type PaymenttypeAvgAggregateOutputType = {
    id: number | null
    brand_id: number | null
  }

  export type PaymenttypeSumAggregateOutputType = {
    id: number | null
    brand_id: number | null
  }

  export type PaymenttypeMinAggregateOutputType = {
    id: number | null
    brand_id: number | null
    description: string | null
  }

  export type PaymenttypeMaxAggregateOutputType = {
    id: number | null
    brand_id: number | null
    description: string | null
  }

  export type PaymenttypeCountAggregateOutputType = {
    id: number
    brand_id: number
    description: number
    _all: number
  }


  export type PaymenttypeAvgAggregateInputType = {
    id?: true
    brand_id?: true
  }

  export type PaymenttypeSumAggregateInputType = {
    id?: true
    brand_id?: true
  }

  export type PaymenttypeMinAggregateInputType = {
    id?: true
    brand_id?: true
    description?: true
  }

  export type PaymenttypeMaxAggregateInputType = {
    id?: true
    brand_id?: true
    description?: true
  }

  export type PaymenttypeCountAggregateInputType = {
    id?: true
    brand_id?: true
    description?: true
    _all?: true
  }

  export type PaymenttypeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which paymenttype to aggregate.
     */
    where?: paymenttypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of paymenttypes to fetch.
     */
    orderBy?: paymenttypeOrderByWithRelationInput | paymenttypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: paymenttypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` paymenttypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` paymenttypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned paymenttypes
    **/
    _count?: true | PaymenttypeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PaymenttypeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PaymenttypeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PaymenttypeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PaymenttypeMaxAggregateInputType
  }

  export type GetPaymenttypeAggregateType<T extends PaymenttypeAggregateArgs> = {
        [P in keyof T & keyof AggregatePaymenttype]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePaymenttype[P]>
      : GetScalarType<T[P], AggregatePaymenttype[P]>
  }




  export type paymenttypeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: paymenttypeWhereInput
    orderBy?: paymenttypeOrderByWithAggregationInput | paymenttypeOrderByWithAggregationInput[]
    by: PaymenttypeScalarFieldEnum[] | PaymenttypeScalarFieldEnum
    having?: paymenttypeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PaymenttypeCountAggregateInputType | true
    _avg?: PaymenttypeAvgAggregateInputType
    _sum?: PaymenttypeSumAggregateInputType
    _min?: PaymenttypeMinAggregateInputType
    _max?: PaymenttypeMaxAggregateInputType
  }

  export type PaymenttypeGroupByOutputType = {
    id: number
    brand_id: number | null
    description: string
    _count: PaymenttypeCountAggregateOutputType | null
    _avg: PaymenttypeAvgAggregateOutputType | null
    _sum: PaymenttypeSumAggregateOutputType | null
    _min: PaymenttypeMinAggregateOutputType | null
    _max: PaymenttypeMaxAggregateOutputType | null
  }

  type GetPaymenttypeGroupByPayload<T extends paymenttypeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PaymenttypeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PaymenttypeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PaymenttypeGroupByOutputType[P]>
            : GetScalarType<T[P], PaymenttypeGroupByOutputType[P]>
        }
      >
    >


  export type paymenttypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    brand_id?: boolean
    description?: boolean
    brand?: boolean | paymenttype$brandArgs<ExtArgs>
    payments?: boolean | paymenttype$paymentsArgs<ExtArgs>
    _count?: boolean | PaymenttypeCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["paymenttype"]>

  export type paymenttypeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    brand_id?: boolean
    description?: boolean
    brand?: boolean | paymenttype$brandArgs<ExtArgs>
  }, ExtArgs["result"]["paymenttype"]>

  export type paymenttypeSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    brand_id?: boolean
    description?: boolean
    brand?: boolean | paymenttype$brandArgs<ExtArgs>
  }, ExtArgs["result"]["paymenttype"]>

  export type paymenttypeSelectScalar = {
    id?: boolean
    brand_id?: boolean
    description?: boolean
  }

  export type paymenttypeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "brand_id" | "description", ExtArgs["result"]["paymenttype"]>
  export type paymenttypeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    brand?: boolean | paymenttype$brandArgs<ExtArgs>
    payments?: boolean | paymenttype$paymentsArgs<ExtArgs>
    _count?: boolean | PaymenttypeCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type paymenttypeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    brand?: boolean | paymenttype$brandArgs<ExtArgs>
  }
  export type paymenttypeIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    brand?: boolean | paymenttype$brandArgs<ExtArgs>
  }

  export type $paymenttypePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "paymenttype"
    objects: {
      brand: Prisma.$brandPayload<ExtArgs> | null
      payments: Prisma.$paymentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      brand_id: number | null
      description: string
    }, ExtArgs["result"]["paymenttype"]>
    composites: {}
  }

  type paymenttypeGetPayload<S extends boolean | null | undefined | paymenttypeDefaultArgs> = $Result.GetResult<Prisma.$paymenttypePayload, S>

  type paymenttypeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<paymenttypeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PaymenttypeCountAggregateInputType | true
    }

  export interface paymenttypeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['paymenttype'], meta: { name: 'paymenttype' } }
    /**
     * Find zero or one Paymenttype that matches the filter.
     * @param {paymenttypeFindUniqueArgs} args - Arguments to find a Paymenttype
     * @example
     * // Get one Paymenttype
     * const paymenttype = await prisma.paymenttype.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends paymenttypeFindUniqueArgs>(args: SelectSubset<T, paymenttypeFindUniqueArgs<ExtArgs>>): Prisma__paymenttypeClient<$Result.GetResult<Prisma.$paymenttypePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Paymenttype that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {paymenttypeFindUniqueOrThrowArgs} args - Arguments to find a Paymenttype
     * @example
     * // Get one Paymenttype
     * const paymenttype = await prisma.paymenttype.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends paymenttypeFindUniqueOrThrowArgs>(args: SelectSubset<T, paymenttypeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__paymenttypeClient<$Result.GetResult<Prisma.$paymenttypePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Paymenttype that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {paymenttypeFindFirstArgs} args - Arguments to find a Paymenttype
     * @example
     * // Get one Paymenttype
     * const paymenttype = await prisma.paymenttype.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends paymenttypeFindFirstArgs>(args?: SelectSubset<T, paymenttypeFindFirstArgs<ExtArgs>>): Prisma__paymenttypeClient<$Result.GetResult<Prisma.$paymenttypePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Paymenttype that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {paymenttypeFindFirstOrThrowArgs} args - Arguments to find a Paymenttype
     * @example
     * // Get one Paymenttype
     * const paymenttype = await prisma.paymenttype.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends paymenttypeFindFirstOrThrowArgs>(args?: SelectSubset<T, paymenttypeFindFirstOrThrowArgs<ExtArgs>>): Prisma__paymenttypeClient<$Result.GetResult<Prisma.$paymenttypePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Paymenttypes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {paymenttypeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Paymenttypes
     * const paymenttypes = await prisma.paymenttype.findMany()
     * 
     * // Get first 10 Paymenttypes
     * const paymenttypes = await prisma.paymenttype.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const paymenttypeWithIdOnly = await prisma.paymenttype.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends paymenttypeFindManyArgs>(args?: SelectSubset<T, paymenttypeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$paymenttypePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Paymenttype.
     * @param {paymenttypeCreateArgs} args - Arguments to create a Paymenttype.
     * @example
     * // Create one Paymenttype
     * const Paymenttype = await prisma.paymenttype.create({
     *   data: {
     *     // ... data to create a Paymenttype
     *   }
     * })
     * 
     */
    create<T extends paymenttypeCreateArgs>(args: SelectSubset<T, paymenttypeCreateArgs<ExtArgs>>): Prisma__paymenttypeClient<$Result.GetResult<Prisma.$paymenttypePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Paymenttypes.
     * @param {paymenttypeCreateManyArgs} args - Arguments to create many Paymenttypes.
     * @example
     * // Create many Paymenttypes
     * const paymenttype = await prisma.paymenttype.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends paymenttypeCreateManyArgs>(args?: SelectSubset<T, paymenttypeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Paymenttypes and returns the data saved in the database.
     * @param {paymenttypeCreateManyAndReturnArgs} args - Arguments to create many Paymenttypes.
     * @example
     * // Create many Paymenttypes
     * const paymenttype = await prisma.paymenttype.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Paymenttypes and only return the `id`
     * const paymenttypeWithIdOnly = await prisma.paymenttype.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends paymenttypeCreateManyAndReturnArgs>(args?: SelectSubset<T, paymenttypeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$paymenttypePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Paymenttype.
     * @param {paymenttypeDeleteArgs} args - Arguments to delete one Paymenttype.
     * @example
     * // Delete one Paymenttype
     * const Paymenttype = await prisma.paymenttype.delete({
     *   where: {
     *     // ... filter to delete one Paymenttype
     *   }
     * })
     * 
     */
    delete<T extends paymenttypeDeleteArgs>(args: SelectSubset<T, paymenttypeDeleteArgs<ExtArgs>>): Prisma__paymenttypeClient<$Result.GetResult<Prisma.$paymenttypePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Paymenttype.
     * @param {paymenttypeUpdateArgs} args - Arguments to update one Paymenttype.
     * @example
     * // Update one Paymenttype
     * const paymenttype = await prisma.paymenttype.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends paymenttypeUpdateArgs>(args: SelectSubset<T, paymenttypeUpdateArgs<ExtArgs>>): Prisma__paymenttypeClient<$Result.GetResult<Prisma.$paymenttypePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Paymenttypes.
     * @param {paymenttypeDeleteManyArgs} args - Arguments to filter Paymenttypes to delete.
     * @example
     * // Delete a few Paymenttypes
     * const { count } = await prisma.paymenttype.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends paymenttypeDeleteManyArgs>(args?: SelectSubset<T, paymenttypeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Paymenttypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {paymenttypeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Paymenttypes
     * const paymenttype = await prisma.paymenttype.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends paymenttypeUpdateManyArgs>(args: SelectSubset<T, paymenttypeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Paymenttypes and returns the data updated in the database.
     * @param {paymenttypeUpdateManyAndReturnArgs} args - Arguments to update many Paymenttypes.
     * @example
     * // Update many Paymenttypes
     * const paymenttype = await prisma.paymenttype.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Paymenttypes and only return the `id`
     * const paymenttypeWithIdOnly = await prisma.paymenttype.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends paymenttypeUpdateManyAndReturnArgs>(args: SelectSubset<T, paymenttypeUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$paymenttypePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Paymenttype.
     * @param {paymenttypeUpsertArgs} args - Arguments to update or create a Paymenttype.
     * @example
     * // Update or create a Paymenttype
     * const paymenttype = await prisma.paymenttype.upsert({
     *   create: {
     *     // ... data to create a Paymenttype
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Paymenttype we want to update
     *   }
     * })
     */
    upsert<T extends paymenttypeUpsertArgs>(args: SelectSubset<T, paymenttypeUpsertArgs<ExtArgs>>): Prisma__paymenttypeClient<$Result.GetResult<Prisma.$paymenttypePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Paymenttypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {paymenttypeCountArgs} args - Arguments to filter Paymenttypes to count.
     * @example
     * // Count the number of Paymenttypes
     * const count = await prisma.paymenttype.count({
     *   where: {
     *     // ... the filter for the Paymenttypes we want to count
     *   }
     * })
    **/
    count<T extends paymenttypeCountArgs>(
      args?: Subset<T, paymenttypeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PaymenttypeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Paymenttype.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymenttypeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PaymenttypeAggregateArgs>(args: Subset<T, PaymenttypeAggregateArgs>): Prisma.PrismaPromise<GetPaymenttypeAggregateType<T>>

    /**
     * Group by Paymenttype.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {paymenttypeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends paymenttypeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: paymenttypeGroupByArgs['orderBy'] }
        : { orderBy?: paymenttypeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, paymenttypeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPaymenttypeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the paymenttype model
   */
  readonly fields: paymenttypeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for paymenttype.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__paymenttypeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    brand<T extends paymenttype$brandArgs<ExtArgs> = {}>(args?: Subset<T, paymenttype$brandArgs<ExtArgs>>): Prisma__brandClient<$Result.GetResult<Prisma.$brandPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    payments<T extends paymenttype$paymentsArgs<ExtArgs> = {}>(args?: Subset<T, paymenttype$paymentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$paymentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the paymenttype model
   */
  interface paymenttypeFieldRefs {
    readonly id: FieldRef<"paymenttype", 'Int'>
    readonly brand_id: FieldRef<"paymenttype", 'Int'>
    readonly description: FieldRef<"paymenttype", 'String'>
  }
    

  // Custom InputTypes
  /**
   * paymenttype findUnique
   */
  export type paymenttypeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the paymenttype
     */
    select?: paymenttypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the paymenttype
     */
    omit?: paymenttypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: paymenttypeInclude<ExtArgs> | null
    /**
     * Filter, which paymenttype to fetch.
     */
    where: paymenttypeWhereUniqueInput
  }

  /**
   * paymenttype findUniqueOrThrow
   */
  export type paymenttypeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the paymenttype
     */
    select?: paymenttypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the paymenttype
     */
    omit?: paymenttypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: paymenttypeInclude<ExtArgs> | null
    /**
     * Filter, which paymenttype to fetch.
     */
    where: paymenttypeWhereUniqueInput
  }

  /**
   * paymenttype findFirst
   */
  export type paymenttypeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the paymenttype
     */
    select?: paymenttypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the paymenttype
     */
    omit?: paymenttypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: paymenttypeInclude<ExtArgs> | null
    /**
     * Filter, which paymenttype to fetch.
     */
    where?: paymenttypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of paymenttypes to fetch.
     */
    orderBy?: paymenttypeOrderByWithRelationInput | paymenttypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for paymenttypes.
     */
    cursor?: paymenttypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` paymenttypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` paymenttypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of paymenttypes.
     */
    distinct?: PaymenttypeScalarFieldEnum | PaymenttypeScalarFieldEnum[]
  }

  /**
   * paymenttype findFirstOrThrow
   */
  export type paymenttypeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the paymenttype
     */
    select?: paymenttypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the paymenttype
     */
    omit?: paymenttypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: paymenttypeInclude<ExtArgs> | null
    /**
     * Filter, which paymenttype to fetch.
     */
    where?: paymenttypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of paymenttypes to fetch.
     */
    orderBy?: paymenttypeOrderByWithRelationInput | paymenttypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for paymenttypes.
     */
    cursor?: paymenttypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` paymenttypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` paymenttypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of paymenttypes.
     */
    distinct?: PaymenttypeScalarFieldEnum | PaymenttypeScalarFieldEnum[]
  }

  /**
   * paymenttype findMany
   */
  export type paymenttypeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the paymenttype
     */
    select?: paymenttypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the paymenttype
     */
    omit?: paymenttypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: paymenttypeInclude<ExtArgs> | null
    /**
     * Filter, which paymenttypes to fetch.
     */
    where?: paymenttypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of paymenttypes to fetch.
     */
    orderBy?: paymenttypeOrderByWithRelationInput | paymenttypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing paymenttypes.
     */
    cursor?: paymenttypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` paymenttypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` paymenttypes.
     */
    skip?: number
    distinct?: PaymenttypeScalarFieldEnum | PaymenttypeScalarFieldEnum[]
  }

  /**
   * paymenttype create
   */
  export type paymenttypeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the paymenttype
     */
    select?: paymenttypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the paymenttype
     */
    omit?: paymenttypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: paymenttypeInclude<ExtArgs> | null
    /**
     * The data needed to create a paymenttype.
     */
    data: XOR<paymenttypeCreateInput, paymenttypeUncheckedCreateInput>
  }

  /**
   * paymenttype createMany
   */
  export type paymenttypeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many paymenttypes.
     */
    data: paymenttypeCreateManyInput | paymenttypeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * paymenttype createManyAndReturn
   */
  export type paymenttypeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the paymenttype
     */
    select?: paymenttypeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the paymenttype
     */
    omit?: paymenttypeOmit<ExtArgs> | null
    /**
     * The data used to create many paymenttypes.
     */
    data: paymenttypeCreateManyInput | paymenttypeCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: paymenttypeIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * paymenttype update
   */
  export type paymenttypeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the paymenttype
     */
    select?: paymenttypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the paymenttype
     */
    omit?: paymenttypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: paymenttypeInclude<ExtArgs> | null
    /**
     * The data needed to update a paymenttype.
     */
    data: XOR<paymenttypeUpdateInput, paymenttypeUncheckedUpdateInput>
    /**
     * Choose, which paymenttype to update.
     */
    where: paymenttypeWhereUniqueInput
  }

  /**
   * paymenttype updateMany
   */
  export type paymenttypeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update paymenttypes.
     */
    data: XOR<paymenttypeUpdateManyMutationInput, paymenttypeUncheckedUpdateManyInput>
    /**
     * Filter which paymenttypes to update
     */
    where?: paymenttypeWhereInput
    /**
     * Limit how many paymenttypes to update.
     */
    limit?: number
  }

  /**
   * paymenttype updateManyAndReturn
   */
  export type paymenttypeUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the paymenttype
     */
    select?: paymenttypeSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the paymenttype
     */
    omit?: paymenttypeOmit<ExtArgs> | null
    /**
     * The data used to update paymenttypes.
     */
    data: XOR<paymenttypeUpdateManyMutationInput, paymenttypeUncheckedUpdateManyInput>
    /**
     * Filter which paymenttypes to update
     */
    where?: paymenttypeWhereInput
    /**
     * Limit how many paymenttypes to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: paymenttypeIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * paymenttype upsert
   */
  export type paymenttypeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the paymenttype
     */
    select?: paymenttypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the paymenttype
     */
    omit?: paymenttypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: paymenttypeInclude<ExtArgs> | null
    /**
     * The filter to search for the paymenttype to update in case it exists.
     */
    where: paymenttypeWhereUniqueInput
    /**
     * In case the paymenttype found by the `where` argument doesn't exist, create a new paymenttype with this data.
     */
    create: XOR<paymenttypeCreateInput, paymenttypeUncheckedCreateInput>
    /**
     * In case the paymenttype was found with the provided `where` argument, update it with this data.
     */
    update: XOR<paymenttypeUpdateInput, paymenttypeUncheckedUpdateInput>
  }

  /**
   * paymenttype delete
   */
  export type paymenttypeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the paymenttype
     */
    select?: paymenttypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the paymenttype
     */
    omit?: paymenttypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: paymenttypeInclude<ExtArgs> | null
    /**
     * Filter which paymenttype to delete.
     */
    where: paymenttypeWhereUniqueInput
  }

  /**
   * paymenttype deleteMany
   */
  export type paymenttypeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which paymenttypes to delete
     */
    where?: paymenttypeWhereInput
    /**
     * Limit how many paymenttypes to delete.
     */
    limit?: number
  }

  /**
   * paymenttype.brand
   */
  export type paymenttype$brandArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the brand
     */
    select?: brandSelect<ExtArgs> | null
    /**
     * Omit specific fields from the brand
     */
    omit?: brandOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: brandInclude<ExtArgs> | null
    where?: brandWhereInput
  }

  /**
   * paymenttype.payments
   */
  export type paymenttype$paymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payment
     */
    select?: paymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payment
     */
    omit?: paymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: paymentInclude<ExtArgs> | null
    where?: paymentWhereInput
    orderBy?: paymentOrderByWithRelationInput | paymentOrderByWithRelationInput[]
    cursor?: paymentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * paymenttype without action
   */
  export type paymenttypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the paymenttype
     */
    select?: paymenttypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the paymenttype
     */
    omit?: paymenttypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: paymenttypeInclude<ExtArgs> | null
  }


  /**
   * Model payment
   */

  export type AggregatePayment = {
    _count: PaymentCountAggregateOutputType | null
    _avg: PaymentAvgAggregateOutputType | null
    _sum: PaymentSumAggregateOutputType | null
    _min: PaymentMinAggregateOutputType | null
    _max: PaymentMaxAggregateOutputType | null
  }

  export type PaymentAvgAggregateOutputType = {
    id: number | null
    sale_id: number | null
    payment_type_id: number | null
    value: Decimal | null
  }

  export type PaymentSumAggregateOutputType = {
    id: number | null
    sale_id: number | null
    payment_type_id: number | null
    value: Decimal | null
  }

  export type PaymentMinAggregateOutputType = {
    id: number | null
    sale_id: number | null
    payment_type_id: number | null
    value: Decimal | null
    is_online: boolean | null
    description: string | null
    currency: string | null
  }

  export type PaymentMaxAggregateOutputType = {
    id: number | null
    sale_id: number | null
    payment_type_id: number | null
    value: Decimal | null
    is_online: boolean | null
    description: string | null
    currency: string | null
  }

  export type PaymentCountAggregateOutputType = {
    id: number
    sale_id: number
    payment_type_id: number
    value: number
    is_online: number
    description: number
    currency: number
    _all: number
  }


  export type PaymentAvgAggregateInputType = {
    id?: true
    sale_id?: true
    payment_type_id?: true
    value?: true
  }

  export type PaymentSumAggregateInputType = {
    id?: true
    sale_id?: true
    payment_type_id?: true
    value?: true
  }

  export type PaymentMinAggregateInputType = {
    id?: true
    sale_id?: true
    payment_type_id?: true
    value?: true
    is_online?: true
    description?: true
    currency?: true
  }

  export type PaymentMaxAggregateInputType = {
    id?: true
    sale_id?: true
    payment_type_id?: true
    value?: true
    is_online?: true
    description?: true
    currency?: true
  }

  export type PaymentCountAggregateInputType = {
    id?: true
    sale_id?: true
    payment_type_id?: true
    value?: true
    is_online?: true
    description?: true
    currency?: true
    _all?: true
  }

  export type PaymentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which payment to aggregate.
     */
    where?: paymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of payments to fetch.
     */
    orderBy?: paymentOrderByWithRelationInput | paymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: paymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned payments
    **/
    _count?: true | PaymentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PaymentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PaymentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PaymentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PaymentMaxAggregateInputType
  }

  export type GetPaymentAggregateType<T extends PaymentAggregateArgs> = {
        [P in keyof T & keyof AggregatePayment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePayment[P]>
      : GetScalarType<T[P], AggregatePayment[P]>
  }




  export type paymentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: paymentWhereInput
    orderBy?: paymentOrderByWithAggregationInput | paymentOrderByWithAggregationInput[]
    by: PaymentScalarFieldEnum[] | PaymentScalarFieldEnum
    having?: paymentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PaymentCountAggregateInputType | true
    _avg?: PaymentAvgAggregateInputType
    _sum?: PaymentSumAggregateInputType
    _min?: PaymentMinAggregateInputType
    _max?: PaymentMaxAggregateInputType
  }

  export type PaymentGroupByOutputType = {
    id: number
    sale_id: number
    payment_type_id: number | null
    value: Decimal
    is_online: boolean | null
    description: string | null
    currency: string | null
    _count: PaymentCountAggregateOutputType | null
    _avg: PaymentAvgAggregateOutputType | null
    _sum: PaymentSumAggregateOutputType | null
    _min: PaymentMinAggregateOutputType | null
    _max: PaymentMaxAggregateOutputType | null
  }

  type GetPaymentGroupByPayload<T extends paymentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PaymentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PaymentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PaymentGroupByOutputType[P]>
            : GetScalarType<T[P], PaymentGroupByOutputType[P]>
        }
      >
    >


  export type paymentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sale_id?: boolean
    payment_type_id?: boolean
    value?: boolean
    is_online?: boolean
    description?: boolean
    currency?: boolean
    sale?: boolean | saleDefaultArgs<ExtArgs>
    paymenttype?: boolean | payment$paymenttypeArgs<ExtArgs>
  }, ExtArgs["result"]["payment"]>

  export type paymentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sale_id?: boolean
    payment_type_id?: boolean
    value?: boolean
    is_online?: boolean
    description?: boolean
    currency?: boolean
    sale?: boolean | saleDefaultArgs<ExtArgs>
    paymenttype?: boolean | payment$paymenttypeArgs<ExtArgs>
  }, ExtArgs["result"]["payment"]>

  export type paymentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sale_id?: boolean
    payment_type_id?: boolean
    value?: boolean
    is_online?: boolean
    description?: boolean
    currency?: boolean
    sale?: boolean | saleDefaultArgs<ExtArgs>
    paymenttype?: boolean | payment$paymenttypeArgs<ExtArgs>
  }, ExtArgs["result"]["payment"]>

  export type paymentSelectScalar = {
    id?: boolean
    sale_id?: boolean
    payment_type_id?: boolean
    value?: boolean
    is_online?: boolean
    description?: boolean
    currency?: boolean
  }

  export type paymentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "sale_id" | "payment_type_id" | "value" | "is_online" | "description" | "currency", ExtArgs["result"]["payment"]>
  export type paymentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sale?: boolean | saleDefaultArgs<ExtArgs>
    paymenttype?: boolean | payment$paymenttypeArgs<ExtArgs>
  }
  export type paymentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sale?: boolean | saleDefaultArgs<ExtArgs>
    paymenttype?: boolean | payment$paymenttypeArgs<ExtArgs>
  }
  export type paymentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sale?: boolean | saleDefaultArgs<ExtArgs>
    paymenttype?: boolean | payment$paymenttypeArgs<ExtArgs>
  }

  export type $paymentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "payment"
    objects: {
      sale: Prisma.$salePayload<ExtArgs>
      paymenttype: Prisma.$paymenttypePayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      sale_id: number
      payment_type_id: number | null
      value: Prisma.Decimal
      is_online: boolean | null
      description: string | null
      currency: string | null
    }, ExtArgs["result"]["payment"]>
    composites: {}
  }

  type paymentGetPayload<S extends boolean | null | undefined | paymentDefaultArgs> = $Result.GetResult<Prisma.$paymentPayload, S>

  type paymentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<paymentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PaymentCountAggregateInputType | true
    }

  export interface paymentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['payment'], meta: { name: 'payment' } }
    /**
     * Find zero or one Payment that matches the filter.
     * @param {paymentFindUniqueArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends paymentFindUniqueArgs>(args: SelectSubset<T, paymentFindUniqueArgs<ExtArgs>>): Prisma__paymentClient<$Result.GetResult<Prisma.$paymentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Payment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {paymentFindUniqueOrThrowArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends paymentFindUniqueOrThrowArgs>(args: SelectSubset<T, paymentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__paymentClient<$Result.GetResult<Prisma.$paymentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Payment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {paymentFindFirstArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends paymentFindFirstArgs>(args?: SelectSubset<T, paymentFindFirstArgs<ExtArgs>>): Prisma__paymentClient<$Result.GetResult<Prisma.$paymentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Payment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {paymentFindFirstOrThrowArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends paymentFindFirstOrThrowArgs>(args?: SelectSubset<T, paymentFindFirstOrThrowArgs<ExtArgs>>): Prisma__paymentClient<$Result.GetResult<Prisma.$paymentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Payments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {paymentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Payments
     * const payments = await prisma.payment.findMany()
     * 
     * // Get first 10 Payments
     * const payments = await prisma.payment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const paymentWithIdOnly = await prisma.payment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends paymentFindManyArgs>(args?: SelectSubset<T, paymentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$paymentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Payment.
     * @param {paymentCreateArgs} args - Arguments to create a Payment.
     * @example
     * // Create one Payment
     * const Payment = await prisma.payment.create({
     *   data: {
     *     // ... data to create a Payment
     *   }
     * })
     * 
     */
    create<T extends paymentCreateArgs>(args: SelectSubset<T, paymentCreateArgs<ExtArgs>>): Prisma__paymentClient<$Result.GetResult<Prisma.$paymentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Payments.
     * @param {paymentCreateManyArgs} args - Arguments to create many Payments.
     * @example
     * // Create many Payments
     * const payment = await prisma.payment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends paymentCreateManyArgs>(args?: SelectSubset<T, paymentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Payments and returns the data saved in the database.
     * @param {paymentCreateManyAndReturnArgs} args - Arguments to create many Payments.
     * @example
     * // Create many Payments
     * const payment = await prisma.payment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Payments and only return the `id`
     * const paymentWithIdOnly = await prisma.payment.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends paymentCreateManyAndReturnArgs>(args?: SelectSubset<T, paymentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$paymentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Payment.
     * @param {paymentDeleteArgs} args - Arguments to delete one Payment.
     * @example
     * // Delete one Payment
     * const Payment = await prisma.payment.delete({
     *   where: {
     *     // ... filter to delete one Payment
     *   }
     * })
     * 
     */
    delete<T extends paymentDeleteArgs>(args: SelectSubset<T, paymentDeleteArgs<ExtArgs>>): Prisma__paymentClient<$Result.GetResult<Prisma.$paymentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Payment.
     * @param {paymentUpdateArgs} args - Arguments to update one Payment.
     * @example
     * // Update one Payment
     * const payment = await prisma.payment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends paymentUpdateArgs>(args: SelectSubset<T, paymentUpdateArgs<ExtArgs>>): Prisma__paymentClient<$Result.GetResult<Prisma.$paymentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Payments.
     * @param {paymentDeleteManyArgs} args - Arguments to filter Payments to delete.
     * @example
     * // Delete a few Payments
     * const { count } = await prisma.payment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends paymentDeleteManyArgs>(args?: SelectSubset<T, paymentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Payments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {paymentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Payments
     * const payment = await prisma.payment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends paymentUpdateManyArgs>(args: SelectSubset<T, paymentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Payments and returns the data updated in the database.
     * @param {paymentUpdateManyAndReturnArgs} args - Arguments to update many Payments.
     * @example
     * // Update many Payments
     * const payment = await prisma.payment.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Payments and only return the `id`
     * const paymentWithIdOnly = await prisma.payment.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends paymentUpdateManyAndReturnArgs>(args: SelectSubset<T, paymentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$paymentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Payment.
     * @param {paymentUpsertArgs} args - Arguments to update or create a Payment.
     * @example
     * // Update or create a Payment
     * const payment = await prisma.payment.upsert({
     *   create: {
     *     // ... data to create a Payment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Payment we want to update
     *   }
     * })
     */
    upsert<T extends paymentUpsertArgs>(args: SelectSubset<T, paymentUpsertArgs<ExtArgs>>): Prisma__paymentClient<$Result.GetResult<Prisma.$paymentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Payments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {paymentCountArgs} args - Arguments to filter Payments to count.
     * @example
     * // Count the number of Payments
     * const count = await prisma.payment.count({
     *   where: {
     *     // ... the filter for the Payments we want to count
     *   }
     * })
    **/
    count<T extends paymentCountArgs>(
      args?: Subset<T, paymentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PaymentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Payment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PaymentAggregateArgs>(args: Subset<T, PaymentAggregateArgs>): Prisma.PrismaPromise<GetPaymentAggregateType<T>>

    /**
     * Group by Payment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {paymentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends paymentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: paymentGroupByArgs['orderBy'] }
        : { orderBy?: paymentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, paymentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPaymentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the payment model
   */
  readonly fields: paymentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for payment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__paymentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    sale<T extends saleDefaultArgs<ExtArgs> = {}>(args?: Subset<T, saleDefaultArgs<ExtArgs>>): Prisma__saleClient<$Result.GetResult<Prisma.$salePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    paymenttype<T extends payment$paymenttypeArgs<ExtArgs> = {}>(args?: Subset<T, payment$paymenttypeArgs<ExtArgs>>): Prisma__paymenttypeClient<$Result.GetResult<Prisma.$paymenttypePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the payment model
   */
  interface paymentFieldRefs {
    readonly id: FieldRef<"payment", 'Int'>
    readonly sale_id: FieldRef<"payment", 'Int'>
    readonly payment_type_id: FieldRef<"payment", 'Int'>
    readonly value: FieldRef<"payment", 'Decimal'>
    readonly is_online: FieldRef<"payment", 'Boolean'>
    readonly description: FieldRef<"payment", 'String'>
    readonly currency: FieldRef<"payment", 'String'>
  }
    

  // Custom InputTypes
  /**
   * payment findUnique
   */
  export type paymentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payment
     */
    select?: paymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payment
     */
    omit?: paymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: paymentInclude<ExtArgs> | null
    /**
     * Filter, which payment to fetch.
     */
    where: paymentWhereUniqueInput
  }

  /**
   * payment findUniqueOrThrow
   */
  export type paymentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payment
     */
    select?: paymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payment
     */
    omit?: paymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: paymentInclude<ExtArgs> | null
    /**
     * Filter, which payment to fetch.
     */
    where: paymentWhereUniqueInput
  }

  /**
   * payment findFirst
   */
  export type paymentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payment
     */
    select?: paymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payment
     */
    omit?: paymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: paymentInclude<ExtArgs> | null
    /**
     * Filter, which payment to fetch.
     */
    where?: paymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of payments to fetch.
     */
    orderBy?: paymentOrderByWithRelationInput | paymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for payments.
     */
    cursor?: paymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of payments.
     */
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * payment findFirstOrThrow
   */
  export type paymentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payment
     */
    select?: paymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payment
     */
    omit?: paymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: paymentInclude<ExtArgs> | null
    /**
     * Filter, which payment to fetch.
     */
    where?: paymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of payments to fetch.
     */
    orderBy?: paymentOrderByWithRelationInput | paymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for payments.
     */
    cursor?: paymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of payments.
     */
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * payment findMany
   */
  export type paymentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payment
     */
    select?: paymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payment
     */
    omit?: paymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: paymentInclude<ExtArgs> | null
    /**
     * Filter, which payments to fetch.
     */
    where?: paymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of payments to fetch.
     */
    orderBy?: paymentOrderByWithRelationInput | paymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing payments.
     */
    cursor?: paymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` payments.
     */
    skip?: number
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * payment create
   */
  export type paymentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payment
     */
    select?: paymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payment
     */
    omit?: paymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: paymentInclude<ExtArgs> | null
    /**
     * The data needed to create a payment.
     */
    data: XOR<paymentCreateInput, paymentUncheckedCreateInput>
  }

  /**
   * payment createMany
   */
  export type paymentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many payments.
     */
    data: paymentCreateManyInput | paymentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * payment createManyAndReturn
   */
  export type paymentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payment
     */
    select?: paymentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the payment
     */
    omit?: paymentOmit<ExtArgs> | null
    /**
     * The data used to create many payments.
     */
    data: paymentCreateManyInput | paymentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: paymentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * payment update
   */
  export type paymentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payment
     */
    select?: paymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payment
     */
    omit?: paymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: paymentInclude<ExtArgs> | null
    /**
     * The data needed to update a payment.
     */
    data: XOR<paymentUpdateInput, paymentUncheckedUpdateInput>
    /**
     * Choose, which payment to update.
     */
    where: paymentWhereUniqueInput
  }

  /**
   * payment updateMany
   */
  export type paymentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update payments.
     */
    data: XOR<paymentUpdateManyMutationInput, paymentUncheckedUpdateManyInput>
    /**
     * Filter which payments to update
     */
    where?: paymentWhereInput
    /**
     * Limit how many payments to update.
     */
    limit?: number
  }

  /**
   * payment updateManyAndReturn
   */
  export type paymentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payment
     */
    select?: paymentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the payment
     */
    omit?: paymentOmit<ExtArgs> | null
    /**
     * The data used to update payments.
     */
    data: XOR<paymentUpdateManyMutationInput, paymentUncheckedUpdateManyInput>
    /**
     * Filter which payments to update
     */
    where?: paymentWhereInput
    /**
     * Limit how many payments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: paymentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * payment upsert
   */
  export type paymentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payment
     */
    select?: paymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payment
     */
    omit?: paymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: paymentInclude<ExtArgs> | null
    /**
     * The filter to search for the payment to update in case it exists.
     */
    where: paymentWhereUniqueInput
    /**
     * In case the payment found by the `where` argument doesn't exist, create a new payment with this data.
     */
    create: XOR<paymentCreateInput, paymentUncheckedCreateInput>
    /**
     * In case the payment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<paymentUpdateInput, paymentUncheckedUpdateInput>
  }

  /**
   * payment delete
   */
  export type paymentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payment
     */
    select?: paymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payment
     */
    omit?: paymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: paymentInclude<ExtArgs> | null
    /**
     * Filter which payment to delete.
     */
    where: paymentWhereUniqueInput
  }

  /**
   * payment deleteMany
   */
  export type paymentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which payments to delete
     */
    where?: paymentWhereInput
    /**
     * Limit how many payments to delete.
     */
    limit?: number
  }

  /**
   * payment.paymenttype
   */
  export type payment$paymenttypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the paymenttype
     */
    select?: paymenttypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the paymenttype
     */
    omit?: paymenttypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: paymenttypeInclude<ExtArgs> | null
    where?: paymenttypeWhereInput
  }

  /**
   * payment without action
   */
  export type paymentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payment
     */
    select?: paymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payment
     */
    omit?: paymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: paymentInclude<ExtArgs> | null
  }


  /**
   * Model coupon
   */

  export type AggregateCoupon = {
    _count: CouponCountAggregateOutputType | null
    _avg: CouponAvgAggregateOutputType | null
    _sum: CouponSumAggregateOutputType | null
    _min: CouponMinAggregateOutputType | null
    _max: CouponMaxAggregateOutputType | null
  }

  export type CouponAvgAggregateOutputType = {
    id: number | null
    brand_id: number | null
    discount_value: Decimal | null
  }

  export type CouponSumAggregateOutputType = {
    id: number | null
    brand_id: number | null
    discount_value: Decimal | null
  }

  export type CouponMinAggregateOutputType = {
    id: number | null
    brand_id: number | null
    code: string | null
    discount_type: string | null
    discount_value: Decimal | null
    is_active: boolean | null
    valid_from: Date | null
    valid_until: Date | null
  }

  export type CouponMaxAggregateOutputType = {
    id: number | null
    brand_id: number | null
    code: string | null
    discount_type: string | null
    discount_value: Decimal | null
    is_active: boolean | null
    valid_from: Date | null
    valid_until: Date | null
  }

  export type CouponCountAggregateOutputType = {
    id: number
    brand_id: number
    code: number
    discount_type: number
    discount_value: number
    is_active: number
    valid_from: number
    valid_until: number
    _all: number
  }


  export type CouponAvgAggregateInputType = {
    id?: true
    brand_id?: true
    discount_value?: true
  }

  export type CouponSumAggregateInputType = {
    id?: true
    brand_id?: true
    discount_value?: true
  }

  export type CouponMinAggregateInputType = {
    id?: true
    brand_id?: true
    code?: true
    discount_type?: true
    discount_value?: true
    is_active?: true
    valid_from?: true
    valid_until?: true
  }

  export type CouponMaxAggregateInputType = {
    id?: true
    brand_id?: true
    code?: true
    discount_type?: true
    discount_value?: true
    is_active?: true
    valid_from?: true
    valid_until?: true
  }

  export type CouponCountAggregateInputType = {
    id?: true
    brand_id?: true
    code?: true
    discount_type?: true
    discount_value?: true
    is_active?: true
    valid_from?: true
    valid_until?: true
    _all?: true
  }

  export type CouponAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which coupon to aggregate.
     */
    where?: couponWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of coupons to fetch.
     */
    orderBy?: couponOrderByWithRelationInput | couponOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: couponWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` coupons from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` coupons.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned coupons
    **/
    _count?: true | CouponCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CouponAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CouponSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CouponMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CouponMaxAggregateInputType
  }

  export type GetCouponAggregateType<T extends CouponAggregateArgs> = {
        [P in keyof T & keyof AggregateCoupon]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCoupon[P]>
      : GetScalarType<T[P], AggregateCoupon[P]>
  }




  export type couponGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: couponWhereInput
    orderBy?: couponOrderByWithAggregationInput | couponOrderByWithAggregationInput[]
    by: CouponScalarFieldEnum[] | CouponScalarFieldEnum
    having?: couponScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CouponCountAggregateInputType | true
    _avg?: CouponAvgAggregateInputType
    _sum?: CouponSumAggregateInputType
    _min?: CouponMinAggregateInputType
    _max?: CouponMaxAggregateInputType
  }

  export type CouponGroupByOutputType = {
    id: number
    brand_id: number | null
    code: string
    discount_type: string | null
    discount_value: Decimal | null
    is_active: boolean | null
    valid_from: Date | null
    valid_until: Date | null
    _count: CouponCountAggregateOutputType | null
    _avg: CouponAvgAggregateOutputType | null
    _sum: CouponSumAggregateOutputType | null
    _min: CouponMinAggregateOutputType | null
    _max: CouponMaxAggregateOutputType | null
  }

  type GetCouponGroupByPayload<T extends couponGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CouponGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CouponGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CouponGroupByOutputType[P]>
            : GetScalarType<T[P], CouponGroupByOutputType[P]>
        }
      >
    >


  export type couponSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    brand_id?: boolean
    code?: boolean
    discount_type?: boolean
    discount_value?: boolean
    is_active?: boolean
    valid_from?: boolean
    valid_until?: boolean
    brand?: boolean | coupon$brandArgs<ExtArgs>
    couponsales?: boolean | coupon$couponsalesArgs<ExtArgs>
    _count?: boolean | CouponCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["coupon"]>

  export type couponSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    brand_id?: boolean
    code?: boolean
    discount_type?: boolean
    discount_value?: boolean
    is_active?: boolean
    valid_from?: boolean
    valid_until?: boolean
    brand?: boolean | coupon$brandArgs<ExtArgs>
  }, ExtArgs["result"]["coupon"]>

  export type couponSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    brand_id?: boolean
    code?: boolean
    discount_type?: boolean
    discount_value?: boolean
    is_active?: boolean
    valid_from?: boolean
    valid_until?: boolean
    brand?: boolean | coupon$brandArgs<ExtArgs>
  }, ExtArgs["result"]["coupon"]>

  export type couponSelectScalar = {
    id?: boolean
    brand_id?: boolean
    code?: boolean
    discount_type?: boolean
    discount_value?: boolean
    is_active?: boolean
    valid_from?: boolean
    valid_until?: boolean
  }

  export type couponOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "brand_id" | "code" | "discount_type" | "discount_value" | "is_active" | "valid_from" | "valid_until", ExtArgs["result"]["coupon"]>
  export type couponInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    brand?: boolean | coupon$brandArgs<ExtArgs>
    couponsales?: boolean | coupon$couponsalesArgs<ExtArgs>
    _count?: boolean | CouponCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type couponIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    brand?: boolean | coupon$brandArgs<ExtArgs>
  }
  export type couponIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    brand?: boolean | coupon$brandArgs<ExtArgs>
  }

  export type $couponPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "coupon"
    objects: {
      brand: Prisma.$brandPayload<ExtArgs> | null
      couponsales: Prisma.$couponsalePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      brand_id: number | null
      code: string
      discount_type: string | null
      discount_value: Prisma.Decimal | null
      is_active: boolean | null
      valid_from: Date | null
      valid_until: Date | null
    }, ExtArgs["result"]["coupon"]>
    composites: {}
  }

  type couponGetPayload<S extends boolean | null | undefined | couponDefaultArgs> = $Result.GetResult<Prisma.$couponPayload, S>

  type couponCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<couponFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CouponCountAggregateInputType | true
    }

  export interface couponDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['coupon'], meta: { name: 'coupon' } }
    /**
     * Find zero or one Coupon that matches the filter.
     * @param {couponFindUniqueArgs} args - Arguments to find a Coupon
     * @example
     * // Get one Coupon
     * const coupon = await prisma.coupon.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends couponFindUniqueArgs>(args: SelectSubset<T, couponFindUniqueArgs<ExtArgs>>): Prisma__couponClient<$Result.GetResult<Prisma.$couponPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Coupon that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {couponFindUniqueOrThrowArgs} args - Arguments to find a Coupon
     * @example
     * // Get one Coupon
     * const coupon = await prisma.coupon.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends couponFindUniqueOrThrowArgs>(args: SelectSubset<T, couponFindUniqueOrThrowArgs<ExtArgs>>): Prisma__couponClient<$Result.GetResult<Prisma.$couponPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Coupon that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {couponFindFirstArgs} args - Arguments to find a Coupon
     * @example
     * // Get one Coupon
     * const coupon = await prisma.coupon.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends couponFindFirstArgs>(args?: SelectSubset<T, couponFindFirstArgs<ExtArgs>>): Prisma__couponClient<$Result.GetResult<Prisma.$couponPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Coupon that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {couponFindFirstOrThrowArgs} args - Arguments to find a Coupon
     * @example
     * // Get one Coupon
     * const coupon = await prisma.coupon.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends couponFindFirstOrThrowArgs>(args?: SelectSubset<T, couponFindFirstOrThrowArgs<ExtArgs>>): Prisma__couponClient<$Result.GetResult<Prisma.$couponPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Coupons that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {couponFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Coupons
     * const coupons = await prisma.coupon.findMany()
     * 
     * // Get first 10 Coupons
     * const coupons = await prisma.coupon.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const couponWithIdOnly = await prisma.coupon.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends couponFindManyArgs>(args?: SelectSubset<T, couponFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$couponPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Coupon.
     * @param {couponCreateArgs} args - Arguments to create a Coupon.
     * @example
     * // Create one Coupon
     * const Coupon = await prisma.coupon.create({
     *   data: {
     *     // ... data to create a Coupon
     *   }
     * })
     * 
     */
    create<T extends couponCreateArgs>(args: SelectSubset<T, couponCreateArgs<ExtArgs>>): Prisma__couponClient<$Result.GetResult<Prisma.$couponPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Coupons.
     * @param {couponCreateManyArgs} args - Arguments to create many Coupons.
     * @example
     * // Create many Coupons
     * const coupon = await prisma.coupon.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends couponCreateManyArgs>(args?: SelectSubset<T, couponCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Coupons and returns the data saved in the database.
     * @param {couponCreateManyAndReturnArgs} args - Arguments to create many Coupons.
     * @example
     * // Create many Coupons
     * const coupon = await prisma.coupon.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Coupons and only return the `id`
     * const couponWithIdOnly = await prisma.coupon.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends couponCreateManyAndReturnArgs>(args?: SelectSubset<T, couponCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$couponPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Coupon.
     * @param {couponDeleteArgs} args - Arguments to delete one Coupon.
     * @example
     * // Delete one Coupon
     * const Coupon = await prisma.coupon.delete({
     *   where: {
     *     // ... filter to delete one Coupon
     *   }
     * })
     * 
     */
    delete<T extends couponDeleteArgs>(args: SelectSubset<T, couponDeleteArgs<ExtArgs>>): Prisma__couponClient<$Result.GetResult<Prisma.$couponPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Coupon.
     * @param {couponUpdateArgs} args - Arguments to update one Coupon.
     * @example
     * // Update one Coupon
     * const coupon = await prisma.coupon.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends couponUpdateArgs>(args: SelectSubset<T, couponUpdateArgs<ExtArgs>>): Prisma__couponClient<$Result.GetResult<Prisma.$couponPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Coupons.
     * @param {couponDeleteManyArgs} args - Arguments to filter Coupons to delete.
     * @example
     * // Delete a few Coupons
     * const { count } = await prisma.coupon.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends couponDeleteManyArgs>(args?: SelectSubset<T, couponDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Coupons.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {couponUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Coupons
     * const coupon = await prisma.coupon.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends couponUpdateManyArgs>(args: SelectSubset<T, couponUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Coupons and returns the data updated in the database.
     * @param {couponUpdateManyAndReturnArgs} args - Arguments to update many Coupons.
     * @example
     * // Update many Coupons
     * const coupon = await prisma.coupon.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Coupons and only return the `id`
     * const couponWithIdOnly = await prisma.coupon.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends couponUpdateManyAndReturnArgs>(args: SelectSubset<T, couponUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$couponPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Coupon.
     * @param {couponUpsertArgs} args - Arguments to update or create a Coupon.
     * @example
     * // Update or create a Coupon
     * const coupon = await prisma.coupon.upsert({
     *   create: {
     *     // ... data to create a Coupon
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Coupon we want to update
     *   }
     * })
     */
    upsert<T extends couponUpsertArgs>(args: SelectSubset<T, couponUpsertArgs<ExtArgs>>): Prisma__couponClient<$Result.GetResult<Prisma.$couponPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Coupons.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {couponCountArgs} args - Arguments to filter Coupons to count.
     * @example
     * // Count the number of Coupons
     * const count = await prisma.coupon.count({
     *   where: {
     *     // ... the filter for the Coupons we want to count
     *   }
     * })
    **/
    count<T extends couponCountArgs>(
      args?: Subset<T, couponCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CouponCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Coupon.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CouponAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CouponAggregateArgs>(args: Subset<T, CouponAggregateArgs>): Prisma.PrismaPromise<GetCouponAggregateType<T>>

    /**
     * Group by Coupon.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {couponGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends couponGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: couponGroupByArgs['orderBy'] }
        : { orderBy?: couponGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, couponGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCouponGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the coupon model
   */
  readonly fields: couponFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for coupon.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__couponClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    brand<T extends coupon$brandArgs<ExtArgs> = {}>(args?: Subset<T, coupon$brandArgs<ExtArgs>>): Prisma__brandClient<$Result.GetResult<Prisma.$brandPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    couponsales<T extends coupon$couponsalesArgs<ExtArgs> = {}>(args?: Subset<T, coupon$couponsalesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$couponsalePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the coupon model
   */
  interface couponFieldRefs {
    readonly id: FieldRef<"coupon", 'Int'>
    readonly brand_id: FieldRef<"coupon", 'Int'>
    readonly code: FieldRef<"coupon", 'String'>
    readonly discount_type: FieldRef<"coupon", 'String'>
    readonly discount_value: FieldRef<"coupon", 'Decimal'>
    readonly is_active: FieldRef<"coupon", 'Boolean'>
    readonly valid_from: FieldRef<"coupon", 'DateTime'>
    readonly valid_until: FieldRef<"coupon", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * coupon findUnique
   */
  export type couponFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the coupon
     */
    select?: couponSelect<ExtArgs> | null
    /**
     * Omit specific fields from the coupon
     */
    omit?: couponOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: couponInclude<ExtArgs> | null
    /**
     * Filter, which coupon to fetch.
     */
    where: couponWhereUniqueInput
  }

  /**
   * coupon findUniqueOrThrow
   */
  export type couponFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the coupon
     */
    select?: couponSelect<ExtArgs> | null
    /**
     * Omit specific fields from the coupon
     */
    omit?: couponOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: couponInclude<ExtArgs> | null
    /**
     * Filter, which coupon to fetch.
     */
    where: couponWhereUniqueInput
  }

  /**
   * coupon findFirst
   */
  export type couponFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the coupon
     */
    select?: couponSelect<ExtArgs> | null
    /**
     * Omit specific fields from the coupon
     */
    omit?: couponOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: couponInclude<ExtArgs> | null
    /**
     * Filter, which coupon to fetch.
     */
    where?: couponWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of coupons to fetch.
     */
    orderBy?: couponOrderByWithRelationInput | couponOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for coupons.
     */
    cursor?: couponWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` coupons from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` coupons.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of coupons.
     */
    distinct?: CouponScalarFieldEnum | CouponScalarFieldEnum[]
  }

  /**
   * coupon findFirstOrThrow
   */
  export type couponFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the coupon
     */
    select?: couponSelect<ExtArgs> | null
    /**
     * Omit specific fields from the coupon
     */
    omit?: couponOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: couponInclude<ExtArgs> | null
    /**
     * Filter, which coupon to fetch.
     */
    where?: couponWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of coupons to fetch.
     */
    orderBy?: couponOrderByWithRelationInput | couponOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for coupons.
     */
    cursor?: couponWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` coupons from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` coupons.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of coupons.
     */
    distinct?: CouponScalarFieldEnum | CouponScalarFieldEnum[]
  }

  /**
   * coupon findMany
   */
  export type couponFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the coupon
     */
    select?: couponSelect<ExtArgs> | null
    /**
     * Omit specific fields from the coupon
     */
    omit?: couponOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: couponInclude<ExtArgs> | null
    /**
     * Filter, which coupons to fetch.
     */
    where?: couponWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of coupons to fetch.
     */
    orderBy?: couponOrderByWithRelationInput | couponOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing coupons.
     */
    cursor?: couponWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` coupons from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` coupons.
     */
    skip?: number
    distinct?: CouponScalarFieldEnum | CouponScalarFieldEnum[]
  }

  /**
   * coupon create
   */
  export type couponCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the coupon
     */
    select?: couponSelect<ExtArgs> | null
    /**
     * Omit specific fields from the coupon
     */
    omit?: couponOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: couponInclude<ExtArgs> | null
    /**
     * The data needed to create a coupon.
     */
    data: XOR<couponCreateInput, couponUncheckedCreateInput>
  }

  /**
   * coupon createMany
   */
  export type couponCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many coupons.
     */
    data: couponCreateManyInput | couponCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * coupon createManyAndReturn
   */
  export type couponCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the coupon
     */
    select?: couponSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the coupon
     */
    omit?: couponOmit<ExtArgs> | null
    /**
     * The data used to create many coupons.
     */
    data: couponCreateManyInput | couponCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: couponIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * coupon update
   */
  export type couponUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the coupon
     */
    select?: couponSelect<ExtArgs> | null
    /**
     * Omit specific fields from the coupon
     */
    omit?: couponOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: couponInclude<ExtArgs> | null
    /**
     * The data needed to update a coupon.
     */
    data: XOR<couponUpdateInput, couponUncheckedUpdateInput>
    /**
     * Choose, which coupon to update.
     */
    where: couponWhereUniqueInput
  }

  /**
   * coupon updateMany
   */
  export type couponUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update coupons.
     */
    data: XOR<couponUpdateManyMutationInput, couponUncheckedUpdateManyInput>
    /**
     * Filter which coupons to update
     */
    where?: couponWhereInput
    /**
     * Limit how many coupons to update.
     */
    limit?: number
  }

  /**
   * coupon updateManyAndReturn
   */
  export type couponUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the coupon
     */
    select?: couponSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the coupon
     */
    omit?: couponOmit<ExtArgs> | null
    /**
     * The data used to update coupons.
     */
    data: XOR<couponUpdateManyMutationInput, couponUncheckedUpdateManyInput>
    /**
     * Filter which coupons to update
     */
    where?: couponWhereInput
    /**
     * Limit how many coupons to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: couponIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * coupon upsert
   */
  export type couponUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the coupon
     */
    select?: couponSelect<ExtArgs> | null
    /**
     * Omit specific fields from the coupon
     */
    omit?: couponOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: couponInclude<ExtArgs> | null
    /**
     * The filter to search for the coupon to update in case it exists.
     */
    where: couponWhereUniqueInput
    /**
     * In case the coupon found by the `where` argument doesn't exist, create a new coupon with this data.
     */
    create: XOR<couponCreateInput, couponUncheckedCreateInput>
    /**
     * In case the coupon was found with the provided `where` argument, update it with this data.
     */
    update: XOR<couponUpdateInput, couponUncheckedUpdateInput>
  }

  /**
   * coupon delete
   */
  export type couponDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the coupon
     */
    select?: couponSelect<ExtArgs> | null
    /**
     * Omit specific fields from the coupon
     */
    omit?: couponOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: couponInclude<ExtArgs> | null
    /**
     * Filter which coupon to delete.
     */
    where: couponWhereUniqueInput
  }

  /**
   * coupon deleteMany
   */
  export type couponDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which coupons to delete
     */
    where?: couponWhereInput
    /**
     * Limit how many coupons to delete.
     */
    limit?: number
  }

  /**
   * coupon.brand
   */
  export type coupon$brandArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the brand
     */
    select?: brandSelect<ExtArgs> | null
    /**
     * Omit specific fields from the brand
     */
    omit?: brandOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: brandInclude<ExtArgs> | null
    where?: brandWhereInput
  }

  /**
   * coupon.couponsales
   */
  export type coupon$couponsalesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the couponsale
     */
    select?: couponsaleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the couponsale
     */
    omit?: couponsaleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: couponsaleInclude<ExtArgs> | null
    where?: couponsaleWhereInput
    orderBy?: couponsaleOrderByWithRelationInput | couponsaleOrderByWithRelationInput[]
    cursor?: couponsaleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CouponsaleScalarFieldEnum | CouponsaleScalarFieldEnum[]
  }

  /**
   * coupon without action
   */
  export type couponDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the coupon
     */
    select?: couponSelect<ExtArgs> | null
    /**
     * Omit specific fields from the coupon
     */
    omit?: couponOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: couponInclude<ExtArgs> | null
  }


  /**
   * Model couponsale
   */

  export type AggregateCouponsale = {
    _count: CouponsaleCountAggregateOutputType | null
    _avg: CouponsaleAvgAggregateOutputType | null
    _sum: CouponsaleSumAggregateOutputType | null
    _min: CouponsaleMinAggregateOutputType | null
    _max: CouponsaleMaxAggregateOutputType | null
  }

  export type CouponsaleAvgAggregateOutputType = {
    id: number | null
    sale_id: number | null
    coupon_id: number | null
    value: number | null
  }

  export type CouponsaleSumAggregateOutputType = {
    id: number | null
    sale_id: number | null
    coupon_id: number | null
    value: number | null
  }

  export type CouponsaleMinAggregateOutputType = {
    id: number | null
    sale_id: number | null
    coupon_id: number | null
    value: number | null
    target: string | null
    sponsorship: string | null
  }

  export type CouponsaleMaxAggregateOutputType = {
    id: number | null
    sale_id: number | null
    coupon_id: number | null
    value: number | null
    target: string | null
    sponsorship: string | null
  }

  export type CouponsaleCountAggregateOutputType = {
    id: number
    sale_id: number
    coupon_id: number
    value: number
    target: number
    sponsorship: number
    _all: number
  }


  export type CouponsaleAvgAggregateInputType = {
    id?: true
    sale_id?: true
    coupon_id?: true
    value?: true
  }

  export type CouponsaleSumAggregateInputType = {
    id?: true
    sale_id?: true
    coupon_id?: true
    value?: true
  }

  export type CouponsaleMinAggregateInputType = {
    id?: true
    sale_id?: true
    coupon_id?: true
    value?: true
    target?: true
    sponsorship?: true
  }

  export type CouponsaleMaxAggregateInputType = {
    id?: true
    sale_id?: true
    coupon_id?: true
    value?: true
    target?: true
    sponsorship?: true
  }

  export type CouponsaleCountAggregateInputType = {
    id?: true
    sale_id?: true
    coupon_id?: true
    value?: true
    target?: true
    sponsorship?: true
    _all?: true
  }

  export type CouponsaleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which couponsale to aggregate.
     */
    where?: couponsaleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of couponsales to fetch.
     */
    orderBy?: couponsaleOrderByWithRelationInput | couponsaleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: couponsaleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` couponsales from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` couponsales.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned couponsales
    **/
    _count?: true | CouponsaleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CouponsaleAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CouponsaleSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CouponsaleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CouponsaleMaxAggregateInputType
  }

  export type GetCouponsaleAggregateType<T extends CouponsaleAggregateArgs> = {
        [P in keyof T & keyof AggregateCouponsale]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCouponsale[P]>
      : GetScalarType<T[P], AggregateCouponsale[P]>
  }




  export type couponsaleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: couponsaleWhereInput
    orderBy?: couponsaleOrderByWithAggregationInput | couponsaleOrderByWithAggregationInput[]
    by: CouponsaleScalarFieldEnum[] | CouponsaleScalarFieldEnum
    having?: couponsaleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CouponsaleCountAggregateInputType | true
    _avg?: CouponsaleAvgAggregateInputType
    _sum?: CouponsaleSumAggregateInputType
    _min?: CouponsaleMinAggregateInputType
    _max?: CouponsaleMaxAggregateInputType
  }

  export type CouponsaleGroupByOutputType = {
    id: number
    sale_id: number | null
    coupon_id: number | null
    value: number | null
    target: string | null
    sponsorship: string | null
    _count: CouponsaleCountAggregateOutputType | null
    _avg: CouponsaleAvgAggregateOutputType | null
    _sum: CouponsaleSumAggregateOutputType | null
    _min: CouponsaleMinAggregateOutputType | null
    _max: CouponsaleMaxAggregateOutputType | null
  }

  type GetCouponsaleGroupByPayload<T extends couponsaleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CouponsaleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CouponsaleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CouponsaleGroupByOutputType[P]>
            : GetScalarType<T[P], CouponsaleGroupByOutputType[P]>
        }
      >
    >


  export type couponsaleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sale_id?: boolean
    coupon_id?: boolean
    value?: boolean
    target?: boolean
    sponsorship?: boolean
    sale?: boolean | couponsale$saleArgs<ExtArgs>
    coupon?: boolean | couponsale$couponArgs<ExtArgs>
  }, ExtArgs["result"]["couponsale"]>

  export type couponsaleSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sale_id?: boolean
    coupon_id?: boolean
    value?: boolean
    target?: boolean
    sponsorship?: boolean
    sale?: boolean | couponsale$saleArgs<ExtArgs>
    coupon?: boolean | couponsale$couponArgs<ExtArgs>
  }, ExtArgs["result"]["couponsale"]>

  export type couponsaleSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sale_id?: boolean
    coupon_id?: boolean
    value?: boolean
    target?: boolean
    sponsorship?: boolean
    sale?: boolean | couponsale$saleArgs<ExtArgs>
    coupon?: boolean | couponsale$couponArgs<ExtArgs>
  }, ExtArgs["result"]["couponsale"]>

  export type couponsaleSelectScalar = {
    id?: boolean
    sale_id?: boolean
    coupon_id?: boolean
    value?: boolean
    target?: boolean
    sponsorship?: boolean
  }

  export type couponsaleOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "sale_id" | "coupon_id" | "value" | "target" | "sponsorship", ExtArgs["result"]["couponsale"]>
  export type couponsaleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sale?: boolean | couponsale$saleArgs<ExtArgs>
    coupon?: boolean | couponsale$couponArgs<ExtArgs>
  }
  export type couponsaleIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sale?: boolean | couponsale$saleArgs<ExtArgs>
    coupon?: boolean | couponsale$couponArgs<ExtArgs>
  }
  export type couponsaleIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sale?: boolean | couponsale$saleArgs<ExtArgs>
    coupon?: boolean | couponsale$couponArgs<ExtArgs>
  }

  export type $couponsalePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "couponsale"
    objects: {
      sale: Prisma.$salePayload<ExtArgs> | null
      coupon: Prisma.$couponPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      sale_id: number | null
      coupon_id: number | null
      value: number | null
      target: string | null
      sponsorship: string | null
    }, ExtArgs["result"]["couponsale"]>
    composites: {}
  }

  type couponsaleGetPayload<S extends boolean | null | undefined | couponsaleDefaultArgs> = $Result.GetResult<Prisma.$couponsalePayload, S>

  type couponsaleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<couponsaleFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CouponsaleCountAggregateInputType | true
    }

  export interface couponsaleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['couponsale'], meta: { name: 'couponsale' } }
    /**
     * Find zero or one Couponsale that matches the filter.
     * @param {couponsaleFindUniqueArgs} args - Arguments to find a Couponsale
     * @example
     * // Get one Couponsale
     * const couponsale = await prisma.couponsale.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends couponsaleFindUniqueArgs>(args: SelectSubset<T, couponsaleFindUniqueArgs<ExtArgs>>): Prisma__couponsaleClient<$Result.GetResult<Prisma.$couponsalePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Couponsale that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {couponsaleFindUniqueOrThrowArgs} args - Arguments to find a Couponsale
     * @example
     * // Get one Couponsale
     * const couponsale = await prisma.couponsale.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends couponsaleFindUniqueOrThrowArgs>(args: SelectSubset<T, couponsaleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__couponsaleClient<$Result.GetResult<Prisma.$couponsalePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Couponsale that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {couponsaleFindFirstArgs} args - Arguments to find a Couponsale
     * @example
     * // Get one Couponsale
     * const couponsale = await prisma.couponsale.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends couponsaleFindFirstArgs>(args?: SelectSubset<T, couponsaleFindFirstArgs<ExtArgs>>): Prisma__couponsaleClient<$Result.GetResult<Prisma.$couponsalePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Couponsale that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {couponsaleFindFirstOrThrowArgs} args - Arguments to find a Couponsale
     * @example
     * // Get one Couponsale
     * const couponsale = await prisma.couponsale.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends couponsaleFindFirstOrThrowArgs>(args?: SelectSubset<T, couponsaleFindFirstOrThrowArgs<ExtArgs>>): Prisma__couponsaleClient<$Result.GetResult<Prisma.$couponsalePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Couponsales that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {couponsaleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Couponsales
     * const couponsales = await prisma.couponsale.findMany()
     * 
     * // Get first 10 Couponsales
     * const couponsales = await prisma.couponsale.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const couponsaleWithIdOnly = await prisma.couponsale.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends couponsaleFindManyArgs>(args?: SelectSubset<T, couponsaleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$couponsalePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Couponsale.
     * @param {couponsaleCreateArgs} args - Arguments to create a Couponsale.
     * @example
     * // Create one Couponsale
     * const Couponsale = await prisma.couponsale.create({
     *   data: {
     *     // ... data to create a Couponsale
     *   }
     * })
     * 
     */
    create<T extends couponsaleCreateArgs>(args: SelectSubset<T, couponsaleCreateArgs<ExtArgs>>): Prisma__couponsaleClient<$Result.GetResult<Prisma.$couponsalePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Couponsales.
     * @param {couponsaleCreateManyArgs} args - Arguments to create many Couponsales.
     * @example
     * // Create many Couponsales
     * const couponsale = await prisma.couponsale.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends couponsaleCreateManyArgs>(args?: SelectSubset<T, couponsaleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Couponsales and returns the data saved in the database.
     * @param {couponsaleCreateManyAndReturnArgs} args - Arguments to create many Couponsales.
     * @example
     * // Create many Couponsales
     * const couponsale = await prisma.couponsale.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Couponsales and only return the `id`
     * const couponsaleWithIdOnly = await prisma.couponsale.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends couponsaleCreateManyAndReturnArgs>(args?: SelectSubset<T, couponsaleCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$couponsalePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Couponsale.
     * @param {couponsaleDeleteArgs} args - Arguments to delete one Couponsale.
     * @example
     * // Delete one Couponsale
     * const Couponsale = await prisma.couponsale.delete({
     *   where: {
     *     // ... filter to delete one Couponsale
     *   }
     * })
     * 
     */
    delete<T extends couponsaleDeleteArgs>(args: SelectSubset<T, couponsaleDeleteArgs<ExtArgs>>): Prisma__couponsaleClient<$Result.GetResult<Prisma.$couponsalePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Couponsale.
     * @param {couponsaleUpdateArgs} args - Arguments to update one Couponsale.
     * @example
     * // Update one Couponsale
     * const couponsale = await prisma.couponsale.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends couponsaleUpdateArgs>(args: SelectSubset<T, couponsaleUpdateArgs<ExtArgs>>): Prisma__couponsaleClient<$Result.GetResult<Prisma.$couponsalePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Couponsales.
     * @param {couponsaleDeleteManyArgs} args - Arguments to filter Couponsales to delete.
     * @example
     * // Delete a few Couponsales
     * const { count } = await prisma.couponsale.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends couponsaleDeleteManyArgs>(args?: SelectSubset<T, couponsaleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Couponsales.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {couponsaleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Couponsales
     * const couponsale = await prisma.couponsale.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends couponsaleUpdateManyArgs>(args: SelectSubset<T, couponsaleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Couponsales and returns the data updated in the database.
     * @param {couponsaleUpdateManyAndReturnArgs} args - Arguments to update many Couponsales.
     * @example
     * // Update many Couponsales
     * const couponsale = await prisma.couponsale.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Couponsales and only return the `id`
     * const couponsaleWithIdOnly = await prisma.couponsale.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends couponsaleUpdateManyAndReturnArgs>(args: SelectSubset<T, couponsaleUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$couponsalePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Couponsale.
     * @param {couponsaleUpsertArgs} args - Arguments to update or create a Couponsale.
     * @example
     * // Update or create a Couponsale
     * const couponsale = await prisma.couponsale.upsert({
     *   create: {
     *     // ... data to create a Couponsale
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Couponsale we want to update
     *   }
     * })
     */
    upsert<T extends couponsaleUpsertArgs>(args: SelectSubset<T, couponsaleUpsertArgs<ExtArgs>>): Prisma__couponsaleClient<$Result.GetResult<Prisma.$couponsalePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Couponsales.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {couponsaleCountArgs} args - Arguments to filter Couponsales to count.
     * @example
     * // Count the number of Couponsales
     * const count = await prisma.couponsale.count({
     *   where: {
     *     // ... the filter for the Couponsales we want to count
     *   }
     * })
    **/
    count<T extends couponsaleCountArgs>(
      args?: Subset<T, couponsaleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CouponsaleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Couponsale.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CouponsaleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CouponsaleAggregateArgs>(args: Subset<T, CouponsaleAggregateArgs>): Prisma.PrismaPromise<GetCouponsaleAggregateType<T>>

    /**
     * Group by Couponsale.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {couponsaleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends couponsaleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: couponsaleGroupByArgs['orderBy'] }
        : { orderBy?: couponsaleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, couponsaleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCouponsaleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the couponsale model
   */
  readonly fields: couponsaleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for couponsale.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__couponsaleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    sale<T extends couponsale$saleArgs<ExtArgs> = {}>(args?: Subset<T, couponsale$saleArgs<ExtArgs>>): Prisma__saleClient<$Result.GetResult<Prisma.$salePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    coupon<T extends couponsale$couponArgs<ExtArgs> = {}>(args?: Subset<T, couponsale$couponArgs<ExtArgs>>): Prisma__couponClient<$Result.GetResult<Prisma.$couponPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the couponsale model
   */
  interface couponsaleFieldRefs {
    readonly id: FieldRef<"couponsale", 'Int'>
    readonly sale_id: FieldRef<"couponsale", 'Int'>
    readonly coupon_id: FieldRef<"couponsale", 'Int'>
    readonly value: FieldRef<"couponsale", 'Float'>
    readonly target: FieldRef<"couponsale", 'String'>
    readonly sponsorship: FieldRef<"couponsale", 'String'>
  }
    

  // Custom InputTypes
  /**
   * couponsale findUnique
   */
  export type couponsaleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the couponsale
     */
    select?: couponsaleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the couponsale
     */
    omit?: couponsaleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: couponsaleInclude<ExtArgs> | null
    /**
     * Filter, which couponsale to fetch.
     */
    where: couponsaleWhereUniqueInput
  }

  /**
   * couponsale findUniqueOrThrow
   */
  export type couponsaleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the couponsale
     */
    select?: couponsaleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the couponsale
     */
    omit?: couponsaleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: couponsaleInclude<ExtArgs> | null
    /**
     * Filter, which couponsale to fetch.
     */
    where: couponsaleWhereUniqueInput
  }

  /**
   * couponsale findFirst
   */
  export type couponsaleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the couponsale
     */
    select?: couponsaleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the couponsale
     */
    omit?: couponsaleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: couponsaleInclude<ExtArgs> | null
    /**
     * Filter, which couponsale to fetch.
     */
    where?: couponsaleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of couponsales to fetch.
     */
    orderBy?: couponsaleOrderByWithRelationInput | couponsaleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for couponsales.
     */
    cursor?: couponsaleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` couponsales from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` couponsales.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of couponsales.
     */
    distinct?: CouponsaleScalarFieldEnum | CouponsaleScalarFieldEnum[]
  }

  /**
   * couponsale findFirstOrThrow
   */
  export type couponsaleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the couponsale
     */
    select?: couponsaleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the couponsale
     */
    omit?: couponsaleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: couponsaleInclude<ExtArgs> | null
    /**
     * Filter, which couponsale to fetch.
     */
    where?: couponsaleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of couponsales to fetch.
     */
    orderBy?: couponsaleOrderByWithRelationInput | couponsaleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for couponsales.
     */
    cursor?: couponsaleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` couponsales from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` couponsales.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of couponsales.
     */
    distinct?: CouponsaleScalarFieldEnum | CouponsaleScalarFieldEnum[]
  }

  /**
   * couponsale findMany
   */
  export type couponsaleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the couponsale
     */
    select?: couponsaleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the couponsale
     */
    omit?: couponsaleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: couponsaleInclude<ExtArgs> | null
    /**
     * Filter, which couponsales to fetch.
     */
    where?: couponsaleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of couponsales to fetch.
     */
    orderBy?: couponsaleOrderByWithRelationInput | couponsaleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing couponsales.
     */
    cursor?: couponsaleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` couponsales from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` couponsales.
     */
    skip?: number
    distinct?: CouponsaleScalarFieldEnum | CouponsaleScalarFieldEnum[]
  }

  /**
   * couponsale create
   */
  export type couponsaleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the couponsale
     */
    select?: couponsaleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the couponsale
     */
    omit?: couponsaleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: couponsaleInclude<ExtArgs> | null
    /**
     * The data needed to create a couponsale.
     */
    data?: XOR<couponsaleCreateInput, couponsaleUncheckedCreateInput>
  }

  /**
   * couponsale createMany
   */
  export type couponsaleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many couponsales.
     */
    data: couponsaleCreateManyInput | couponsaleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * couponsale createManyAndReturn
   */
  export type couponsaleCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the couponsale
     */
    select?: couponsaleSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the couponsale
     */
    omit?: couponsaleOmit<ExtArgs> | null
    /**
     * The data used to create many couponsales.
     */
    data: couponsaleCreateManyInput | couponsaleCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: couponsaleIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * couponsale update
   */
  export type couponsaleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the couponsale
     */
    select?: couponsaleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the couponsale
     */
    omit?: couponsaleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: couponsaleInclude<ExtArgs> | null
    /**
     * The data needed to update a couponsale.
     */
    data: XOR<couponsaleUpdateInput, couponsaleUncheckedUpdateInput>
    /**
     * Choose, which couponsale to update.
     */
    where: couponsaleWhereUniqueInput
  }

  /**
   * couponsale updateMany
   */
  export type couponsaleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update couponsales.
     */
    data: XOR<couponsaleUpdateManyMutationInput, couponsaleUncheckedUpdateManyInput>
    /**
     * Filter which couponsales to update
     */
    where?: couponsaleWhereInput
    /**
     * Limit how many couponsales to update.
     */
    limit?: number
  }

  /**
   * couponsale updateManyAndReturn
   */
  export type couponsaleUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the couponsale
     */
    select?: couponsaleSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the couponsale
     */
    omit?: couponsaleOmit<ExtArgs> | null
    /**
     * The data used to update couponsales.
     */
    data: XOR<couponsaleUpdateManyMutationInput, couponsaleUncheckedUpdateManyInput>
    /**
     * Filter which couponsales to update
     */
    where?: couponsaleWhereInput
    /**
     * Limit how many couponsales to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: couponsaleIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * couponsale upsert
   */
  export type couponsaleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the couponsale
     */
    select?: couponsaleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the couponsale
     */
    omit?: couponsaleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: couponsaleInclude<ExtArgs> | null
    /**
     * The filter to search for the couponsale to update in case it exists.
     */
    where: couponsaleWhereUniqueInput
    /**
     * In case the couponsale found by the `where` argument doesn't exist, create a new couponsale with this data.
     */
    create: XOR<couponsaleCreateInput, couponsaleUncheckedCreateInput>
    /**
     * In case the couponsale was found with the provided `where` argument, update it with this data.
     */
    update: XOR<couponsaleUpdateInput, couponsaleUncheckedUpdateInput>
  }

  /**
   * couponsale delete
   */
  export type couponsaleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the couponsale
     */
    select?: couponsaleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the couponsale
     */
    omit?: couponsaleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: couponsaleInclude<ExtArgs> | null
    /**
     * Filter which couponsale to delete.
     */
    where: couponsaleWhereUniqueInput
  }

  /**
   * couponsale deleteMany
   */
  export type couponsaleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which couponsales to delete
     */
    where?: couponsaleWhereInput
    /**
     * Limit how many couponsales to delete.
     */
    limit?: number
  }

  /**
   * couponsale.sale
   */
  export type couponsale$saleArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sale
     */
    select?: saleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sale
     */
    omit?: saleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: saleInclude<ExtArgs> | null
    where?: saleWhereInput
  }

  /**
   * couponsale.coupon
   */
  export type couponsale$couponArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the coupon
     */
    select?: couponSelect<ExtArgs> | null
    /**
     * Omit specific fields from the coupon
     */
    omit?: couponOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: couponInclude<ExtArgs> | null
    where?: couponWhereInput
  }

  /**
   * couponsale without action
   */
  export type couponsaleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the couponsale
     */
    select?: couponsaleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the couponsale
     */
    omit?: couponsaleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: couponsaleInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const BrandScalarFieldEnum: {
    id: 'id',
    name: 'name',
    created_at: 'created_at'
  };

  export type BrandScalarFieldEnum = (typeof BrandScalarFieldEnum)[keyof typeof BrandScalarFieldEnum]


  export const SubbrandScalarFieldEnum: {
    id: 'id',
    brand_id: 'brand_id',
    name: 'name',
    created_at: 'created_at'
  };

  export type SubbrandScalarFieldEnum = (typeof SubbrandScalarFieldEnum)[keyof typeof SubbrandScalarFieldEnum]


  export const StoreScalarFieldEnum: {
    id: 'id',
    brand_id: 'brand_id',
    sub_brand_id: 'sub_brand_id',
    name: 'name',
    city: 'city',
    state: 'state',
    district: 'district',
    address_street: 'address_street',
    address_number: 'address_number',
    zipcode: 'zipcode',
    latitude: 'latitude',
    longitude: 'longitude',
    is_active: 'is_active',
    is_own: 'is_own',
    is_holding: 'is_holding',
    creation_date: 'creation_date',
    created_at: 'created_at'
  };

  export type StoreScalarFieldEnum = (typeof StoreScalarFieldEnum)[keyof typeof StoreScalarFieldEnum]


  export const ChannelScalarFieldEnum: {
    id: 'id',
    brand_id: 'brand_id',
    name: 'name',
    description: 'description',
    type: 'type',
    created_at: 'created_at'
  };

  export type ChannelScalarFieldEnum = (typeof ChannelScalarFieldEnum)[keyof typeof ChannelScalarFieldEnum]


  export const CategoryScalarFieldEnum: {
    id: 'id',
    brand_id: 'brand_id',
    sub_brand_id: 'sub_brand_id',
    name: 'name',
    type: 'type',
    pos_uuid: 'pos_uuid',
    deleted_at: 'deleted_at'
  };

  export type CategoryScalarFieldEnum = (typeof CategoryScalarFieldEnum)[keyof typeof CategoryScalarFieldEnum]


  export const ProductScalarFieldEnum: {
    id: 'id',
    brand_id: 'brand_id',
    sub_brand_id: 'sub_brand_id',
    category_id: 'category_id',
    name: 'name',
    pos_uuid: 'pos_uuid',
    deleted_at: 'deleted_at'
  };

  export type ProductScalarFieldEnum = (typeof ProductScalarFieldEnum)[keyof typeof ProductScalarFieldEnum]


  export const OptiongroupScalarFieldEnum: {
    id: 'id',
    brand_id: 'brand_id',
    sub_brand_id: 'sub_brand_id',
    category_id: 'category_id',
    name: 'name',
    pos_uuid: 'pos_uuid',
    deleted_at: 'deleted_at'
  };

  export type OptiongroupScalarFieldEnum = (typeof OptiongroupScalarFieldEnum)[keyof typeof OptiongroupScalarFieldEnum]


  export const ItemScalarFieldEnum: {
    id: 'id',
    brand_id: 'brand_id',
    sub_brand_id: 'sub_brand_id',
    category_id: 'category_id',
    name: 'name',
    pos_uuid: 'pos_uuid',
    deleted_at: 'deleted_at'
  };

  export type ItemScalarFieldEnum = (typeof ItemScalarFieldEnum)[keyof typeof ItemScalarFieldEnum]


  export const CustomerScalarFieldEnum: {
    id: 'id',
    customer_name: 'customer_name',
    email: 'email',
    phone_number: 'phone_number',
    cpf: 'cpf',
    birth_date: 'birth_date',
    gender: 'gender',
    store_id: 'store_id',
    sub_brand_id: 'sub_brand_id',
    registration_origin: 'registration_origin',
    agree_terms: 'agree_terms',
    receive_promotions_email: 'receive_promotions_email',
    receive_promotions_sms: 'receive_promotions_sms',
    created_at: 'created_at'
  };

  export type CustomerScalarFieldEnum = (typeof CustomerScalarFieldEnum)[keyof typeof CustomerScalarFieldEnum]


  export const SaleScalarFieldEnum: {
    id: 'id',
    store_id: 'store_id',
    sub_brand_id: 'sub_brand_id',
    customer_id: 'customer_id',
    channel_id: 'channel_id',
    cod_sale1: 'cod_sale1',
    cod_sale2: 'cod_sale2',
    created_at: 'created_at',
    customer_name: 'customer_name',
    sale_status_desc: 'sale_status_desc',
    total_amount_items: 'total_amount_items',
    total_discount: 'total_discount',
    total_increase: 'total_increase',
    delivery_fee: 'delivery_fee',
    service_tax_fee: 'service_tax_fee',
    total_amount: 'total_amount',
    value_paid: 'value_paid',
    production_seconds: 'production_seconds',
    delivery_seconds: 'delivery_seconds',
    people_quantity: 'people_quantity',
    discount_reason: 'discount_reason',
    increase_reason: 'increase_reason',
    origin: 'origin'
  };

  export type SaleScalarFieldEnum = (typeof SaleScalarFieldEnum)[keyof typeof SaleScalarFieldEnum]


  export const ProductsaleScalarFieldEnum: {
    id: 'id',
    sale_id: 'sale_id',
    product_id: 'product_id',
    quantity: 'quantity',
    base_price: 'base_price',
    total_price: 'total_price',
    observations: 'observations'
  };

  export type ProductsaleScalarFieldEnum = (typeof ProductsaleScalarFieldEnum)[keyof typeof ProductsaleScalarFieldEnum]


  export const ItemproductsaleScalarFieldEnum: {
    id: 'id',
    product_sale_id: 'product_sale_id',
    item_id: 'item_id',
    option_group_id: 'option_group_id',
    quantity: 'quantity',
    additional_price: 'additional_price',
    price: 'price',
    amount: 'amount',
    observations: 'observations'
  };

  export type ItemproductsaleScalarFieldEnum = (typeof ItemproductsaleScalarFieldEnum)[keyof typeof ItemproductsaleScalarFieldEnum]


  export const ItemitemproductsaleScalarFieldEnum: {
    id: 'id',
    item_product_sale_id: 'item_product_sale_id',
    item_id: 'item_id',
    option_group_id: 'option_group_id',
    quantity: 'quantity',
    additional_price: 'additional_price',
    price: 'price',
    amount: 'amount'
  };

  export type ItemitemproductsaleScalarFieldEnum = (typeof ItemitemproductsaleScalarFieldEnum)[keyof typeof ItemitemproductsaleScalarFieldEnum]


  export const DeliverysaleScalarFieldEnum: {
    id: 'id',
    sale_id: 'sale_id',
    courier_id: 'courier_id',
    courier_name: 'courier_name',
    courier_phone: 'courier_phone',
    courier_type: 'courier_type',
    delivered_by: 'delivered_by',
    delivery_type: 'delivery_type',
    status: 'status',
    delivery_fee: 'delivery_fee',
    courier_fee: 'courier_fee',
    timing: 'timing',
    mode: 'mode'
  };

  export type DeliverysaleScalarFieldEnum = (typeof DeliverysaleScalarFieldEnum)[keyof typeof DeliverysaleScalarFieldEnum]


  export const DeliveryaddressScalarFieldEnum: {
    id: 'id',
    sale_id: 'sale_id',
    delivery_sale_id: 'delivery_sale_id',
    street: 'street',
    number: 'number',
    complement: 'complement',
    formatted_address: 'formatted_address',
    neighborhood: 'neighborhood',
    city: 'city',
    state: 'state',
    country: 'country',
    postal_code: 'postal_code',
    reference: 'reference',
    latitude: 'latitude',
    longitude: 'longitude'
  };

  export type DeliveryaddressScalarFieldEnum = (typeof DeliveryaddressScalarFieldEnum)[keyof typeof DeliveryaddressScalarFieldEnum]


  export const PaymenttypeScalarFieldEnum: {
    id: 'id',
    brand_id: 'brand_id',
    description: 'description'
  };

  export type PaymenttypeScalarFieldEnum = (typeof PaymenttypeScalarFieldEnum)[keyof typeof PaymenttypeScalarFieldEnum]


  export const PaymentScalarFieldEnum: {
    id: 'id',
    sale_id: 'sale_id',
    payment_type_id: 'payment_type_id',
    value: 'value',
    is_online: 'is_online',
    description: 'description',
    currency: 'currency'
  };

  export type PaymentScalarFieldEnum = (typeof PaymentScalarFieldEnum)[keyof typeof PaymentScalarFieldEnum]


  export const CouponScalarFieldEnum: {
    id: 'id',
    brand_id: 'brand_id',
    code: 'code',
    discount_type: 'discount_type',
    discount_value: 'discount_value',
    is_active: 'is_active',
    valid_from: 'valid_from',
    valid_until: 'valid_until'
  };

  export type CouponScalarFieldEnum = (typeof CouponScalarFieldEnum)[keyof typeof CouponScalarFieldEnum]


  export const CouponsaleScalarFieldEnum: {
    id: 'id',
    sale_id: 'sale_id',
    coupon_id: 'coupon_id',
    value: 'value',
    target: 'target',
    sponsorship: 'sponsorship'
  };

  export type CouponsaleScalarFieldEnum = (typeof CouponsaleScalarFieldEnum)[keyof typeof CouponsaleScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Decimal'
   */
  export type DecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal'>
    


  /**
   * Reference to a field of type 'Decimal[]'
   */
  export type ListDecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    
  /**
   * Deep Input Types
   */


  export type brandWhereInput = {
    AND?: brandWhereInput | brandWhereInput[]
    OR?: brandWhereInput[]
    NOT?: brandWhereInput | brandWhereInput[]
    id?: IntFilter<"brand"> | number
    name?: StringFilter<"brand"> | string
    created_at?: DateTimeNullableFilter<"brand"> | Date | string | null
    subbrands?: SubbrandListRelationFilter
    stores?: StoreListRelationFilter
    channels?: ChannelListRelationFilter
    categories?: CategoryListRelationFilter
    products?: ProductListRelationFilter
    optiongroups?: OptiongroupListRelationFilter
    items?: ItemListRelationFilter
    paymenttypes?: PaymenttypeListRelationFilter
    coupons?: CouponListRelationFilter
  }

  export type brandOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    created_at?: SortOrderInput | SortOrder
    subbrands?: subbrandOrderByRelationAggregateInput
    stores?: storeOrderByRelationAggregateInput
    channels?: channelOrderByRelationAggregateInput
    categories?: categoryOrderByRelationAggregateInput
    products?: productOrderByRelationAggregateInput
    optiongroups?: optiongroupOrderByRelationAggregateInput
    items?: itemOrderByRelationAggregateInput
    paymenttypes?: paymenttypeOrderByRelationAggregateInput
    coupons?: couponOrderByRelationAggregateInput
  }

  export type brandWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: brandWhereInput | brandWhereInput[]
    OR?: brandWhereInput[]
    NOT?: brandWhereInput | brandWhereInput[]
    name?: StringFilter<"brand"> | string
    created_at?: DateTimeNullableFilter<"brand"> | Date | string | null
    subbrands?: SubbrandListRelationFilter
    stores?: StoreListRelationFilter
    channels?: ChannelListRelationFilter
    categories?: CategoryListRelationFilter
    products?: ProductListRelationFilter
    optiongroups?: OptiongroupListRelationFilter
    items?: ItemListRelationFilter
    paymenttypes?: PaymenttypeListRelationFilter
    coupons?: CouponListRelationFilter
  }, "id">

  export type brandOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    created_at?: SortOrderInput | SortOrder
    _count?: brandCountOrderByAggregateInput
    _avg?: brandAvgOrderByAggregateInput
    _max?: brandMaxOrderByAggregateInput
    _min?: brandMinOrderByAggregateInput
    _sum?: brandSumOrderByAggregateInput
  }

  export type brandScalarWhereWithAggregatesInput = {
    AND?: brandScalarWhereWithAggregatesInput | brandScalarWhereWithAggregatesInput[]
    OR?: brandScalarWhereWithAggregatesInput[]
    NOT?: brandScalarWhereWithAggregatesInput | brandScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"brand"> | number
    name?: StringWithAggregatesFilter<"brand"> | string
    created_at?: DateTimeNullableWithAggregatesFilter<"brand"> | Date | string | null
  }

  export type subbrandWhereInput = {
    AND?: subbrandWhereInput | subbrandWhereInput[]
    OR?: subbrandWhereInput[]
    NOT?: subbrandWhereInput | subbrandWhereInput[]
    id?: IntFilter<"subbrand"> | number
    brand_id?: IntFilter<"subbrand"> | number
    name?: StringFilter<"subbrand"> | string
    created_at?: DateTimeNullableFilter<"subbrand"> | Date | string | null
    brand?: XOR<BrandScalarRelationFilter, brandWhereInput>
    stores?: StoreListRelationFilter
    categories?: CategoryListRelationFilter
    products?: ProductListRelationFilter
    optiongroups?: OptiongroupListRelationFilter
    items?: ItemListRelationFilter
    customers?: CustomerListRelationFilter
    sales?: SaleListRelationFilter
  }

  export type subbrandOrderByWithRelationInput = {
    id?: SortOrder
    brand_id?: SortOrder
    name?: SortOrder
    created_at?: SortOrderInput | SortOrder
    brand?: brandOrderByWithRelationInput
    stores?: storeOrderByRelationAggregateInput
    categories?: categoryOrderByRelationAggregateInput
    products?: productOrderByRelationAggregateInput
    optiongroups?: optiongroupOrderByRelationAggregateInput
    items?: itemOrderByRelationAggregateInput
    customers?: customerOrderByRelationAggregateInput
    sales?: saleOrderByRelationAggregateInput
  }

  export type subbrandWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: subbrandWhereInput | subbrandWhereInput[]
    OR?: subbrandWhereInput[]
    NOT?: subbrandWhereInput | subbrandWhereInput[]
    brand_id?: IntFilter<"subbrand"> | number
    name?: StringFilter<"subbrand"> | string
    created_at?: DateTimeNullableFilter<"subbrand"> | Date | string | null
    brand?: XOR<BrandScalarRelationFilter, brandWhereInput>
    stores?: StoreListRelationFilter
    categories?: CategoryListRelationFilter
    products?: ProductListRelationFilter
    optiongroups?: OptiongroupListRelationFilter
    items?: ItemListRelationFilter
    customers?: CustomerListRelationFilter
    sales?: SaleListRelationFilter
  }, "id">

  export type subbrandOrderByWithAggregationInput = {
    id?: SortOrder
    brand_id?: SortOrder
    name?: SortOrder
    created_at?: SortOrderInput | SortOrder
    _count?: subbrandCountOrderByAggregateInput
    _avg?: subbrandAvgOrderByAggregateInput
    _max?: subbrandMaxOrderByAggregateInput
    _min?: subbrandMinOrderByAggregateInput
    _sum?: subbrandSumOrderByAggregateInput
  }

  export type subbrandScalarWhereWithAggregatesInput = {
    AND?: subbrandScalarWhereWithAggregatesInput | subbrandScalarWhereWithAggregatesInput[]
    OR?: subbrandScalarWhereWithAggregatesInput[]
    NOT?: subbrandScalarWhereWithAggregatesInput | subbrandScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"subbrand"> | number
    brand_id?: IntWithAggregatesFilter<"subbrand"> | number
    name?: StringWithAggregatesFilter<"subbrand"> | string
    created_at?: DateTimeNullableWithAggregatesFilter<"subbrand"> | Date | string | null
  }

  export type storeWhereInput = {
    AND?: storeWhereInput | storeWhereInput[]
    OR?: storeWhereInput[]
    NOT?: storeWhereInput | storeWhereInput[]
    id?: IntFilter<"store"> | number
    brand_id?: IntFilter<"store"> | number
    sub_brand_id?: IntNullableFilter<"store"> | number | null
    name?: StringFilter<"store"> | string
    city?: StringNullableFilter<"store"> | string | null
    state?: StringNullableFilter<"store"> | string | null
    district?: StringNullableFilter<"store"> | string | null
    address_street?: StringNullableFilter<"store"> | string | null
    address_number?: IntNullableFilter<"store"> | number | null
    zipcode?: StringNullableFilter<"store"> | string | null
    latitude?: DecimalNullableFilter<"store"> | Decimal | DecimalJsLike | number | string | null
    longitude?: DecimalNullableFilter<"store"> | Decimal | DecimalJsLike | number | string | null
    is_active?: BoolNullableFilter<"store"> | boolean | null
    is_own?: BoolNullableFilter<"store"> | boolean | null
    is_holding?: BoolNullableFilter<"store"> | boolean | null
    creation_date?: DateTimeNullableFilter<"store"> | Date | string | null
    created_at?: DateTimeNullableFilter<"store"> | Date | string | null
    brand?: XOR<BrandScalarRelationFilter, brandWhereInput>
    subbrand?: XOR<SubbrandNullableScalarRelationFilter, subbrandWhereInput> | null
    customers?: CustomerListRelationFilter
    sales?: SaleListRelationFilter
  }

  export type storeOrderByWithRelationInput = {
    id?: SortOrder
    brand_id?: SortOrder
    sub_brand_id?: SortOrderInput | SortOrder
    name?: SortOrder
    city?: SortOrderInput | SortOrder
    state?: SortOrderInput | SortOrder
    district?: SortOrderInput | SortOrder
    address_street?: SortOrderInput | SortOrder
    address_number?: SortOrderInput | SortOrder
    zipcode?: SortOrderInput | SortOrder
    latitude?: SortOrderInput | SortOrder
    longitude?: SortOrderInput | SortOrder
    is_active?: SortOrderInput | SortOrder
    is_own?: SortOrderInput | SortOrder
    is_holding?: SortOrderInput | SortOrder
    creation_date?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    brand?: brandOrderByWithRelationInput
    subbrand?: subbrandOrderByWithRelationInput
    customers?: customerOrderByRelationAggregateInput
    sales?: saleOrderByRelationAggregateInput
  }

  export type storeWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: storeWhereInput | storeWhereInput[]
    OR?: storeWhereInput[]
    NOT?: storeWhereInput | storeWhereInput[]
    brand_id?: IntFilter<"store"> | number
    sub_brand_id?: IntNullableFilter<"store"> | number | null
    name?: StringFilter<"store"> | string
    city?: StringNullableFilter<"store"> | string | null
    state?: StringNullableFilter<"store"> | string | null
    district?: StringNullableFilter<"store"> | string | null
    address_street?: StringNullableFilter<"store"> | string | null
    address_number?: IntNullableFilter<"store"> | number | null
    zipcode?: StringNullableFilter<"store"> | string | null
    latitude?: DecimalNullableFilter<"store"> | Decimal | DecimalJsLike | number | string | null
    longitude?: DecimalNullableFilter<"store"> | Decimal | DecimalJsLike | number | string | null
    is_active?: BoolNullableFilter<"store"> | boolean | null
    is_own?: BoolNullableFilter<"store"> | boolean | null
    is_holding?: BoolNullableFilter<"store"> | boolean | null
    creation_date?: DateTimeNullableFilter<"store"> | Date | string | null
    created_at?: DateTimeNullableFilter<"store"> | Date | string | null
    brand?: XOR<BrandScalarRelationFilter, brandWhereInput>
    subbrand?: XOR<SubbrandNullableScalarRelationFilter, subbrandWhereInput> | null
    customers?: CustomerListRelationFilter
    sales?: SaleListRelationFilter
  }, "id">

  export type storeOrderByWithAggregationInput = {
    id?: SortOrder
    brand_id?: SortOrder
    sub_brand_id?: SortOrderInput | SortOrder
    name?: SortOrder
    city?: SortOrderInput | SortOrder
    state?: SortOrderInput | SortOrder
    district?: SortOrderInput | SortOrder
    address_street?: SortOrderInput | SortOrder
    address_number?: SortOrderInput | SortOrder
    zipcode?: SortOrderInput | SortOrder
    latitude?: SortOrderInput | SortOrder
    longitude?: SortOrderInput | SortOrder
    is_active?: SortOrderInput | SortOrder
    is_own?: SortOrderInput | SortOrder
    is_holding?: SortOrderInput | SortOrder
    creation_date?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    _count?: storeCountOrderByAggregateInput
    _avg?: storeAvgOrderByAggregateInput
    _max?: storeMaxOrderByAggregateInput
    _min?: storeMinOrderByAggregateInput
    _sum?: storeSumOrderByAggregateInput
  }

  export type storeScalarWhereWithAggregatesInput = {
    AND?: storeScalarWhereWithAggregatesInput | storeScalarWhereWithAggregatesInput[]
    OR?: storeScalarWhereWithAggregatesInput[]
    NOT?: storeScalarWhereWithAggregatesInput | storeScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"store"> | number
    brand_id?: IntWithAggregatesFilter<"store"> | number
    sub_brand_id?: IntNullableWithAggregatesFilter<"store"> | number | null
    name?: StringWithAggregatesFilter<"store"> | string
    city?: StringNullableWithAggregatesFilter<"store"> | string | null
    state?: StringNullableWithAggregatesFilter<"store"> | string | null
    district?: StringNullableWithAggregatesFilter<"store"> | string | null
    address_street?: StringNullableWithAggregatesFilter<"store"> | string | null
    address_number?: IntNullableWithAggregatesFilter<"store"> | number | null
    zipcode?: StringNullableWithAggregatesFilter<"store"> | string | null
    latitude?: DecimalNullableWithAggregatesFilter<"store"> | Decimal | DecimalJsLike | number | string | null
    longitude?: DecimalNullableWithAggregatesFilter<"store"> | Decimal | DecimalJsLike | number | string | null
    is_active?: BoolNullableWithAggregatesFilter<"store"> | boolean | null
    is_own?: BoolNullableWithAggregatesFilter<"store"> | boolean | null
    is_holding?: BoolNullableWithAggregatesFilter<"store"> | boolean | null
    creation_date?: DateTimeNullableWithAggregatesFilter<"store"> | Date | string | null
    created_at?: DateTimeNullableWithAggregatesFilter<"store"> | Date | string | null
  }

  export type channelWhereInput = {
    AND?: channelWhereInput | channelWhereInput[]
    OR?: channelWhereInput[]
    NOT?: channelWhereInput | channelWhereInput[]
    id?: IntFilter<"channel"> | number
    brand_id?: IntFilter<"channel"> | number
    name?: StringFilter<"channel"> | string
    description?: StringNullableFilter<"channel"> | string | null
    type?: StringNullableFilter<"channel"> | string | null
    created_at?: DateTimeNullableFilter<"channel"> | Date | string | null
    brand?: XOR<BrandScalarRelationFilter, brandWhereInput>
    sales?: SaleListRelationFilter
  }

  export type channelOrderByWithRelationInput = {
    id?: SortOrder
    brand_id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    type?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    brand?: brandOrderByWithRelationInput
    sales?: saleOrderByRelationAggregateInput
  }

  export type channelWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: channelWhereInput | channelWhereInput[]
    OR?: channelWhereInput[]
    NOT?: channelWhereInput | channelWhereInput[]
    brand_id?: IntFilter<"channel"> | number
    name?: StringFilter<"channel"> | string
    description?: StringNullableFilter<"channel"> | string | null
    type?: StringNullableFilter<"channel"> | string | null
    created_at?: DateTimeNullableFilter<"channel"> | Date | string | null
    brand?: XOR<BrandScalarRelationFilter, brandWhereInput>
    sales?: SaleListRelationFilter
  }, "id">

  export type channelOrderByWithAggregationInput = {
    id?: SortOrder
    brand_id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    type?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    _count?: channelCountOrderByAggregateInput
    _avg?: channelAvgOrderByAggregateInput
    _max?: channelMaxOrderByAggregateInput
    _min?: channelMinOrderByAggregateInput
    _sum?: channelSumOrderByAggregateInput
  }

  export type channelScalarWhereWithAggregatesInput = {
    AND?: channelScalarWhereWithAggregatesInput | channelScalarWhereWithAggregatesInput[]
    OR?: channelScalarWhereWithAggregatesInput[]
    NOT?: channelScalarWhereWithAggregatesInput | channelScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"channel"> | number
    brand_id?: IntWithAggregatesFilter<"channel"> | number
    name?: StringWithAggregatesFilter<"channel"> | string
    description?: StringNullableWithAggregatesFilter<"channel"> | string | null
    type?: StringNullableWithAggregatesFilter<"channel"> | string | null
    created_at?: DateTimeNullableWithAggregatesFilter<"channel"> | Date | string | null
  }

  export type categoryWhereInput = {
    AND?: categoryWhereInput | categoryWhereInput[]
    OR?: categoryWhereInput[]
    NOT?: categoryWhereInput | categoryWhereInput[]
    id?: IntFilter<"category"> | number
    brand_id?: IntFilter<"category"> | number
    sub_brand_id?: IntNullableFilter<"category"> | number | null
    name?: StringFilter<"category"> | string
    type?: StringNullableFilter<"category"> | string | null
    pos_uuid?: StringNullableFilter<"category"> | string | null
    deleted_at?: DateTimeNullableFilter<"category"> | Date | string | null
    brand?: XOR<BrandScalarRelationFilter, brandWhereInput>
    subbrand?: XOR<SubbrandNullableScalarRelationFilter, subbrandWhereInput> | null
    products?: ProductListRelationFilter
    optiongroups?: OptiongroupListRelationFilter
    items?: ItemListRelationFilter
  }

  export type categoryOrderByWithRelationInput = {
    id?: SortOrder
    brand_id?: SortOrder
    sub_brand_id?: SortOrderInput | SortOrder
    name?: SortOrder
    type?: SortOrderInput | SortOrder
    pos_uuid?: SortOrderInput | SortOrder
    deleted_at?: SortOrderInput | SortOrder
    brand?: brandOrderByWithRelationInput
    subbrand?: subbrandOrderByWithRelationInput
    products?: productOrderByRelationAggregateInput
    optiongroups?: optiongroupOrderByRelationAggregateInput
    items?: itemOrderByRelationAggregateInput
  }

  export type categoryWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: categoryWhereInput | categoryWhereInput[]
    OR?: categoryWhereInput[]
    NOT?: categoryWhereInput | categoryWhereInput[]
    brand_id?: IntFilter<"category"> | number
    sub_brand_id?: IntNullableFilter<"category"> | number | null
    name?: StringFilter<"category"> | string
    type?: StringNullableFilter<"category"> | string | null
    pos_uuid?: StringNullableFilter<"category"> | string | null
    deleted_at?: DateTimeNullableFilter<"category"> | Date | string | null
    brand?: XOR<BrandScalarRelationFilter, brandWhereInput>
    subbrand?: XOR<SubbrandNullableScalarRelationFilter, subbrandWhereInput> | null
    products?: ProductListRelationFilter
    optiongroups?: OptiongroupListRelationFilter
    items?: ItemListRelationFilter
  }, "id">

  export type categoryOrderByWithAggregationInput = {
    id?: SortOrder
    brand_id?: SortOrder
    sub_brand_id?: SortOrderInput | SortOrder
    name?: SortOrder
    type?: SortOrderInput | SortOrder
    pos_uuid?: SortOrderInput | SortOrder
    deleted_at?: SortOrderInput | SortOrder
    _count?: categoryCountOrderByAggregateInput
    _avg?: categoryAvgOrderByAggregateInput
    _max?: categoryMaxOrderByAggregateInput
    _min?: categoryMinOrderByAggregateInput
    _sum?: categorySumOrderByAggregateInput
  }

  export type categoryScalarWhereWithAggregatesInput = {
    AND?: categoryScalarWhereWithAggregatesInput | categoryScalarWhereWithAggregatesInput[]
    OR?: categoryScalarWhereWithAggregatesInput[]
    NOT?: categoryScalarWhereWithAggregatesInput | categoryScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"category"> | number
    brand_id?: IntWithAggregatesFilter<"category"> | number
    sub_brand_id?: IntNullableWithAggregatesFilter<"category"> | number | null
    name?: StringWithAggregatesFilter<"category"> | string
    type?: StringNullableWithAggregatesFilter<"category"> | string | null
    pos_uuid?: StringNullableWithAggregatesFilter<"category"> | string | null
    deleted_at?: DateTimeNullableWithAggregatesFilter<"category"> | Date | string | null
  }

  export type productWhereInput = {
    AND?: productWhereInput | productWhereInput[]
    OR?: productWhereInput[]
    NOT?: productWhereInput | productWhereInput[]
    id?: IntFilter<"product"> | number
    brand_id?: IntFilter<"product"> | number
    sub_brand_id?: IntNullableFilter<"product"> | number | null
    category_id?: IntNullableFilter<"product"> | number | null
    name?: StringFilter<"product"> | string
    pos_uuid?: StringNullableFilter<"product"> | string | null
    deleted_at?: DateTimeNullableFilter<"product"> | Date | string | null
    brand?: XOR<BrandScalarRelationFilter, brandWhereInput>
    subbrand?: XOR<SubbrandNullableScalarRelationFilter, subbrandWhereInput> | null
    category?: XOR<CategoryNullableScalarRelationFilter, categoryWhereInput> | null
    productsales?: ProductsaleListRelationFilter
  }

  export type productOrderByWithRelationInput = {
    id?: SortOrder
    brand_id?: SortOrder
    sub_brand_id?: SortOrderInput | SortOrder
    category_id?: SortOrderInput | SortOrder
    name?: SortOrder
    pos_uuid?: SortOrderInput | SortOrder
    deleted_at?: SortOrderInput | SortOrder
    brand?: brandOrderByWithRelationInput
    subbrand?: subbrandOrderByWithRelationInput
    category?: categoryOrderByWithRelationInput
    productsales?: productsaleOrderByRelationAggregateInput
  }

  export type productWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: productWhereInput | productWhereInput[]
    OR?: productWhereInput[]
    NOT?: productWhereInput | productWhereInput[]
    brand_id?: IntFilter<"product"> | number
    sub_brand_id?: IntNullableFilter<"product"> | number | null
    category_id?: IntNullableFilter<"product"> | number | null
    name?: StringFilter<"product"> | string
    pos_uuid?: StringNullableFilter<"product"> | string | null
    deleted_at?: DateTimeNullableFilter<"product"> | Date | string | null
    brand?: XOR<BrandScalarRelationFilter, brandWhereInput>
    subbrand?: XOR<SubbrandNullableScalarRelationFilter, subbrandWhereInput> | null
    category?: XOR<CategoryNullableScalarRelationFilter, categoryWhereInput> | null
    productsales?: ProductsaleListRelationFilter
  }, "id">

  export type productOrderByWithAggregationInput = {
    id?: SortOrder
    brand_id?: SortOrder
    sub_brand_id?: SortOrderInput | SortOrder
    category_id?: SortOrderInput | SortOrder
    name?: SortOrder
    pos_uuid?: SortOrderInput | SortOrder
    deleted_at?: SortOrderInput | SortOrder
    _count?: productCountOrderByAggregateInput
    _avg?: productAvgOrderByAggregateInput
    _max?: productMaxOrderByAggregateInput
    _min?: productMinOrderByAggregateInput
    _sum?: productSumOrderByAggregateInput
  }

  export type productScalarWhereWithAggregatesInput = {
    AND?: productScalarWhereWithAggregatesInput | productScalarWhereWithAggregatesInput[]
    OR?: productScalarWhereWithAggregatesInput[]
    NOT?: productScalarWhereWithAggregatesInput | productScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"product"> | number
    brand_id?: IntWithAggregatesFilter<"product"> | number
    sub_brand_id?: IntNullableWithAggregatesFilter<"product"> | number | null
    category_id?: IntNullableWithAggregatesFilter<"product"> | number | null
    name?: StringWithAggregatesFilter<"product"> | string
    pos_uuid?: StringNullableWithAggregatesFilter<"product"> | string | null
    deleted_at?: DateTimeNullableWithAggregatesFilter<"product"> | Date | string | null
  }

  export type optiongroupWhereInput = {
    AND?: optiongroupWhereInput | optiongroupWhereInput[]
    OR?: optiongroupWhereInput[]
    NOT?: optiongroupWhereInput | optiongroupWhereInput[]
    id?: IntFilter<"optiongroup"> | number
    brand_id?: IntFilter<"optiongroup"> | number
    sub_brand_id?: IntNullableFilter<"optiongroup"> | number | null
    category_id?: IntNullableFilter<"optiongroup"> | number | null
    name?: StringFilter<"optiongroup"> | string
    pos_uuid?: StringNullableFilter<"optiongroup"> | string | null
    deleted_at?: DateTimeNullableFilter<"optiongroup"> | Date | string | null
    brand?: XOR<BrandScalarRelationFilter, brandWhereInput>
    subbrand?: XOR<SubbrandNullableScalarRelationFilter, subbrandWhereInput> | null
    category?: XOR<CategoryNullableScalarRelationFilter, categoryWhereInput> | null
    itemproductsales?: ItemproductsaleListRelationFilter
    itemitemproductsales?: ItemitemproductsaleListRelationFilter
  }

  export type optiongroupOrderByWithRelationInput = {
    id?: SortOrder
    brand_id?: SortOrder
    sub_brand_id?: SortOrderInput | SortOrder
    category_id?: SortOrderInput | SortOrder
    name?: SortOrder
    pos_uuid?: SortOrderInput | SortOrder
    deleted_at?: SortOrderInput | SortOrder
    brand?: brandOrderByWithRelationInput
    subbrand?: subbrandOrderByWithRelationInput
    category?: categoryOrderByWithRelationInput
    itemproductsales?: itemproductsaleOrderByRelationAggregateInput
    itemitemproductsales?: itemitemproductsaleOrderByRelationAggregateInput
  }

  export type optiongroupWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: optiongroupWhereInput | optiongroupWhereInput[]
    OR?: optiongroupWhereInput[]
    NOT?: optiongroupWhereInput | optiongroupWhereInput[]
    brand_id?: IntFilter<"optiongroup"> | number
    sub_brand_id?: IntNullableFilter<"optiongroup"> | number | null
    category_id?: IntNullableFilter<"optiongroup"> | number | null
    name?: StringFilter<"optiongroup"> | string
    pos_uuid?: StringNullableFilter<"optiongroup"> | string | null
    deleted_at?: DateTimeNullableFilter<"optiongroup"> | Date | string | null
    brand?: XOR<BrandScalarRelationFilter, brandWhereInput>
    subbrand?: XOR<SubbrandNullableScalarRelationFilter, subbrandWhereInput> | null
    category?: XOR<CategoryNullableScalarRelationFilter, categoryWhereInput> | null
    itemproductsales?: ItemproductsaleListRelationFilter
    itemitemproductsales?: ItemitemproductsaleListRelationFilter
  }, "id">

  export type optiongroupOrderByWithAggregationInput = {
    id?: SortOrder
    brand_id?: SortOrder
    sub_brand_id?: SortOrderInput | SortOrder
    category_id?: SortOrderInput | SortOrder
    name?: SortOrder
    pos_uuid?: SortOrderInput | SortOrder
    deleted_at?: SortOrderInput | SortOrder
    _count?: optiongroupCountOrderByAggregateInput
    _avg?: optiongroupAvgOrderByAggregateInput
    _max?: optiongroupMaxOrderByAggregateInput
    _min?: optiongroupMinOrderByAggregateInput
    _sum?: optiongroupSumOrderByAggregateInput
  }

  export type optiongroupScalarWhereWithAggregatesInput = {
    AND?: optiongroupScalarWhereWithAggregatesInput | optiongroupScalarWhereWithAggregatesInput[]
    OR?: optiongroupScalarWhereWithAggregatesInput[]
    NOT?: optiongroupScalarWhereWithAggregatesInput | optiongroupScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"optiongroup"> | number
    brand_id?: IntWithAggregatesFilter<"optiongroup"> | number
    sub_brand_id?: IntNullableWithAggregatesFilter<"optiongroup"> | number | null
    category_id?: IntNullableWithAggregatesFilter<"optiongroup"> | number | null
    name?: StringWithAggregatesFilter<"optiongroup"> | string
    pos_uuid?: StringNullableWithAggregatesFilter<"optiongroup"> | string | null
    deleted_at?: DateTimeNullableWithAggregatesFilter<"optiongroup"> | Date | string | null
  }

  export type itemWhereInput = {
    AND?: itemWhereInput | itemWhereInput[]
    OR?: itemWhereInput[]
    NOT?: itemWhereInput | itemWhereInput[]
    id?: IntFilter<"item"> | number
    brand_id?: IntFilter<"item"> | number
    sub_brand_id?: IntNullableFilter<"item"> | number | null
    category_id?: IntNullableFilter<"item"> | number | null
    name?: StringFilter<"item"> | string
    pos_uuid?: StringNullableFilter<"item"> | string | null
    deleted_at?: DateTimeNullableFilter<"item"> | Date | string | null
    brand?: XOR<BrandScalarRelationFilter, brandWhereInput>
    subbrand?: XOR<SubbrandNullableScalarRelationFilter, subbrandWhereInput> | null
    category?: XOR<CategoryNullableScalarRelationFilter, categoryWhereInput> | null
    itemproductsales?: ItemproductsaleListRelationFilter
    itemitemproductsales?: ItemitemproductsaleListRelationFilter
  }

  export type itemOrderByWithRelationInput = {
    id?: SortOrder
    brand_id?: SortOrder
    sub_brand_id?: SortOrderInput | SortOrder
    category_id?: SortOrderInput | SortOrder
    name?: SortOrder
    pos_uuid?: SortOrderInput | SortOrder
    deleted_at?: SortOrderInput | SortOrder
    brand?: brandOrderByWithRelationInput
    subbrand?: subbrandOrderByWithRelationInput
    category?: categoryOrderByWithRelationInput
    itemproductsales?: itemproductsaleOrderByRelationAggregateInput
    itemitemproductsales?: itemitemproductsaleOrderByRelationAggregateInput
  }

  export type itemWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: itemWhereInput | itemWhereInput[]
    OR?: itemWhereInput[]
    NOT?: itemWhereInput | itemWhereInput[]
    brand_id?: IntFilter<"item"> | number
    sub_brand_id?: IntNullableFilter<"item"> | number | null
    category_id?: IntNullableFilter<"item"> | number | null
    name?: StringFilter<"item"> | string
    pos_uuid?: StringNullableFilter<"item"> | string | null
    deleted_at?: DateTimeNullableFilter<"item"> | Date | string | null
    brand?: XOR<BrandScalarRelationFilter, brandWhereInput>
    subbrand?: XOR<SubbrandNullableScalarRelationFilter, subbrandWhereInput> | null
    category?: XOR<CategoryNullableScalarRelationFilter, categoryWhereInput> | null
    itemproductsales?: ItemproductsaleListRelationFilter
    itemitemproductsales?: ItemitemproductsaleListRelationFilter
  }, "id">

  export type itemOrderByWithAggregationInput = {
    id?: SortOrder
    brand_id?: SortOrder
    sub_brand_id?: SortOrderInput | SortOrder
    category_id?: SortOrderInput | SortOrder
    name?: SortOrder
    pos_uuid?: SortOrderInput | SortOrder
    deleted_at?: SortOrderInput | SortOrder
    _count?: itemCountOrderByAggregateInput
    _avg?: itemAvgOrderByAggregateInput
    _max?: itemMaxOrderByAggregateInput
    _min?: itemMinOrderByAggregateInput
    _sum?: itemSumOrderByAggregateInput
  }

  export type itemScalarWhereWithAggregatesInput = {
    AND?: itemScalarWhereWithAggregatesInput | itemScalarWhereWithAggregatesInput[]
    OR?: itemScalarWhereWithAggregatesInput[]
    NOT?: itemScalarWhereWithAggregatesInput | itemScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"item"> | number
    brand_id?: IntWithAggregatesFilter<"item"> | number
    sub_brand_id?: IntNullableWithAggregatesFilter<"item"> | number | null
    category_id?: IntNullableWithAggregatesFilter<"item"> | number | null
    name?: StringWithAggregatesFilter<"item"> | string
    pos_uuid?: StringNullableWithAggregatesFilter<"item"> | string | null
    deleted_at?: DateTimeNullableWithAggregatesFilter<"item"> | Date | string | null
  }

  export type customerWhereInput = {
    AND?: customerWhereInput | customerWhereInput[]
    OR?: customerWhereInput[]
    NOT?: customerWhereInput | customerWhereInput[]
    id?: IntFilter<"customer"> | number
    customer_name?: StringNullableFilter<"customer"> | string | null
    email?: StringNullableFilter<"customer"> | string | null
    phone_number?: StringNullableFilter<"customer"> | string | null
    cpf?: StringNullableFilter<"customer"> | string | null
    birth_date?: DateTimeNullableFilter<"customer"> | Date | string | null
    gender?: StringNullableFilter<"customer"> | string | null
    store_id?: IntNullableFilter<"customer"> | number | null
    sub_brand_id?: IntNullableFilter<"customer"> | number | null
    registration_origin?: StringNullableFilter<"customer"> | string | null
    agree_terms?: BoolNullableFilter<"customer"> | boolean | null
    receive_promotions_email?: BoolNullableFilter<"customer"> | boolean | null
    receive_promotions_sms?: BoolNullableFilter<"customer"> | boolean | null
    created_at?: DateTimeNullableFilter<"customer"> | Date | string | null
    store?: XOR<StoreNullableScalarRelationFilter, storeWhereInput> | null
    subbrand?: XOR<SubbrandNullableScalarRelationFilter, subbrandWhereInput> | null
    sales?: SaleListRelationFilter
  }

  export type customerOrderByWithRelationInput = {
    id?: SortOrder
    customer_name?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    phone_number?: SortOrderInput | SortOrder
    cpf?: SortOrderInput | SortOrder
    birth_date?: SortOrderInput | SortOrder
    gender?: SortOrderInput | SortOrder
    store_id?: SortOrderInput | SortOrder
    sub_brand_id?: SortOrderInput | SortOrder
    registration_origin?: SortOrderInput | SortOrder
    agree_terms?: SortOrderInput | SortOrder
    receive_promotions_email?: SortOrderInput | SortOrder
    receive_promotions_sms?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    store?: storeOrderByWithRelationInput
    subbrand?: subbrandOrderByWithRelationInput
    sales?: saleOrderByRelationAggregateInput
  }

  export type customerWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: customerWhereInput | customerWhereInput[]
    OR?: customerWhereInput[]
    NOT?: customerWhereInput | customerWhereInput[]
    customer_name?: StringNullableFilter<"customer"> | string | null
    email?: StringNullableFilter<"customer"> | string | null
    phone_number?: StringNullableFilter<"customer"> | string | null
    cpf?: StringNullableFilter<"customer"> | string | null
    birth_date?: DateTimeNullableFilter<"customer"> | Date | string | null
    gender?: StringNullableFilter<"customer"> | string | null
    store_id?: IntNullableFilter<"customer"> | number | null
    sub_brand_id?: IntNullableFilter<"customer"> | number | null
    registration_origin?: StringNullableFilter<"customer"> | string | null
    agree_terms?: BoolNullableFilter<"customer"> | boolean | null
    receive_promotions_email?: BoolNullableFilter<"customer"> | boolean | null
    receive_promotions_sms?: BoolNullableFilter<"customer"> | boolean | null
    created_at?: DateTimeNullableFilter<"customer"> | Date | string | null
    store?: XOR<StoreNullableScalarRelationFilter, storeWhereInput> | null
    subbrand?: XOR<SubbrandNullableScalarRelationFilter, subbrandWhereInput> | null
    sales?: SaleListRelationFilter
  }, "id">

  export type customerOrderByWithAggregationInput = {
    id?: SortOrder
    customer_name?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    phone_number?: SortOrderInput | SortOrder
    cpf?: SortOrderInput | SortOrder
    birth_date?: SortOrderInput | SortOrder
    gender?: SortOrderInput | SortOrder
    store_id?: SortOrderInput | SortOrder
    sub_brand_id?: SortOrderInput | SortOrder
    registration_origin?: SortOrderInput | SortOrder
    agree_terms?: SortOrderInput | SortOrder
    receive_promotions_email?: SortOrderInput | SortOrder
    receive_promotions_sms?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    _count?: customerCountOrderByAggregateInput
    _avg?: customerAvgOrderByAggregateInput
    _max?: customerMaxOrderByAggregateInput
    _min?: customerMinOrderByAggregateInput
    _sum?: customerSumOrderByAggregateInput
  }

  export type customerScalarWhereWithAggregatesInput = {
    AND?: customerScalarWhereWithAggregatesInput | customerScalarWhereWithAggregatesInput[]
    OR?: customerScalarWhereWithAggregatesInput[]
    NOT?: customerScalarWhereWithAggregatesInput | customerScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"customer"> | number
    customer_name?: StringNullableWithAggregatesFilter<"customer"> | string | null
    email?: StringNullableWithAggregatesFilter<"customer"> | string | null
    phone_number?: StringNullableWithAggregatesFilter<"customer"> | string | null
    cpf?: StringNullableWithAggregatesFilter<"customer"> | string | null
    birth_date?: DateTimeNullableWithAggregatesFilter<"customer"> | Date | string | null
    gender?: StringNullableWithAggregatesFilter<"customer"> | string | null
    store_id?: IntNullableWithAggregatesFilter<"customer"> | number | null
    sub_brand_id?: IntNullableWithAggregatesFilter<"customer"> | number | null
    registration_origin?: StringNullableWithAggregatesFilter<"customer"> | string | null
    agree_terms?: BoolNullableWithAggregatesFilter<"customer"> | boolean | null
    receive_promotions_email?: BoolNullableWithAggregatesFilter<"customer"> | boolean | null
    receive_promotions_sms?: BoolNullableWithAggregatesFilter<"customer"> | boolean | null
    created_at?: DateTimeNullableWithAggregatesFilter<"customer"> | Date | string | null
  }

  export type saleWhereInput = {
    AND?: saleWhereInput | saleWhereInput[]
    OR?: saleWhereInput[]
    NOT?: saleWhereInput | saleWhereInput[]
    id?: IntFilter<"sale"> | number
    store_id?: IntFilter<"sale"> | number
    sub_brand_id?: IntNullableFilter<"sale"> | number | null
    customer_id?: IntNullableFilter<"sale"> | number | null
    channel_id?: IntFilter<"sale"> | number
    cod_sale1?: StringNullableFilter<"sale"> | string | null
    cod_sale2?: StringNullableFilter<"sale"> | string | null
    created_at?: DateTimeFilter<"sale"> | Date | string
    customer_name?: StringNullableFilter<"sale"> | string | null
    sale_status_desc?: StringFilter<"sale"> | string
    total_amount_items?: DecimalFilter<"sale"> | Decimal | DecimalJsLike | number | string
    total_discount?: DecimalNullableFilter<"sale"> | Decimal | DecimalJsLike | number | string | null
    total_increase?: DecimalNullableFilter<"sale"> | Decimal | DecimalJsLike | number | string | null
    delivery_fee?: DecimalNullableFilter<"sale"> | Decimal | DecimalJsLike | number | string | null
    service_tax_fee?: DecimalNullableFilter<"sale"> | Decimal | DecimalJsLike | number | string | null
    total_amount?: DecimalFilter<"sale"> | Decimal | DecimalJsLike | number | string
    value_paid?: DecimalNullableFilter<"sale"> | Decimal | DecimalJsLike | number | string | null
    production_seconds?: IntNullableFilter<"sale"> | number | null
    delivery_seconds?: IntNullableFilter<"sale"> | number | null
    people_quantity?: IntNullableFilter<"sale"> | number | null
    discount_reason?: StringNullableFilter<"sale"> | string | null
    increase_reason?: StringNullableFilter<"sale"> | string | null
    origin?: StringNullableFilter<"sale"> | string | null
    store?: XOR<StoreScalarRelationFilter, storeWhereInput>
    subbrand?: XOR<SubbrandNullableScalarRelationFilter, subbrandWhereInput> | null
    customer?: XOR<CustomerNullableScalarRelationFilter, customerWhereInput> | null
    channel?: XOR<ChannelScalarRelationFilter, channelWhereInput>
    productsales?: ProductsaleListRelationFilter
    deliverysales?: DeliverysaleListRelationFilter
    deliveryaddress?: DeliveryaddressListRelationFilter
    payments?: PaymentListRelationFilter
    couponsales?: CouponsaleListRelationFilter
  }

  export type saleOrderByWithRelationInput = {
    id?: SortOrder
    store_id?: SortOrder
    sub_brand_id?: SortOrderInput | SortOrder
    customer_id?: SortOrderInput | SortOrder
    channel_id?: SortOrder
    cod_sale1?: SortOrderInput | SortOrder
    cod_sale2?: SortOrderInput | SortOrder
    created_at?: SortOrder
    customer_name?: SortOrderInput | SortOrder
    sale_status_desc?: SortOrder
    total_amount_items?: SortOrder
    total_discount?: SortOrderInput | SortOrder
    total_increase?: SortOrderInput | SortOrder
    delivery_fee?: SortOrderInput | SortOrder
    service_tax_fee?: SortOrderInput | SortOrder
    total_amount?: SortOrder
    value_paid?: SortOrderInput | SortOrder
    production_seconds?: SortOrderInput | SortOrder
    delivery_seconds?: SortOrderInput | SortOrder
    people_quantity?: SortOrderInput | SortOrder
    discount_reason?: SortOrderInput | SortOrder
    increase_reason?: SortOrderInput | SortOrder
    origin?: SortOrderInput | SortOrder
    store?: storeOrderByWithRelationInput
    subbrand?: subbrandOrderByWithRelationInput
    customer?: customerOrderByWithRelationInput
    channel?: channelOrderByWithRelationInput
    productsales?: productsaleOrderByRelationAggregateInput
    deliverysales?: deliverysaleOrderByRelationAggregateInput
    deliveryaddress?: deliveryaddressOrderByRelationAggregateInput
    payments?: paymentOrderByRelationAggregateInput
    couponsales?: couponsaleOrderByRelationAggregateInput
  }

  export type saleWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: saleWhereInput | saleWhereInput[]
    OR?: saleWhereInput[]
    NOT?: saleWhereInput | saleWhereInput[]
    store_id?: IntFilter<"sale"> | number
    sub_brand_id?: IntNullableFilter<"sale"> | number | null
    customer_id?: IntNullableFilter<"sale"> | number | null
    channel_id?: IntFilter<"sale"> | number
    cod_sale1?: StringNullableFilter<"sale"> | string | null
    cod_sale2?: StringNullableFilter<"sale"> | string | null
    created_at?: DateTimeFilter<"sale"> | Date | string
    customer_name?: StringNullableFilter<"sale"> | string | null
    sale_status_desc?: StringFilter<"sale"> | string
    total_amount_items?: DecimalFilter<"sale"> | Decimal | DecimalJsLike | number | string
    total_discount?: DecimalNullableFilter<"sale"> | Decimal | DecimalJsLike | number | string | null
    total_increase?: DecimalNullableFilter<"sale"> | Decimal | DecimalJsLike | number | string | null
    delivery_fee?: DecimalNullableFilter<"sale"> | Decimal | DecimalJsLike | number | string | null
    service_tax_fee?: DecimalNullableFilter<"sale"> | Decimal | DecimalJsLike | number | string | null
    total_amount?: DecimalFilter<"sale"> | Decimal | DecimalJsLike | number | string
    value_paid?: DecimalNullableFilter<"sale"> | Decimal | DecimalJsLike | number | string | null
    production_seconds?: IntNullableFilter<"sale"> | number | null
    delivery_seconds?: IntNullableFilter<"sale"> | number | null
    people_quantity?: IntNullableFilter<"sale"> | number | null
    discount_reason?: StringNullableFilter<"sale"> | string | null
    increase_reason?: StringNullableFilter<"sale"> | string | null
    origin?: StringNullableFilter<"sale"> | string | null
    store?: XOR<StoreScalarRelationFilter, storeWhereInput>
    subbrand?: XOR<SubbrandNullableScalarRelationFilter, subbrandWhereInput> | null
    customer?: XOR<CustomerNullableScalarRelationFilter, customerWhereInput> | null
    channel?: XOR<ChannelScalarRelationFilter, channelWhereInput>
    productsales?: ProductsaleListRelationFilter
    deliverysales?: DeliverysaleListRelationFilter
    deliveryaddress?: DeliveryaddressListRelationFilter
    payments?: PaymentListRelationFilter
    couponsales?: CouponsaleListRelationFilter
  }, "id">

  export type saleOrderByWithAggregationInput = {
    id?: SortOrder
    store_id?: SortOrder
    sub_brand_id?: SortOrderInput | SortOrder
    customer_id?: SortOrderInput | SortOrder
    channel_id?: SortOrder
    cod_sale1?: SortOrderInput | SortOrder
    cod_sale2?: SortOrderInput | SortOrder
    created_at?: SortOrder
    customer_name?: SortOrderInput | SortOrder
    sale_status_desc?: SortOrder
    total_amount_items?: SortOrder
    total_discount?: SortOrderInput | SortOrder
    total_increase?: SortOrderInput | SortOrder
    delivery_fee?: SortOrderInput | SortOrder
    service_tax_fee?: SortOrderInput | SortOrder
    total_amount?: SortOrder
    value_paid?: SortOrderInput | SortOrder
    production_seconds?: SortOrderInput | SortOrder
    delivery_seconds?: SortOrderInput | SortOrder
    people_quantity?: SortOrderInput | SortOrder
    discount_reason?: SortOrderInput | SortOrder
    increase_reason?: SortOrderInput | SortOrder
    origin?: SortOrderInput | SortOrder
    _count?: saleCountOrderByAggregateInput
    _avg?: saleAvgOrderByAggregateInput
    _max?: saleMaxOrderByAggregateInput
    _min?: saleMinOrderByAggregateInput
    _sum?: saleSumOrderByAggregateInput
  }

  export type saleScalarWhereWithAggregatesInput = {
    AND?: saleScalarWhereWithAggregatesInput | saleScalarWhereWithAggregatesInput[]
    OR?: saleScalarWhereWithAggregatesInput[]
    NOT?: saleScalarWhereWithAggregatesInput | saleScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"sale"> | number
    store_id?: IntWithAggregatesFilter<"sale"> | number
    sub_brand_id?: IntNullableWithAggregatesFilter<"sale"> | number | null
    customer_id?: IntNullableWithAggregatesFilter<"sale"> | number | null
    channel_id?: IntWithAggregatesFilter<"sale"> | number
    cod_sale1?: StringNullableWithAggregatesFilter<"sale"> | string | null
    cod_sale2?: StringNullableWithAggregatesFilter<"sale"> | string | null
    created_at?: DateTimeWithAggregatesFilter<"sale"> | Date | string
    customer_name?: StringNullableWithAggregatesFilter<"sale"> | string | null
    sale_status_desc?: StringWithAggregatesFilter<"sale"> | string
    total_amount_items?: DecimalWithAggregatesFilter<"sale"> | Decimal | DecimalJsLike | number | string
    total_discount?: DecimalNullableWithAggregatesFilter<"sale"> | Decimal | DecimalJsLike | number | string | null
    total_increase?: DecimalNullableWithAggregatesFilter<"sale"> | Decimal | DecimalJsLike | number | string | null
    delivery_fee?: DecimalNullableWithAggregatesFilter<"sale"> | Decimal | DecimalJsLike | number | string | null
    service_tax_fee?: DecimalNullableWithAggregatesFilter<"sale"> | Decimal | DecimalJsLike | number | string | null
    total_amount?: DecimalWithAggregatesFilter<"sale"> | Decimal | DecimalJsLike | number | string
    value_paid?: DecimalNullableWithAggregatesFilter<"sale"> | Decimal | DecimalJsLike | number | string | null
    production_seconds?: IntNullableWithAggregatesFilter<"sale"> | number | null
    delivery_seconds?: IntNullableWithAggregatesFilter<"sale"> | number | null
    people_quantity?: IntNullableWithAggregatesFilter<"sale"> | number | null
    discount_reason?: StringNullableWithAggregatesFilter<"sale"> | string | null
    increase_reason?: StringNullableWithAggregatesFilter<"sale"> | string | null
    origin?: StringNullableWithAggregatesFilter<"sale"> | string | null
  }

  export type productsaleWhereInput = {
    AND?: productsaleWhereInput | productsaleWhereInput[]
    OR?: productsaleWhereInput[]
    NOT?: productsaleWhereInput | productsaleWhereInput[]
    id?: IntFilter<"productsale"> | number
    sale_id?: IntFilter<"productsale"> | number
    product_id?: IntFilter<"productsale"> | number
    quantity?: FloatFilter<"productsale"> | number
    base_price?: FloatFilter<"productsale"> | number
    total_price?: FloatFilter<"productsale"> | number
    observations?: StringNullableFilter<"productsale"> | string | null
    sale?: XOR<SaleScalarRelationFilter, saleWhereInput>
    product?: XOR<ProductScalarRelationFilter, productWhereInput>
    itemproductsales?: ItemproductsaleListRelationFilter
  }

  export type productsaleOrderByWithRelationInput = {
    id?: SortOrder
    sale_id?: SortOrder
    product_id?: SortOrder
    quantity?: SortOrder
    base_price?: SortOrder
    total_price?: SortOrder
    observations?: SortOrderInput | SortOrder
    sale?: saleOrderByWithRelationInput
    product?: productOrderByWithRelationInput
    itemproductsales?: itemproductsaleOrderByRelationAggregateInput
  }

  export type productsaleWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: productsaleWhereInput | productsaleWhereInput[]
    OR?: productsaleWhereInput[]
    NOT?: productsaleWhereInput | productsaleWhereInput[]
    sale_id?: IntFilter<"productsale"> | number
    product_id?: IntFilter<"productsale"> | number
    quantity?: FloatFilter<"productsale"> | number
    base_price?: FloatFilter<"productsale"> | number
    total_price?: FloatFilter<"productsale"> | number
    observations?: StringNullableFilter<"productsale"> | string | null
    sale?: XOR<SaleScalarRelationFilter, saleWhereInput>
    product?: XOR<ProductScalarRelationFilter, productWhereInput>
    itemproductsales?: ItemproductsaleListRelationFilter
  }, "id">

  export type productsaleOrderByWithAggregationInput = {
    id?: SortOrder
    sale_id?: SortOrder
    product_id?: SortOrder
    quantity?: SortOrder
    base_price?: SortOrder
    total_price?: SortOrder
    observations?: SortOrderInput | SortOrder
    _count?: productsaleCountOrderByAggregateInput
    _avg?: productsaleAvgOrderByAggregateInput
    _max?: productsaleMaxOrderByAggregateInput
    _min?: productsaleMinOrderByAggregateInput
    _sum?: productsaleSumOrderByAggregateInput
  }

  export type productsaleScalarWhereWithAggregatesInput = {
    AND?: productsaleScalarWhereWithAggregatesInput | productsaleScalarWhereWithAggregatesInput[]
    OR?: productsaleScalarWhereWithAggregatesInput[]
    NOT?: productsaleScalarWhereWithAggregatesInput | productsaleScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"productsale"> | number
    sale_id?: IntWithAggregatesFilter<"productsale"> | number
    product_id?: IntWithAggregatesFilter<"productsale"> | number
    quantity?: FloatWithAggregatesFilter<"productsale"> | number
    base_price?: FloatWithAggregatesFilter<"productsale"> | number
    total_price?: FloatWithAggregatesFilter<"productsale"> | number
    observations?: StringNullableWithAggregatesFilter<"productsale"> | string | null
  }

  export type itemproductsaleWhereInput = {
    AND?: itemproductsaleWhereInput | itemproductsaleWhereInput[]
    OR?: itemproductsaleWhereInput[]
    NOT?: itemproductsaleWhereInput | itemproductsaleWhereInput[]
    id?: IntFilter<"itemproductsale"> | number
    product_sale_id?: IntFilter<"itemproductsale"> | number
    item_id?: IntFilter<"itemproductsale"> | number
    option_group_id?: IntNullableFilter<"itemproductsale"> | number | null
    quantity?: FloatFilter<"itemproductsale"> | number
    additional_price?: FloatFilter<"itemproductsale"> | number
    price?: FloatFilter<"itemproductsale"> | number
    amount?: FloatNullableFilter<"itemproductsale"> | number | null
    observations?: StringNullableFilter<"itemproductsale"> | string | null
    productsale?: XOR<ProductsaleScalarRelationFilter, productsaleWhereInput>
    item?: XOR<ItemScalarRelationFilter, itemWhereInput>
    optiongroup?: XOR<OptiongroupNullableScalarRelationFilter, optiongroupWhereInput> | null
    itemitemproductsales?: ItemitemproductsaleListRelationFilter
  }

  export type itemproductsaleOrderByWithRelationInput = {
    id?: SortOrder
    product_sale_id?: SortOrder
    item_id?: SortOrder
    option_group_id?: SortOrderInput | SortOrder
    quantity?: SortOrder
    additional_price?: SortOrder
    price?: SortOrder
    amount?: SortOrderInput | SortOrder
    observations?: SortOrderInput | SortOrder
    productsale?: productsaleOrderByWithRelationInput
    item?: itemOrderByWithRelationInput
    optiongroup?: optiongroupOrderByWithRelationInput
    itemitemproductsales?: itemitemproductsaleOrderByRelationAggregateInput
  }

  export type itemproductsaleWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: itemproductsaleWhereInput | itemproductsaleWhereInput[]
    OR?: itemproductsaleWhereInput[]
    NOT?: itemproductsaleWhereInput | itemproductsaleWhereInput[]
    product_sale_id?: IntFilter<"itemproductsale"> | number
    item_id?: IntFilter<"itemproductsale"> | number
    option_group_id?: IntNullableFilter<"itemproductsale"> | number | null
    quantity?: FloatFilter<"itemproductsale"> | number
    additional_price?: FloatFilter<"itemproductsale"> | number
    price?: FloatFilter<"itemproductsale"> | number
    amount?: FloatNullableFilter<"itemproductsale"> | number | null
    observations?: StringNullableFilter<"itemproductsale"> | string | null
    productsale?: XOR<ProductsaleScalarRelationFilter, productsaleWhereInput>
    item?: XOR<ItemScalarRelationFilter, itemWhereInput>
    optiongroup?: XOR<OptiongroupNullableScalarRelationFilter, optiongroupWhereInput> | null
    itemitemproductsales?: ItemitemproductsaleListRelationFilter
  }, "id">

  export type itemproductsaleOrderByWithAggregationInput = {
    id?: SortOrder
    product_sale_id?: SortOrder
    item_id?: SortOrder
    option_group_id?: SortOrderInput | SortOrder
    quantity?: SortOrder
    additional_price?: SortOrder
    price?: SortOrder
    amount?: SortOrderInput | SortOrder
    observations?: SortOrderInput | SortOrder
    _count?: itemproductsaleCountOrderByAggregateInput
    _avg?: itemproductsaleAvgOrderByAggregateInput
    _max?: itemproductsaleMaxOrderByAggregateInput
    _min?: itemproductsaleMinOrderByAggregateInput
    _sum?: itemproductsaleSumOrderByAggregateInput
  }

  export type itemproductsaleScalarWhereWithAggregatesInput = {
    AND?: itemproductsaleScalarWhereWithAggregatesInput | itemproductsaleScalarWhereWithAggregatesInput[]
    OR?: itemproductsaleScalarWhereWithAggregatesInput[]
    NOT?: itemproductsaleScalarWhereWithAggregatesInput | itemproductsaleScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"itemproductsale"> | number
    product_sale_id?: IntWithAggregatesFilter<"itemproductsale"> | number
    item_id?: IntWithAggregatesFilter<"itemproductsale"> | number
    option_group_id?: IntNullableWithAggregatesFilter<"itemproductsale"> | number | null
    quantity?: FloatWithAggregatesFilter<"itemproductsale"> | number
    additional_price?: FloatWithAggregatesFilter<"itemproductsale"> | number
    price?: FloatWithAggregatesFilter<"itemproductsale"> | number
    amount?: FloatNullableWithAggregatesFilter<"itemproductsale"> | number | null
    observations?: StringNullableWithAggregatesFilter<"itemproductsale"> | string | null
  }

  export type itemitemproductsaleWhereInput = {
    AND?: itemitemproductsaleWhereInput | itemitemproductsaleWhereInput[]
    OR?: itemitemproductsaleWhereInput[]
    NOT?: itemitemproductsaleWhereInput | itemitemproductsaleWhereInput[]
    id?: IntFilter<"itemitemproductsale"> | number
    item_product_sale_id?: IntFilter<"itemitemproductsale"> | number
    item_id?: IntFilter<"itemitemproductsale"> | number
    option_group_id?: IntNullableFilter<"itemitemproductsale"> | number | null
    quantity?: FloatFilter<"itemitemproductsale"> | number
    additional_price?: FloatFilter<"itemitemproductsale"> | number
    price?: FloatFilter<"itemitemproductsale"> | number
    amount?: FloatNullableFilter<"itemitemproductsale"> | number | null
    itemproductsale?: XOR<ItemproductsaleScalarRelationFilter, itemproductsaleWhereInput>
    item?: XOR<ItemScalarRelationFilter, itemWhereInput>
    optiongroup?: XOR<OptiongroupNullableScalarRelationFilter, optiongroupWhereInput> | null
  }

  export type itemitemproductsaleOrderByWithRelationInput = {
    id?: SortOrder
    item_product_sale_id?: SortOrder
    item_id?: SortOrder
    option_group_id?: SortOrderInput | SortOrder
    quantity?: SortOrder
    additional_price?: SortOrder
    price?: SortOrder
    amount?: SortOrderInput | SortOrder
    itemproductsale?: itemproductsaleOrderByWithRelationInput
    item?: itemOrderByWithRelationInput
    optiongroup?: optiongroupOrderByWithRelationInput
  }

  export type itemitemproductsaleWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: itemitemproductsaleWhereInput | itemitemproductsaleWhereInput[]
    OR?: itemitemproductsaleWhereInput[]
    NOT?: itemitemproductsaleWhereInput | itemitemproductsaleWhereInput[]
    item_product_sale_id?: IntFilter<"itemitemproductsale"> | number
    item_id?: IntFilter<"itemitemproductsale"> | number
    option_group_id?: IntNullableFilter<"itemitemproductsale"> | number | null
    quantity?: FloatFilter<"itemitemproductsale"> | number
    additional_price?: FloatFilter<"itemitemproductsale"> | number
    price?: FloatFilter<"itemitemproductsale"> | number
    amount?: FloatNullableFilter<"itemitemproductsale"> | number | null
    itemproductsale?: XOR<ItemproductsaleScalarRelationFilter, itemproductsaleWhereInput>
    item?: XOR<ItemScalarRelationFilter, itemWhereInput>
    optiongroup?: XOR<OptiongroupNullableScalarRelationFilter, optiongroupWhereInput> | null
  }, "id">

  export type itemitemproductsaleOrderByWithAggregationInput = {
    id?: SortOrder
    item_product_sale_id?: SortOrder
    item_id?: SortOrder
    option_group_id?: SortOrderInput | SortOrder
    quantity?: SortOrder
    additional_price?: SortOrder
    price?: SortOrder
    amount?: SortOrderInput | SortOrder
    _count?: itemitemproductsaleCountOrderByAggregateInput
    _avg?: itemitemproductsaleAvgOrderByAggregateInput
    _max?: itemitemproductsaleMaxOrderByAggregateInput
    _min?: itemitemproductsaleMinOrderByAggregateInput
    _sum?: itemitemproductsaleSumOrderByAggregateInput
  }

  export type itemitemproductsaleScalarWhereWithAggregatesInput = {
    AND?: itemitemproductsaleScalarWhereWithAggregatesInput | itemitemproductsaleScalarWhereWithAggregatesInput[]
    OR?: itemitemproductsaleScalarWhereWithAggregatesInput[]
    NOT?: itemitemproductsaleScalarWhereWithAggregatesInput | itemitemproductsaleScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"itemitemproductsale"> | number
    item_product_sale_id?: IntWithAggregatesFilter<"itemitemproductsale"> | number
    item_id?: IntWithAggregatesFilter<"itemitemproductsale"> | number
    option_group_id?: IntNullableWithAggregatesFilter<"itemitemproductsale"> | number | null
    quantity?: FloatWithAggregatesFilter<"itemitemproductsale"> | number
    additional_price?: FloatWithAggregatesFilter<"itemitemproductsale"> | number
    price?: FloatWithAggregatesFilter<"itemitemproductsale"> | number
    amount?: FloatNullableWithAggregatesFilter<"itemitemproductsale"> | number | null
  }

  export type deliverysaleWhereInput = {
    AND?: deliverysaleWhereInput | deliverysaleWhereInput[]
    OR?: deliverysaleWhereInput[]
    NOT?: deliverysaleWhereInput | deliverysaleWhereInput[]
    id?: IntFilter<"deliverysale"> | number
    sale_id?: IntFilter<"deliverysale"> | number
    courier_id?: StringNullableFilter<"deliverysale"> | string | null
    courier_name?: StringNullableFilter<"deliverysale"> | string | null
    courier_phone?: StringNullableFilter<"deliverysale"> | string | null
    courier_type?: StringNullableFilter<"deliverysale"> | string | null
    delivered_by?: StringNullableFilter<"deliverysale"> | string | null
    delivery_type?: StringNullableFilter<"deliverysale"> | string | null
    status?: StringNullableFilter<"deliverysale"> | string | null
    delivery_fee?: FloatNullableFilter<"deliverysale"> | number | null
    courier_fee?: FloatNullableFilter<"deliverysale"> | number | null
    timing?: StringNullableFilter<"deliverysale"> | string | null
    mode?: StringNullableFilter<"deliverysale"> | string | null
    sale?: XOR<SaleScalarRelationFilter, saleWhereInput>
    deliveryaddresses?: DeliveryaddressListRelationFilter
  }

  export type deliverysaleOrderByWithRelationInput = {
    id?: SortOrder
    sale_id?: SortOrder
    courier_id?: SortOrderInput | SortOrder
    courier_name?: SortOrderInput | SortOrder
    courier_phone?: SortOrderInput | SortOrder
    courier_type?: SortOrderInput | SortOrder
    delivered_by?: SortOrderInput | SortOrder
    delivery_type?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    delivery_fee?: SortOrderInput | SortOrder
    courier_fee?: SortOrderInput | SortOrder
    timing?: SortOrderInput | SortOrder
    mode?: SortOrderInput | SortOrder
    sale?: saleOrderByWithRelationInput
    deliveryaddresses?: deliveryaddressOrderByRelationAggregateInput
  }

  export type deliverysaleWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: deliverysaleWhereInput | deliverysaleWhereInput[]
    OR?: deliverysaleWhereInput[]
    NOT?: deliverysaleWhereInput | deliverysaleWhereInput[]
    sale_id?: IntFilter<"deliverysale"> | number
    courier_id?: StringNullableFilter<"deliverysale"> | string | null
    courier_name?: StringNullableFilter<"deliverysale"> | string | null
    courier_phone?: StringNullableFilter<"deliverysale"> | string | null
    courier_type?: StringNullableFilter<"deliverysale"> | string | null
    delivered_by?: StringNullableFilter<"deliverysale"> | string | null
    delivery_type?: StringNullableFilter<"deliverysale"> | string | null
    status?: StringNullableFilter<"deliverysale"> | string | null
    delivery_fee?: FloatNullableFilter<"deliverysale"> | number | null
    courier_fee?: FloatNullableFilter<"deliverysale"> | number | null
    timing?: StringNullableFilter<"deliverysale"> | string | null
    mode?: StringNullableFilter<"deliverysale"> | string | null
    sale?: XOR<SaleScalarRelationFilter, saleWhereInput>
    deliveryaddresses?: DeliveryaddressListRelationFilter
  }, "id">

  export type deliverysaleOrderByWithAggregationInput = {
    id?: SortOrder
    sale_id?: SortOrder
    courier_id?: SortOrderInput | SortOrder
    courier_name?: SortOrderInput | SortOrder
    courier_phone?: SortOrderInput | SortOrder
    courier_type?: SortOrderInput | SortOrder
    delivered_by?: SortOrderInput | SortOrder
    delivery_type?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    delivery_fee?: SortOrderInput | SortOrder
    courier_fee?: SortOrderInput | SortOrder
    timing?: SortOrderInput | SortOrder
    mode?: SortOrderInput | SortOrder
    _count?: deliverysaleCountOrderByAggregateInput
    _avg?: deliverysaleAvgOrderByAggregateInput
    _max?: deliverysaleMaxOrderByAggregateInput
    _min?: deliverysaleMinOrderByAggregateInput
    _sum?: deliverysaleSumOrderByAggregateInput
  }

  export type deliverysaleScalarWhereWithAggregatesInput = {
    AND?: deliverysaleScalarWhereWithAggregatesInput | deliverysaleScalarWhereWithAggregatesInput[]
    OR?: deliverysaleScalarWhereWithAggregatesInput[]
    NOT?: deliverysaleScalarWhereWithAggregatesInput | deliverysaleScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"deliverysale"> | number
    sale_id?: IntWithAggregatesFilter<"deliverysale"> | number
    courier_id?: StringNullableWithAggregatesFilter<"deliverysale"> | string | null
    courier_name?: StringNullableWithAggregatesFilter<"deliverysale"> | string | null
    courier_phone?: StringNullableWithAggregatesFilter<"deliverysale"> | string | null
    courier_type?: StringNullableWithAggregatesFilter<"deliverysale"> | string | null
    delivered_by?: StringNullableWithAggregatesFilter<"deliverysale"> | string | null
    delivery_type?: StringNullableWithAggregatesFilter<"deliverysale"> | string | null
    status?: StringNullableWithAggregatesFilter<"deliverysale"> | string | null
    delivery_fee?: FloatNullableWithAggregatesFilter<"deliverysale"> | number | null
    courier_fee?: FloatNullableWithAggregatesFilter<"deliverysale"> | number | null
    timing?: StringNullableWithAggregatesFilter<"deliverysale"> | string | null
    mode?: StringNullableWithAggregatesFilter<"deliverysale"> | string | null
  }

  export type deliveryaddressWhereInput = {
    AND?: deliveryaddressWhereInput | deliveryaddressWhereInput[]
    OR?: deliveryaddressWhereInput[]
    NOT?: deliveryaddressWhereInput | deliveryaddressWhereInput[]
    id?: IntFilter<"deliveryaddress"> | number
    sale_id?: IntFilter<"deliveryaddress"> | number
    delivery_sale_id?: IntNullableFilter<"deliveryaddress"> | number | null
    street?: StringNullableFilter<"deliveryaddress"> | string | null
    number?: StringNullableFilter<"deliveryaddress"> | string | null
    complement?: StringNullableFilter<"deliveryaddress"> | string | null
    formatted_address?: StringNullableFilter<"deliveryaddress"> | string | null
    neighborhood?: StringNullableFilter<"deliveryaddress"> | string | null
    city?: StringNullableFilter<"deliveryaddress"> | string | null
    state?: StringNullableFilter<"deliveryaddress"> | string | null
    country?: StringNullableFilter<"deliveryaddress"> | string | null
    postal_code?: StringNullableFilter<"deliveryaddress"> | string | null
    reference?: StringNullableFilter<"deliveryaddress"> | string | null
    latitude?: FloatNullableFilter<"deliveryaddress"> | number | null
    longitude?: FloatNullableFilter<"deliveryaddress"> | number | null
    sale?: XOR<SaleScalarRelationFilter, saleWhereInput>
    deliverysale?: XOR<DeliverysaleNullableScalarRelationFilter, deliverysaleWhereInput> | null
  }

  export type deliveryaddressOrderByWithRelationInput = {
    id?: SortOrder
    sale_id?: SortOrder
    delivery_sale_id?: SortOrderInput | SortOrder
    street?: SortOrderInput | SortOrder
    number?: SortOrderInput | SortOrder
    complement?: SortOrderInput | SortOrder
    formatted_address?: SortOrderInput | SortOrder
    neighborhood?: SortOrderInput | SortOrder
    city?: SortOrderInput | SortOrder
    state?: SortOrderInput | SortOrder
    country?: SortOrderInput | SortOrder
    postal_code?: SortOrderInput | SortOrder
    reference?: SortOrderInput | SortOrder
    latitude?: SortOrderInput | SortOrder
    longitude?: SortOrderInput | SortOrder
    sale?: saleOrderByWithRelationInput
    deliverysale?: deliverysaleOrderByWithRelationInput
  }

  export type deliveryaddressWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: deliveryaddressWhereInput | deliveryaddressWhereInput[]
    OR?: deliveryaddressWhereInput[]
    NOT?: deliveryaddressWhereInput | deliveryaddressWhereInput[]
    sale_id?: IntFilter<"deliveryaddress"> | number
    delivery_sale_id?: IntNullableFilter<"deliveryaddress"> | number | null
    street?: StringNullableFilter<"deliveryaddress"> | string | null
    number?: StringNullableFilter<"deliveryaddress"> | string | null
    complement?: StringNullableFilter<"deliveryaddress"> | string | null
    formatted_address?: StringNullableFilter<"deliveryaddress"> | string | null
    neighborhood?: StringNullableFilter<"deliveryaddress"> | string | null
    city?: StringNullableFilter<"deliveryaddress"> | string | null
    state?: StringNullableFilter<"deliveryaddress"> | string | null
    country?: StringNullableFilter<"deliveryaddress"> | string | null
    postal_code?: StringNullableFilter<"deliveryaddress"> | string | null
    reference?: StringNullableFilter<"deliveryaddress"> | string | null
    latitude?: FloatNullableFilter<"deliveryaddress"> | number | null
    longitude?: FloatNullableFilter<"deliveryaddress"> | number | null
    sale?: XOR<SaleScalarRelationFilter, saleWhereInput>
    deliverysale?: XOR<DeliverysaleNullableScalarRelationFilter, deliverysaleWhereInput> | null
  }, "id">

  export type deliveryaddressOrderByWithAggregationInput = {
    id?: SortOrder
    sale_id?: SortOrder
    delivery_sale_id?: SortOrderInput | SortOrder
    street?: SortOrderInput | SortOrder
    number?: SortOrderInput | SortOrder
    complement?: SortOrderInput | SortOrder
    formatted_address?: SortOrderInput | SortOrder
    neighborhood?: SortOrderInput | SortOrder
    city?: SortOrderInput | SortOrder
    state?: SortOrderInput | SortOrder
    country?: SortOrderInput | SortOrder
    postal_code?: SortOrderInput | SortOrder
    reference?: SortOrderInput | SortOrder
    latitude?: SortOrderInput | SortOrder
    longitude?: SortOrderInput | SortOrder
    _count?: deliveryaddressCountOrderByAggregateInput
    _avg?: deliveryaddressAvgOrderByAggregateInput
    _max?: deliveryaddressMaxOrderByAggregateInput
    _min?: deliveryaddressMinOrderByAggregateInput
    _sum?: deliveryaddressSumOrderByAggregateInput
  }

  export type deliveryaddressScalarWhereWithAggregatesInput = {
    AND?: deliveryaddressScalarWhereWithAggregatesInput | deliveryaddressScalarWhereWithAggregatesInput[]
    OR?: deliveryaddressScalarWhereWithAggregatesInput[]
    NOT?: deliveryaddressScalarWhereWithAggregatesInput | deliveryaddressScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"deliveryaddress"> | number
    sale_id?: IntWithAggregatesFilter<"deliveryaddress"> | number
    delivery_sale_id?: IntNullableWithAggregatesFilter<"deliveryaddress"> | number | null
    street?: StringNullableWithAggregatesFilter<"deliveryaddress"> | string | null
    number?: StringNullableWithAggregatesFilter<"deliveryaddress"> | string | null
    complement?: StringNullableWithAggregatesFilter<"deliveryaddress"> | string | null
    formatted_address?: StringNullableWithAggregatesFilter<"deliveryaddress"> | string | null
    neighborhood?: StringNullableWithAggregatesFilter<"deliveryaddress"> | string | null
    city?: StringNullableWithAggregatesFilter<"deliveryaddress"> | string | null
    state?: StringNullableWithAggregatesFilter<"deliveryaddress"> | string | null
    country?: StringNullableWithAggregatesFilter<"deliveryaddress"> | string | null
    postal_code?: StringNullableWithAggregatesFilter<"deliveryaddress"> | string | null
    reference?: StringNullableWithAggregatesFilter<"deliveryaddress"> | string | null
    latitude?: FloatNullableWithAggregatesFilter<"deliveryaddress"> | number | null
    longitude?: FloatNullableWithAggregatesFilter<"deliveryaddress"> | number | null
  }

  export type paymenttypeWhereInput = {
    AND?: paymenttypeWhereInput | paymenttypeWhereInput[]
    OR?: paymenttypeWhereInput[]
    NOT?: paymenttypeWhereInput | paymenttypeWhereInput[]
    id?: IntFilter<"paymenttype"> | number
    brand_id?: IntNullableFilter<"paymenttype"> | number | null
    description?: StringFilter<"paymenttype"> | string
    brand?: XOR<BrandNullableScalarRelationFilter, brandWhereInput> | null
    payments?: PaymentListRelationFilter
  }

  export type paymenttypeOrderByWithRelationInput = {
    id?: SortOrder
    brand_id?: SortOrderInput | SortOrder
    description?: SortOrder
    brand?: brandOrderByWithRelationInput
    payments?: paymentOrderByRelationAggregateInput
  }

  export type paymenttypeWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: paymenttypeWhereInput | paymenttypeWhereInput[]
    OR?: paymenttypeWhereInput[]
    NOT?: paymenttypeWhereInput | paymenttypeWhereInput[]
    brand_id?: IntNullableFilter<"paymenttype"> | number | null
    description?: StringFilter<"paymenttype"> | string
    brand?: XOR<BrandNullableScalarRelationFilter, brandWhereInput> | null
    payments?: PaymentListRelationFilter
  }, "id">

  export type paymenttypeOrderByWithAggregationInput = {
    id?: SortOrder
    brand_id?: SortOrderInput | SortOrder
    description?: SortOrder
    _count?: paymenttypeCountOrderByAggregateInput
    _avg?: paymenttypeAvgOrderByAggregateInput
    _max?: paymenttypeMaxOrderByAggregateInput
    _min?: paymenttypeMinOrderByAggregateInput
    _sum?: paymenttypeSumOrderByAggregateInput
  }

  export type paymenttypeScalarWhereWithAggregatesInput = {
    AND?: paymenttypeScalarWhereWithAggregatesInput | paymenttypeScalarWhereWithAggregatesInput[]
    OR?: paymenttypeScalarWhereWithAggregatesInput[]
    NOT?: paymenttypeScalarWhereWithAggregatesInput | paymenttypeScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"paymenttype"> | number
    brand_id?: IntNullableWithAggregatesFilter<"paymenttype"> | number | null
    description?: StringWithAggregatesFilter<"paymenttype"> | string
  }

  export type paymentWhereInput = {
    AND?: paymentWhereInput | paymentWhereInput[]
    OR?: paymentWhereInput[]
    NOT?: paymentWhereInput | paymentWhereInput[]
    id?: IntFilter<"payment"> | number
    sale_id?: IntFilter<"payment"> | number
    payment_type_id?: IntNullableFilter<"payment"> | number | null
    value?: DecimalFilter<"payment"> | Decimal | DecimalJsLike | number | string
    is_online?: BoolNullableFilter<"payment"> | boolean | null
    description?: StringNullableFilter<"payment"> | string | null
    currency?: StringNullableFilter<"payment"> | string | null
    sale?: XOR<SaleScalarRelationFilter, saleWhereInput>
    paymenttype?: XOR<PaymenttypeNullableScalarRelationFilter, paymenttypeWhereInput> | null
  }

  export type paymentOrderByWithRelationInput = {
    id?: SortOrder
    sale_id?: SortOrder
    payment_type_id?: SortOrderInput | SortOrder
    value?: SortOrder
    is_online?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    currency?: SortOrderInput | SortOrder
    sale?: saleOrderByWithRelationInput
    paymenttype?: paymenttypeOrderByWithRelationInput
  }

  export type paymentWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: paymentWhereInput | paymentWhereInput[]
    OR?: paymentWhereInput[]
    NOT?: paymentWhereInput | paymentWhereInput[]
    sale_id?: IntFilter<"payment"> | number
    payment_type_id?: IntNullableFilter<"payment"> | number | null
    value?: DecimalFilter<"payment"> | Decimal | DecimalJsLike | number | string
    is_online?: BoolNullableFilter<"payment"> | boolean | null
    description?: StringNullableFilter<"payment"> | string | null
    currency?: StringNullableFilter<"payment"> | string | null
    sale?: XOR<SaleScalarRelationFilter, saleWhereInput>
    paymenttype?: XOR<PaymenttypeNullableScalarRelationFilter, paymenttypeWhereInput> | null
  }, "id">

  export type paymentOrderByWithAggregationInput = {
    id?: SortOrder
    sale_id?: SortOrder
    payment_type_id?: SortOrderInput | SortOrder
    value?: SortOrder
    is_online?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    currency?: SortOrderInput | SortOrder
    _count?: paymentCountOrderByAggregateInput
    _avg?: paymentAvgOrderByAggregateInput
    _max?: paymentMaxOrderByAggregateInput
    _min?: paymentMinOrderByAggregateInput
    _sum?: paymentSumOrderByAggregateInput
  }

  export type paymentScalarWhereWithAggregatesInput = {
    AND?: paymentScalarWhereWithAggregatesInput | paymentScalarWhereWithAggregatesInput[]
    OR?: paymentScalarWhereWithAggregatesInput[]
    NOT?: paymentScalarWhereWithAggregatesInput | paymentScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"payment"> | number
    sale_id?: IntWithAggregatesFilter<"payment"> | number
    payment_type_id?: IntNullableWithAggregatesFilter<"payment"> | number | null
    value?: DecimalWithAggregatesFilter<"payment"> | Decimal | DecimalJsLike | number | string
    is_online?: BoolNullableWithAggregatesFilter<"payment"> | boolean | null
    description?: StringNullableWithAggregatesFilter<"payment"> | string | null
    currency?: StringNullableWithAggregatesFilter<"payment"> | string | null
  }

  export type couponWhereInput = {
    AND?: couponWhereInput | couponWhereInput[]
    OR?: couponWhereInput[]
    NOT?: couponWhereInput | couponWhereInput[]
    id?: IntFilter<"coupon"> | number
    brand_id?: IntNullableFilter<"coupon"> | number | null
    code?: StringFilter<"coupon"> | string
    discount_type?: StringNullableFilter<"coupon"> | string | null
    discount_value?: DecimalNullableFilter<"coupon"> | Decimal | DecimalJsLike | number | string | null
    is_active?: BoolNullableFilter<"coupon"> | boolean | null
    valid_from?: DateTimeNullableFilter<"coupon"> | Date | string | null
    valid_until?: DateTimeNullableFilter<"coupon"> | Date | string | null
    brand?: XOR<BrandNullableScalarRelationFilter, brandWhereInput> | null
    couponsales?: CouponsaleListRelationFilter
  }

  export type couponOrderByWithRelationInput = {
    id?: SortOrder
    brand_id?: SortOrderInput | SortOrder
    code?: SortOrder
    discount_type?: SortOrderInput | SortOrder
    discount_value?: SortOrderInput | SortOrder
    is_active?: SortOrderInput | SortOrder
    valid_from?: SortOrderInput | SortOrder
    valid_until?: SortOrderInput | SortOrder
    brand?: brandOrderByWithRelationInput
    couponsales?: couponsaleOrderByRelationAggregateInput
  }

  export type couponWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: couponWhereInput | couponWhereInput[]
    OR?: couponWhereInput[]
    NOT?: couponWhereInput | couponWhereInput[]
    brand_id?: IntNullableFilter<"coupon"> | number | null
    code?: StringFilter<"coupon"> | string
    discount_type?: StringNullableFilter<"coupon"> | string | null
    discount_value?: DecimalNullableFilter<"coupon"> | Decimal | DecimalJsLike | number | string | null
    is_active?: BoolNullableFilter<"coupon"> | boolean | null
    valid_from?: DateTimeNullableFilter<"coupon"> | Date | string | null
    valid_until?: DateTimeNullableFilter<"coupon"> | Date | string | null
    brand?: XOR<BrandNullableScalarRelationFilter, brandWhereInput> | null
    couponsales?: CouponsaleListRelationFilter
  }, "id">

  export type couponOrderByWithAggregationInput = {
    id?: SortOrder
    brand_id?: SortOrderInput | SortOrder
    code?: SortOrder
    discount_type?: SortOrderInput | SortOrder
    discount_value?: SortOrderInput | SortOrder
    is_active?: SortOrderInput | SortOrder
    valid_from?: SortOrderInput | SortOrder
    valid_until?: SortOrderInput | SortOrder
    _count?: couponCountOrderByAggregateInput
    _avg?: couponAvgOrderByAggregateInput
    _max?: couponMaxOrderByAggregateInput
    _min?: couponMinOrderByAggregateInput
    _sum?: couponSumOrderByAggregateInput
  }

  export type couponScalarWhereWithAggregatesInput = {
    AND?: couponScalarWhereWithAggregatesInput | couponScalarWhereWithAggregatesInput[]
    OR?: couponScalarWhereWithAggregatesInput[]
    NOT?: couponScalarWhereWithAggregatesInput | couponScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"coupon"> | number
    brand_id?: IntNullableWithAggregatesFilter<"coupon"> | number | null
    code?: StringWithAggregatesFilter<"coupon"> | string
    discount_type?: StringNullableWithAggregatesFilter<"coupon"> | string | null
    discount_value?: DecimalNullableWithAggregatesFilter<"coupon"> | Decimal | DecimalJsLike | number | string | null
    is_active?: BoolNullableWithAggregatesFilter<"coupon"> | boolean | null
    valid_from?: DateTimeNullableWithAggregatesFilter<"coupon"> | Date | string | null
    valid_until?: DateTimeNullableWithAggregatesFilter<"coupon"> | Date | string | null
  }

  export type couponsaleWhereInput = {
    AND?: couponsaleWhereInput | couponsaleWhereInput[]
    OR?: couponsaleWhereInput[]
    NOT?: couponsaleWhereInput | couponsaleWhereInput[]
    id?: IntFilter<"couponsale"> | number
    sale_id?: IntNullableFilter<"couponsale"> | number | null
    coupon_id?: IntNullableFilter<"couponsale"> | number | null
    value?: FloatNullableFilter<"couponsale"> | number | null
    target?: StringNullableFilter<"couponsale"> | string | null
    sponsorship?: StringNullableFilter<"couponsale"> | string | null
    sale?: XOR<SaleNullableScalarRelationFilter, saleWhereInput> | null
    coupon?: XOR<CouponNullableScalarRelationFilter, couponWhereInput> | null
  }

  export type couponsaleOrderByWithRelationInput = {
    id?: SortOrder
    sale_id?: SortOrderInput | SortOrder
    coupon_id?: SortOrderInput | SortOrder
    value?: SortOrderInput | SortOrder
    target?: SortOrderInput | SortOrder
    sponsorship?: SortOrderInput | SortOrder
    sale?: saleOrderByWithRelationInput
    coupon?: couponOrderByWithRelationInput
  }

  export type couponsaleWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: couponsaleWhereInput | couponsaleWhereInput[]
    OR?: couponsaleWhereInput[]
    NOT?: couponsaleWhereInput | couponsaleWhereInput[]
    sale_id?: IntNullableFilter<"couponsale"> | number | null
    coupon_id?: IntNullableFilter<"couponsale"> | number | null
    value?: FloatNullableFilter<"couponsale"> | number | null
    target?: StringNullableFilter<"couponsale"> | string | null
    sponsorship?: StringNullableFilter<"couponsale"> | string | null
    sale?: XOR<SaleNullableScalarRelationFilter, saleWhereInput> | null
    coupon?: XOR<CouponNullableScalarRelationFilter, couponWhereInput> | null
  }, "id">

  export type couponsaleOrderByWithAggregationInput = {
    id?: SortOrder
    sale_id?: SortOrderInput | SortOrder
    coupon_id?: SortOrderInput | SortOrder
    value?: SortOrderInput | SortOrder
    target?: SortOrderInput | SortOrder
    sponsorship?: SortOrderInput | SortOrder
    _count?: couponsaleCountOrderByAggregateInput
    _avg?: couponsaleAvgOrderByAggregateInput
    _max?: couponsaleMaxOrderByAggregateInput
    _min?: couponsaleMinOrderByAggregateInput
    _sum?: couponsaleSumOrderByAggregateInput
  }

  export type couponsaleScalarWhereWithAggregatesInput = {
    AND?: couponsaleScalarWhereWithAggregatesInput | couponsaleScalarWhereWithAggregatesInput[]
    OR?: couponsaleScalarWhereWithAggregatesInput[]
    NOT?: couponsaleScalarWhereWithAggregatesInput | couponsaleScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"couponsale"> | number
    sale_id?: IntNullableWithAggregatesFilter<"couponsale"> | number | null
    coupon_id?: IntNullableWithAggregatesFilter<"couponsale"> | number | null
    value?: FloatNullableWithAggregatesFilter<"couponsale"> | number | null
    target?: StringNullableWithAggregatesFilter<"couponsale"> | string | null
    sponsorship?: StringNullableWithAggregatesFilter<"couponsale"> | string | null
  }

  export type brandCreateInput = {
    name: string
    created_at?: Date | string | null
    subbrands?: subbrandCreateNestedManyWithoutBrandInput
    stores?: storeCreateNestedManyWithoutBrandInput
    channels?: channelCreateNestedManyWithoutBrandInput
    categories?: categoryCreateNestedManyWithoutBrandInput
    products?: productCreateNestedManyWithoutBrandInput
    optiongroups?: optiongroupCreateNestedManyWithoutBrandInput
    items?: itemCreateNestedManyWithoutBrandInput
    paymenttypes?: paymenttypeCreateNestedManyWithoutBrandInput
    coupons?: couponCreateNestedManyWithoutBrandInput
  }

  export type brandUncheckedCreateInput = {
    id?: number
    name: string
    created_at?: Date | string | null
    subbrands?: subbrandUncheckedCreateNestedManyWithoutBrandInput
    stores?: storeUncheckedCreateNestedManyWithoutBrandInput
    channels?: channelUncheckedCreateNestedManyWithoutBrandInput
    categories?: categoryUncheckedCreateNestedManyWithoutBrandInput
    products?: productUncheckedCreateNestedManyWithoutBrandInput
    optiongroups?: optiongroupUncheckedCreateNestedManyWithoutBrandInput
    items?: itemUncheckedCreateNestedManyWithoutBrandInput
    paymenttypes?: paymenttypeUncheckedCreateNestedManyWithoutBrandInput
    coupons?: couponUncheckedCreateNestedManyWithoutBrandInput
  }

  export type brandUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subbrands?: subbrandUpdateManyWithoutBrandNestedInput
    stores?: storeUpdateManyWithoutBrandNestedInput
    channels?: channelUpdateManyWithoutBrandNestedInput
    categories?: categoryUpdateManyWithoutBrandNestedInput
    products?: productUpdateManyWithoutBrandNestedInput
    optiongroups?: optiongroupUpdateManyWithoutBrandNestedInput
    items?: itemUpdateManyWithoutBrandNestedInput
    paymenttypes?: paymenttypeUpdateManyWithoutBrandNestedInput
    coupons?: couponUpdateManyWithoutBrandNestedInput
  }

  export type brandUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subbrands?: subbrandUncheckedUpdateManyWithoutBrandNestedInput
    stores?: storeUncheckedUpdateManyWithoutBrandNestedInput
    channels?: channelUncheckedUpdateManyWithoutBrandNestedInput
    categories?: categoryUncheckedUpdateManyWithoutBrandNestedInput
    products?: productUncheckedUpdateManyWithoutBrandNestedInput
    optiongroups?: optiongroupUncheckedUpdateManyWithoutBrandNestedInput
    items?: itemUncheckedUpdateManyWithoutBrandNestedInput
    paymenttypes?: paymenttypeUncheckedUpdateManyWithoutBrandNestedInput
    coupons?: couponUncheckedUpdateManyWithoutBrandNestedInput
  }

  export type brandCreateManyInput = {
    id?: number
    name: string
    created_at?: Date | string | null
  }

  export type brandUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type brandUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type subbrandCreateInput = {
    name: string
    created_at?: Date | string | null
    brand: brandCreateNestedOneWithoutSubbrandsInput
    stores?: storeCreateNestedManyWithoutSubbrandInput
    categories?: categoryCreateNestedManyWithoutSubbrandInput
    products?: productCreateNestedManyWithoutSubbrandInput
    optiongroups?: optiongroupCreateNestedManyWithoutSubbrandInput
    items?: itemCreateNestedManyWithoutSubbrandInput
    customers?: customerCreateNestedManyWithoutSubbrandInput
    sales?: saleCreateNestedManyWithoutSubbrandInput
  }

  export type subbrandUncheckedCreateInput = {
    id?: number
    brand_id: number
    name: string
    created_at?: Date | string | null
    stores?: storeUncheckedCreateNestedManyWithoutSubbrandInput
    categories?: categoryUncheckedCreateNestedManyWithoutSubbrandInput
    products?: productUncheckedCreateNestedManyWithoutSubbrandInput
    optiongroups?: optiongroupUncheckedCreateNestedManyWithoutSubbrandInput
    items?: itemUncheckedCreateNestedManyWithoutSubbrandInput
    customers?: customerUncheckedCreateNestedManyWithoutSubbrandInput
    sales?: saleUncheckedCreateNestedManyWithoutSubbrandInput
  }

  export type subbrandUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    brand?: brandUpdateOneRequiredWithoutSubbrandsNestedInput
    stores?: storeUpdateManyWithoutSubbrandNestedInput
    categories?: categoryUpdateManyWithoutSubbrandNestedInput
    products?: productUpdateManyWithoutSubbrandNestedInput
    optiongroups?: optiongroupUpdateManyWithoutSubbrandNestedInput
    items?: itemUpdateManyWithoutSubbrandNestedInput
    customers?: customerUpdateManyWithoutSubbrandNestedInput
    sales?: saleUpdateManyWithoutSubbrandNestedInput
  }

  export type subbrandUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    brand_id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stores?: storeUncheckedUpdateManyWithoutSubbrandNestedInput
    categories?: categoryUncheckedUpdateManyWithoutSubbrandNestedInput
    products?: productUncheckedUpdateManyWithoutSubbrandNestedInput
    optiongroups?: optiongroupUncheckedUpdateManyWithoutSubbrandNestedInput
    items?: itemUncheckedUpdateManyWithoutSubbrandNestedInput
    customers?: customerUncheckedUpdateManyWithoutSubbrandNestedInput
    sales?: saleUncheckedUpdateManyWithoutSubbrandNestedInput
  }

  export type subbrandCreateManyInput = {
    id?: number
    brand_id: number
    name: string
    created_at?: Date | string | null
  }

  export type subbrandUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type subbrandUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    brand_id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type storeCreateInput = {
    name: string
    city?: string | null
    state?: string | null
    district?: string | null
    address_street?: string | null
    address_number?: number | null
    zipcode?: string | null
    latitude?: Decimal | DecimalJsLike | number | string | null
    longitude?: Decimal | DecimalJsLike | number | string | null
    is_active?: boolean | null
    is_own?: boolean | null
    is_holding?: boolean | null
    creation_date?: Date | string | null
    created_at?: Date | string | null
    brand: brandCreateNestedOneWithoutStoresInput
    subbrand?: subbrandCreateNestedOneWithoutStoresInput
    customers?: customerCreateNestedManyWithoutStoreInput
    sales?: saleCreateNestedManyWithoutStoreInput
  }

  export type storeUncheckedCreateInput = {
    id?: number
    brand_id: number
    sub_brand_id?: number | null
    name: string
    city?: string | null
    state?: string | null
    district?: string | null
    address_street?: string | null
    address_number?: number | null
    zipcode?: string | null
    latitude?: Decimal | DecimalJsLike | number | string | null
    longitude?: Decimal | DecimalJsLike | number | string | null
    is_active?: boolean | null
    is_own?: boolean | null
    is_holding?: boolean | null
    creation_date?: Date | string | null
    created_at?: Date | string | null
    customers?: customerUncheckedCreateNestedManyWithoutStoreInput
    sales?: saleUncheckedCreateNestedManyWithoutStoreInput
  }

  export type storeUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    district?: NullableStringFieldUpdateOperationsInput | string | null
    address_street?: NullableStringFieldUpdateOperationsInput | string | null
    address_number?: NullableIntFieldUpdateOperationsInput | number | null
    zipcode?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    longitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_own?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_holding?: NullableBoolFieldUpdateOperationsInput | boolean | null
    creation_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    brand?: brandUpdateOneRequiredWithoutStoresNestedInput
    subbrand?: subbrandUpdateOneWithoutStoresNestedInput
    customers?: customerUpdateManyWithoutStoreNestedInput
    sales?: saleUpdateManyWithoutStoreNestedInput
  }

  export type storeUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    brand_id?: IntFieldUpdateOperationsInput | number
    sub_brand_id?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    district?: NullableStringFieldUpdateOperationsInput | string | null
    address_street?: NullableStringFieldUpdateOperationsInput | string | null
    address_number?: NullableIntFieldUpdateOperationsInput | number | null
    zipcode?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    longitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_own?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_holding?: NullableBoolFieldUpdateOperationsInput | boolean | null
    creation_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    customers?: customerUncheckedUpdateManyWithoutStoreNestedInput
    sales?: saleUncheckedUpdateManyWithoutStoreNestedInput
  }

  export type storeCreateManyInput = {
    id?: number
    brand_id: number
    sub_brand_id?: number | null
    name: string
    city?: string | null
    state?: string | null
    district?: string | null
    address_street?: string | null
    address_number?: number | null
    zipcode?: string | null
    latitude?: Decimal | DecimalJsLike | number | string | null
    longitude?: Decimal | DecimalJsLike | number | string | null
    is_active?: boolean | null
    is_own?: boolean | null
    is_holding?: boolean | null
    creation_date?: Date | string | null
    created_at?: Date | string | null
  }

  export type storeUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    district?: NullableStringFieldUpdateOperationsInput | string | null
    address_street?: NullableStringFieldUpdateOperationsInput | string | null
    address_number?: NullableIntFieldUpdateOperationsInput | number | null
    zipcode?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    longitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_own?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_holding?: NullableBoolFieldUpdateOperationsInput | boolean | null
    creation_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type storeUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    brand_id?: IntFieldUpdateOperationsInput | number
    sub_brand_id?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    district?: NullableStringFieldUpdateOperationsInput | string | null
    address_street?: NullableStringFieldUpdateOperationsInput | string | null
    address_number?: NullableIntFieldUpdateOperationsInput | number | null
    zipcode?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    longitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_own?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_holding?: NullableBoolFieldUpdateOperationsInput | boolean | null
    creation_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type channelCreateInput = {
    name: string
    description?: string | null
    type?: string | null
    created_at?: Date | string | null
    brand: brandCreateNestedOneWithoutChannelsInput
    sales?: saleCreateNestedManyWithoutChannelInput
  }

  export type channelUncheckedCreateInput = {
    id?: number
    brand_id: number
    name: string
    description?: string | null
    type?: string | null
    created_at?: Date | string | null
    sales?: saleUncheckedCreateNestedManyWithoutChannelInput
  }

  export type channelUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    brand?: brandUpdateOneRequiredWithoutChannelsNestedInput
    sales?: saleUpdateManyWithoutChannelNestedInput
  }

  export type channelUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    brand_id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sales?: saleUncheckedUpdateManyWithoutChannelNestedInput
  }

  export type channelCreateManyInput = {
    id?: number
    brand_id: number
    name: string
    description?: string | null
    type?: string | null
    created_at?: Date | string | null
  }

  export type channelUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type channelUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    brand_id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type categoryCreateInput = {
    name: string
    type?: string | null
    pos_uuid?: string | null
    deleted_at?: Date | string | null
    brand: brandCreateNestedOneWithoutCategoriesInput
    subbrand?: subbrandCreateNestedOneWithoutCategoriesInput
    products?: productCreateNestedManyWithoutCategoryInput
    optiongroups?: optiongroupCreateNestedManyWithoutCategoryInput
    items?: itemCreateNestedManyWithoutCategoryInput
  }

  export type categoryUncheckedCreateInput = {
    id?: number
    brand_id: number
    sub_brand_id?: number | null
    name: string
    type?: string | null
    pos_uuid?: string | null
    deleted_at?: Date | string | null
    products?: productUncheckedCreateNestedManyWithoutCategoryInput
    optiongroups?: optiongroupUncheckedCreateNestedManyWithoutCategoryInput
    items?: itemUncheckedCreateNestedManyWithoutCategoryInput
  }

  export type categoryUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    pos_uuid?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    brand?: brandUpdateOneRequiredWithoutCategoriesNestedInput
    subbrand?: subbrandUpdateOneWithoutCategoriesNestedInput
    products?: productUpdateManyWithoutCategoryNestedInput
    optiongroups?: optiongroupUpdateManyWithoutCategoryNestedInput
    items?: itemUpdateManyWithoutCategoryNestedInput
  }

  export type categoryUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    brand_id?: IntFieldUpdateOperationsInput | number
    sub_brand_id?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    pos_uuid?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    products?: productUncheckedUpdateManyWithoutCategoryNestedInput
    optiongroups?: optiongroupUncheckedUpdateManyWithoutCategoryNestedInput
    items?: itemUncheckedUpdateManyWithoutCategoryNestedInput
  }

  export type categoryCreateManyInput = {
    id?: number
    brand_id: number
    sub_brand_id?: number | null
    name: string
    type?: string | null
    pos_uuid?: string | null
    deleted_at?: Date | string | null
  }

  export type categoryUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    pos_uuid?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type categoryUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    brand_id?: IntFieldUpdateOperationsInput | number
    sub_brand_id?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    pos_uuid?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type productCreateInput = {
    name: string
    pos_uuid?: string | null
    deleted_at?: Date | string | null
    brand: brandCreateNestedOneWithoutProductsInput
    subbrand?: subbrandCreateNestedOneWithoutProductsInput
    category?: categoryCreateNestedOneWithoutProductsInput
    productsales?: productsaleCreateNestedManyWithoutProductInput
  }

  export type productUncheckedCreateInput = {
    id?: number
    brand_id: number
    sub_brand_id?: number | null
    category_id?: number | null
    name: string
    pos_uuid?: string | null
    deleted_at?: Date | string | null
    productsales?: productsaleUncheckedCreateNestedManyWithoutProductInput
  }

  export type productUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    pos_uuid?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    brand?: brandUpdateOneRequiredWithoutProductsNestedInput
    subbrand?: subbrandUpdateOneWithoutProductsNestedInput
    category?: categoryUpdateOneWithoutProductsNestedInput
    productsales?: productsaleUpdateManyWithoutProductNestedInput
  }

  export type productUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    brand_id?: IntFieldUpdateOperationsInput | number
    sub_brand_id?: NullableIntFieldUpdateOperationsInput | number | null
    category_id?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    pos_uuid?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    productsales?: productsaleUncheckedUpdateManyWithoutProductNestedInput
  }

  export type productCreateManyInput = {
    id?: number
    brand_id: number
    sub_brand_id?: number | null
    category_id?: number | null
    name: string
    pos_uuid?: string | null
    deleted_at?: Date | string | null
  }

  export type productUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    pos_uuid?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type productUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    brand_id?: IntFieldUpdateOperationsInput | number
    sub_brand_id?: NullableIntFieldUpdateOperationsInput | number | null
    category_id?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    pos_uuid?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type optiongroupCreateInput = {
    name: string
    pos_uuid?: string | null
    deleted_at?: Date | string | null
    brand: brandCreateNestedOneWithoutOptiongroupsInput
    subbrand?: subbrandCreateNestedOneWithoutOptiongroupsInput
    category?: categoryCreateNestedOneWithoutOptiongroupsInput
    itemproductsales?: itemproductsaleCreateNestedManyWithoutOptiongroupInput
    itemitemproductsales?: itemitemproductsaleCreateNestedManyWithoutOptiongroupInput
  }

  export type optiongroupUncheckedCreateInput = {
    id?: number
    brand_id: number
    sub_brand_id?: number | null
    category_id?: number | null
    name: string
    pos_uuid?: string | null
    deleted_at?: Date | string | null
    itemproductsales?: itemproductsaleUncheckedCreateNestedManyWithoutOptiongroupInput
    itemitemproductsales?: itemitemproductsaleUncheckedCreateNestedManyWithoutOptiongroupInput
  }

  export type optiongroupUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    pos_uuid?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    brand?: brandUpdateOneRequiredWithoutOptiongroupsNestedInput
    subbrand?: subbrandUpdateOneWithoutOptiongroupsNestedInput
    category?: categoryUpdateOneWithoutOptiongroupsNestedInput
    itemproductsales?: itemproductsaleUpdateManyWithoutOptiongroupNestedInput
    itemitemproductsales?: itemitemproductsaleUpdateManyWithoutOptiongroupNestedInput
  }

  export type optiongroupUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    brand_id?: IntFieldUpdateOperationsInput | number
    sub_brand_id?: NullableIntFieldUpdateOperationsInput | number | null
    category_id?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    pos_uuid?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    itemproductsales?: itemproductsaleUncheckedUpdateManyWithoutOptiongroupNestedInput
    itemitemproductsales?: itemitemproductsaleUncheckedUpdateManyWithoutOptiongroupNestedInput
  }

  export type optiongroupCreateManyInput = {
    id?: number
    brand_id: number
    sub_brand_id?: number | null
    category_id?: number | null
    name: string
    pos_uuid?: string | null
    deleted_at?: Date | string | null
  }

  export type optiongroupUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    pos_uuid?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type optiongroupUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    brand_id?: IntFieldUpdateOperationsInput | number
    sub_brand_id?: NullableIntFieldUpdateOperationsInput | number | null
    category_id?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    pos_uuid?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type itemCreateInput = {
    name: string
    pos_uuid?: string | null
    deleted_at?: Date | string | null
    brand: brandCreateNestedOneWithoutItemsInput
    subbrand?: subbrandCreateNestedOneWithoutItemsInput
    category?: categoryCreateNestedOneWithoutItemsInput
    itemproductsales?: itemproductsaleCreateNestedManyWithoutItemInput
    itemitemproductsales?: itemitemproductsaleCreateNestedManyWithoutItemInput
  }

  export type itemUncheckedCreateInput = {
    id?: number
    brand_id: number
    sub_brand_id?: number | null
    category_id?: number | null
    name: string
    pos_uuid?: string | null
    deleted_at?: Date | string | null
    itemproductsales?: itemproductsaleUncheckedCreateNestedManyWithoutItemInput
    itemitemproductsales?: itemitemproductsaleUncheckedCreateNestedManyWithoutItemInput
  }

  export type itemUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    pos_uuid?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    brand?: brandUpdateOneRequiredWithoutItemsNestedInput
    subbrand?: subbrandUpdateOneWithoutItemsNestedInput
    category?: categoryUpdateOneWithoutItemsNestedInput
    itemproductsales?: itemproductsaleUpdateManyWithoutItemNestedInput
    itemitemproductsales?: itemitemproductsaleUpdateManyWithoutItemNestedInput
  }

  export type itemUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    brand_id?: IntFieldUpdateOperationsInput | number
    sub_brand_id?: NullableIntFieldUpdateOperationsInput | number | null
    category_id?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    pos_uuid?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    itemproductsales?: itemproductsaleUncheckedUpdateManyWithoutItemNestedInput
    itemitemproductsales?: itemitemproductsaleUncheckedUpdateManyWithoutItemNestedInput
  }

  export type itemCreateManyInput = {
    id?: number
    brand_id: number
    sub_brand_id?: number | null
    category_id?: number | null
    name: string
    pos_uuid?: string | null
    deleted_at?: Date | string | null
  }

  export type itemUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    pos_uuid?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type itemUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    brand_id?: IntFieldUpdateOperationsInput | number
    sub_brand_id?: NullableIntFieldUpdateOperationsInput | number | null
    category_id?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    pos_uuid?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type customerCreateInput = {
    customer_name?: string | null
    email?: string | null
    phone_number?: string | null
    cpf?: string | null
    birth_date?: Date | string | null
    gender?: string | null
    registration_origin?: string | null
    agree_terms?: boolean | null
    receive_promotions_email?: boolean | null
    receive_promotions_sms?: boolean | null
    created_at?: Date | string | null
    store?: storeCreateNestedOneWithoutCustomersInput
    subbrand?: subbrandCreateNestedOneWithoutCustomersInput
    sales?: saleCreateNestedManyWithoutCustomerInput
  }

  export type customerUncheckedCreateInput = {
    id?: number
    customer_name?: string | null
    email?: string | null
    phone_number?: string | null
    cpf?: string | null
    birth_date?: Date | string | null
    gender?: string | null
    store_id?: number | null
    sub_brand_id?: number | null
    registration_origin?: string | null
    agree_terms?: boolean | null
    receive_promotions_email?: boolean | null
    receive_promotions_sms?: boolean | null
    created_at?: Date | string | null
    sales?: saleUncheckedCreateNestedManyWithoutCustomerInput
  }

  export type customerUpdateInput = {
    customer_name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    cpf?: NullableStringFieldUpdateOperationsInput | string | null
    birth_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    registration_origin?: NullableStringFieldUpdateOperationsInput | string | null
    agree_terms?: NullableBoolFieldUpdateOperationsInput | boolean | null
    receive_promotions_email?: NullableBoolFieldUpdateOperationsInput | boolean | null
    receive_promotions_sms?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    store?: storeUpdateOneWithoutCustomersNestedInput
    subbrand?: subbrandUpdateOneWithoutCustomersNestedInput
    sales?: saleUpdateManyWithoutCustomerNestedInput
  }

  export type customerUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    customer_name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    cpf?: NullableStringFieldUpdateOperationsInput | string | null
    birth_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    store_id?: NullableIntFieldUpdateOperationsInput | number | null
    sub_brand_id?: NullableIntFieldUpdateOperationsInput | number | null
    registration_origin?: NullableStringFieldUpdateOperationsInput | string | null
    agree_terms?: NullableBoolFieldUpdateOperationsInput | boolean | null
    receive_promotions_email?: NullableBoolFieldUpdateOperationsInput | boolean | null
    receive_promotions_sms?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sales?: saleUncheckedUpdateManyWithoutCustomerNestedInput
  }

  export type customerCreateManyInput = {
    id?: number
    customer_name?: string | null
    email?: string | null
    phone_number?: string | null
    cpf?: string | null
    birth_date?: Date | string | null
    gender?: string | null
    store_id?: number | null
    sub_brand_id?: number | null
    registration_origin?: string | null
    agree_terms?: boolean | null
    receive_promotions_email?: boolean | null
    receive_promotions_sms?: boolean | null
    created_at?: Date | string | null
  }

  export type customerUpdateManyMutationInput = {
    customer_name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    cpf?: NullableStringFieldUpdateOperationsInput | string | null
    birth_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    registration_origin?: NullableStringFieldUpdateOperationsInput | string | null
    agree_terms?: NullableBoolFieldUpdateOperationsInput | boolean | null
    receive_promotions_email?: NullableBoolFieldUpdateOperationsInput | boolean | null
    receive_promotions_sms?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type customerUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    customer_name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    cpf?: NullableStringFieldUpdateOperationsInput | string | null
    birth_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    store_id?: NullableIntFieldUpdateOperationsInput | number | null
    sub_brand_id?: NullableIntFieldUpdateOperationsInput | number | null
    registration_origin?: NullableStringFieldUpdateOperationsInput | string | null
    agree_terms?: NullableBoolFieldUpdateOperationsInput | boolean | null
    receive_promotions_email?: NullableBoolFieldUpdateOperationsInput | boolean | null
    receive_promotions_sms?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type saleCreateInput = {
    cod_sale1?: string | null
    cod_sale2?: string | null
    created_at: Date | string
    customer_name?: string | null
    sale_status_desc: string
    total_amount_items: Decimal | DecimalJsLike | number | string
    total_discount?: Decimal | DecimalJsLike | number | string | null
    total_increase?: Decimal | DecimalJsLike | number | string | null
    delivery_fee?: Decimal | DecimalJsLike | number | string | null
    service_tax_fee?: Decimal | DecimalJsLike | number | string | null
    total_amount: Decimal | DecimalJsLike | number | string
    value_paid?: Decimal | DecimalJsLike | number | string | null
    production_seconds?: number | null
    delivery_seconds?: number | null
    people_quantity?: number | null
    discount_reason?: string | null
    increase_reason?: string | null
    origin?: string | null
    store: storeCreateNestedOneWithoutSalesInput
    subbrand?: subbrandCreateNestedOneWithoutSalesInput
    customer?: customerCreateNestedOneWithoutSalesInput
    channel: channelCreateNestedOneWithoutSalesInput
    productsales?: productsaleCreateNestedManyWithoutSaleInput
    deliverysales?: deliverysaleCreateNestedManyWithoutSaleInput
    deliveryaddress?: deliveryaddressCreateNestedManyWithoutSaleInput
    payments?: paymentCreateNestedManyWithoutSaleInput
    couponsales?: couponsaleCreateNestedManyWithoutSaleInput
  }

  export type saleUncheckedCreateInput = {
    id?: number
    store_id: number
    sub_brand_id?: number | null
    customer_id?: number | null
    channel_id: number
    cod_sale1?: string | null
    cod_sale2?: string | null
    created_at: Date | string
    customer_name?: string | null
    sale_status_desc: string
    total_amount_items: Decimal | DecimalJsLike | number | string
    total_discount?: Decimal | DecimalJsLike | number | string | null
    total_increase?: Decimal | DecimalJsLike | number | string | null
    delivery_fee?: Decimal | DecimalJsLike | number | string | null
    service_tax_fee?: Decimal | DecimalJsLike | number | string | null
    total_amount: Decimal | DecimalJsLike | number | string
    value_paid?: Decimal | DecimalJsLike | number | string | null
    production_seconds?: number | null
    delivery_seconds?: number | null
    people_quantity?: number | null
    discount_reason?: string | null
    increase_reason?: string | null
    origin?: string | null
    productsales?: productsaleUncheckedCreateNestedManyWithoutSaleInput
    deliverysales?: deliverysaleUncheckedCreateNestedManyWithoutSaleInput
    deliveryaddress?: deliveryaddressUncheckedCreateNestedManyWithoutSaleInput
    payments?: paymentUncheckedCreateNestedManyWithoutSaleInput
    couponsales?: couponsaleUncheckedCreateNestedManyWithoutSaleInput
  }

  export type saleUpdateInput = {
    cod_sale1?: NullableStringFieldUpdateOperationsInput | string | null
    cod_sale2?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    customer_name?: NullableStringFieldUpdateOperationsInput | string | null
    sale_status_desc?: StringFieldUpdateOperationsInput | string
    total_amount_items?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total_discount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    total_increase?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    delivery_fee?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    service_tax_fee?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    total_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    value_paid?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    production_seconds?: NullableIntFieldUpdateOperationsInput | number | null
    delivery_seconds?: NullableIntFieldUpdateOperationsInput | number | null
    people_quantity?: NullableIntFieldUpdateOperationsInput | number | null
    discount_reason?: NullableStringFieldUpdateOperationsInput | string | null
    increase_reason?: NullableStringFieldUpdateOperationsInput | string | null
    origin?: NullableStringFieldUpdateOperationsInput | string | null
    store?: storeUpdateOneRequiredWithoutSalesNestedInput
    subbrand?: subbrandUpdateOneWithoutSalesNestedInput
    customer?: customerUpdateOneWithoutSalesNestedInput
    channel?: channelUpdateOneRequiredWithoutSalesNestedInput
    productsales?: productsaleUpdateManyWithoutSaleNestedInput
    deliverysales?: deliverysaleUpdateManyWithoutSaleNestedInput
    deliveryaddress?: deliveryaddressUpdateManyWithoutSaleNestedInput
    payments?: paymentUpdateManyWithoutSaleNestedInput
    couponsales?: couponsaleUpdateManyWithoutSaleNestedInput
  }

  export type saleUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    store_id?: IntFieldUpdateOperationsInput | number
    sub_brand_id?: NullableIntFieldUpdateOperationsInput | number | null
    customer_id?: NullableIntFieldUpdateOperationsInput | number | null
    channel_id?: IntFieldUpdateOperationsInput | number
    cod_sale1?: NullableStringFieldUpdateOperationsInput | string | null
    cod_sale2?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    customer_name?: NullableStringFieldUpdateOperationsInput | string | null
    sale_status_desc?: StringFieldUpdateOperationsInput | string
    total_amount_items?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total_discount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    total_increase?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    delivery_fee?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    service_tax_fee?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    total_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    value_paid?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    production_seconds?: NullableIntFieldUpdateOperationsInput | number | null
    delivery_seconds?: NullableIntFieldUpdateOperationsInput | number | null
    people_quantity?: NullableIntFieldUpdateOperationsInput | number | null
    discount_reason?: NullableStringFieldUpdateOperationsInput | string | null
    increase_reason?: NullableStringFieldUpdateOperationsInput | string | null
    origin?: NullableStringFieldUpdateOperationsInput | string | null
    productsales?: productsaleUncheckedUpdateManyWithoutSaleNestedInput
    deliverysales?: deliverysaleUncheckedUpdateManyWithoutSaleNestedInput
    deliveryaddress?: deliveryaddressUncheckedUpdateManyWithoutSaleNestedInput
    payments?: paymentUncheckedUpdateManyWithoutSaleNestedInput
    couponsales?: couponsaleUncheckedUpdateManyWithoutSaleNestedInput
  }

  export type saleCreateManyInput = {
    id?: number
    store_id: number
    sub_brand_id?: number | null
    customer_id?: number | null
    channel_id: number
    cod_sale1?: string | null
    cod_sale2?: string | null
    created_at: Date | string
    customer_name?: string | null
    sale_status_desc: string
    total_amount_items: Decimal | DecimalJsLike | number | string
    total_discount?: Decimal | DecimalJsLike | number | string | null
    total_increase?: Decimal | DecimalJsLike | number | string | null
    delivery_fee?: Decimal | DecimalJsLike | number | string | null
    service_tax_fee?: Decimal | DecimalJsLike | number | string | null
    total_amount: Decimal | DecimalJsLike | number | string
    value_paid?: Decimal | DecimalJsLike | number | string | null
    production_seconds?: number | null
    delivery_seconds?: number | null
    people_quantity?: number | null
    discount_reason?: string | null
    increase_reason?: string | null
    origin?: string | null
  }

  export type saleUpdateManyMutationInput = {
    cod_sale1?: NullableStringFieldUpdateOperationsInput | string | null
    cod_sale2?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    customer_name?: NullableStringFieldUpdateOperationsInput | string | null
    sale_status_desc?: StringFieldUpdateOperationsInput | string
    total_amount_items?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total_discount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    total_increase?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    delivery_fee?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    service_tax_fee?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    total_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    value_paid?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    production_seconds?: NullableIntFieldUpdateOperationsInput | number | null
    delivery_seconds?: NullableIntFieldUpdateOperationsInput | number | null
    people_quantity?: NullableIntFieldUpdateOperationsInput | number | null
    discount_reason?: NullableStringFieldUpdateOperationsInput | string | null
    increase_reason?: NullableStringFieldUpdateOperationsInput | string | null
    origin?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type saleUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    store_id?: IntFieldUpdateOperationsInput | number
    sub_brand_id?: NullableIntFieldUpdateOperationsInput | number | null
    customer_id?: NullableIntFieldUpdateOperationsInput | number | null
    channel_id?: IntFieldUpdateOperationsInput | number
    cod_sale1?: NullableStringFieldUpdateOperationsInput | string | null
    cod_sale2?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    customer_name?: NullableStringFieldUpdateOperationsInput | string | null
    sale_status_desc?: StringFieldUpdateOperationsInput | string
    total_amount_items?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total_discount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    total_increase?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    delivery_fee?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    service_tax_fee?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    total_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    value_paid?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    production_seconds?: NullableIntFieldUpdateOperationsInput | number | null
    delivery_seconds?: NullableIntFieldUpdateOperationsInput | number | null
    people_quantity?: NullableIntFieldUpdateOperationsInput | number | null
    discount_reason?: NullableStringFieldUpdateOperationsInput | string | null
    increase_reason?: NullableStringFieldUpdateOperationsInput | string | null
    origin?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type productsaleCreateInput = {
    quantity: number
    base_price: number
    total_price: number
    observations?: string | null
    sale: saleCreateNestedOneWithoutProductsalesInput
    product: productCreateNestedOneWithoutProductsalesInput
    itemproductsales?: itemproductsaleCreateNestedManyWithoutProductsaleInput
  }

  export type productsaleUncheckedCreateInput = {
    id?: number
    sale_id: number
    product_id: number
    quantity: number
    base_price: number
    total_price: number
    observations?: string | null
    itemproductsales?: itemproductsaleUncheckedCreateNestedManyWithoutProductsaleInput
  }

  export type productsaleUpdateInput = {
    quantity?: FloatFieldUpdateOperationsInput | number
    base_price?: FloatFieldUpdateOperationsInput | number
    total_price?: FloatFieldUpdateOperationsInput | number
    observations?: NullableStringFieldUpdateOperationsInput | string | null
    sale?: saleUpdateOneRequiredWithoutProductsalesNestedInput
    product?: productUpdateOneRequiredWithoutProductsalesNestedInput
    itemproductsales?: itemproductsaleUpdateManyWithoutProductsaleNestedInput
  }

  export type productsaleUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    sale_id?: IntFieldUpdateOperationsInput | number
    product_id?: IntFieldUpdateOperationsInput | number
    quantity?: FloatFieldUpdateOperationsInput | number
    base_price?: FloatFieldUpdateOperationsInput | number
    total_price?: FloatFieldUpdateOperationsInput | number
    observations?: NullableStringFieldUpdateOperationsInput | string | null
    itemproductsales?: itemproductsaleUncheckedUpdateManyWithoutProductsaleNestedInput
  }

  export type productsaleCreateManyInput = {
    id?: number
    sale_id: number
    product_id: number
    quantity: number
    base_price: number
    total_price: number
    observations?: string | null
  }

  export type productsaleUpdateManyMutationInput = {
    quantity?: FloatFieldUpdateOperationsInput | number
    base_price?: FloatFieldUpdateOperationsInput | number
    total_price?: FloatFieldUpdateOperationsInput | number
    observations?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type productsaleUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    sale_id?: IntFieldUpdateOperationsInput | number
    product_id?: IntFieldUpdateOperationsInput | number
    quantity?: FloatFieldUpdateOperationsInput | number
    base_price?: FloatFieldUpdateOperationsInput | number
    total_price?: FloatFieldUpdateOperationsInput | number
    observations?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type itemproductsaleCreateInput = {
    quantity: number
    additional_price: number
    price: number
    amount?: number | null
    observations?: string | null
    productsale: productsaleCreateNestedOneWithoutItemproductsalesInput
    item: itemCreateNestedOneWithoutItemproductsalesInput
    optiongroup?: optiongroupCreateNestedOneWithoutItemproductsalesInput
    itemitemproductsales?: itemitemproductsaleCreateNestedManyWithoutItemproductsaleInput
  }

  export type itemproductsaleUncheckedCreateInput = {
    id?: number
    product_sale_id: number
    item_id: number
    option_group_id?: number | null
    quantity: number
    additional_price: number
    price: number
    amount?: number | null
    observations?: string | null
    itemitemproductsales?: itemitemproductsaleUncheckedCreateNestedManyWithoutItemproductsaleInput
  }

  export type itemproductsaleUpdateInput = {
    quantity?: FloatFieldUpdateOperationsInput | number
    additional_price?: FloatFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    observations?: NullableStringFieldUpdateOperationsInput | string | null
    productsale?: productsaleUpdateOneRequiredWithoutItemproductsalesNestedInput
    item?: itemUpdateOneRequiredWithoutItemproductsalesNestedInput
    optiongroup?: optiongroupUpdateOneWithoutItemproductsalesNestedInput
    itemitemproductsales?: itemitemproductsaleUpdateManyWithoutItemproductsaleNestedInput
  }

  export type itemproductsaleUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    product_sale_id?: IntFieldUpdateOperationsInput | number
    item_id?: IntFieldUpdateOperationsInput | number
    option_group_id?: NullableIntFieldUpdateOperationsInput | number | null
    quantity?: FloatFieldUpdateOperationsInput | number
    additional_price?: FloatFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    observations?: NullableStringFieldUpdateOperationsInput | string | null
    itemitemproductsales?: itemitemproductsaleUncheckedUpdateManyWithoutItemproductsaleNestedInput
  }

  export type itemproductsaleCreateManyInput = {
    id?: number
    product_sale_id: number
    item_id: number
    option_group_id?: number | null
    quantity: number
    additional_price: number
    price: number
    amount?: number | null
    observations?: string | null
  }

  export type itemproductsaleUpdateManyMutationInput = {
    quantity?: FloatFieldUpdateOperationsInput | number
    additional_price?: FloatFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    observations?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type itemproductsaleUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    product_sale_id?: IntFieldUpdateOperationsInput | number
    item_id?: IntFieldUpdateOperationsInput | number
    option_group_id?: NullableIntFieldUpdateOperationsInput | number | null
    quantity?: FloatFieldUpdateOperationsInput | number
    additional_price?: FloatFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    observations?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type itemitemproductsaleCreateInput = {
    quantity: number
    additional_price: number
    price: number
    amount?: number | null
    itemproductsale: itemproductsaleCreateNestedOneWithoutItemitemproductsalesInput
    item: itemCreateNestedOneWithoutItemitemproductsalesInput
    optiongroup?: optiongroupCreateNestedOneWithoutItemitemproductsalesInput
  }

  export type itemitemproductsaleUncheckedCreateInput = {
    id?: number
    item_product_sale_id: number
    item_id: number
    option_group_id?: number | null
    quantity: number
    additional_price: number
    price: number
    amount?: number | null
  }

  export type itemitemproductsaleUpdateInput = {
    quantity?: FloatFieldUpdateOperationsInput | number
    additional_price?: FloatFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    itemproductsale?: itemproductsaleUpdateOneRequiredWithoutItemitemproductsalesNestedInput
    item?: itemUpdateOneRequiredWithoutItemitemproductsalesNestedInput
    optiongroup?: optiongroupUpdateOneWithoutItemitemproductsalesNestedInput
  }

  export type itemitemproductsaleUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    item_product_sale_id?: IntFieldUpdateOperationsInput | number
    item_id?: IntFieldUpdateOperationsInput | number
    option_group_id?: NullableIntFieldUpdateOperationsInput | number | null
    quantity?: FloatFieldUpdateOperationsInput | number
    additional_price?: FloatFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type itemitemproductsaleCreateManyInput = {
    id?: number
    item_product_sale_id: number
    item_id: number
    option_group_id?: number | null
    quantity: number
    additional_price: number
    price: number
    amount?: number | null
  }

  export type itemitemproductsaleUpdateManyMutationInput = {
    quantity?: FloatFieldUpdateOperationsInput | number
    additional_price?: FloatFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type itemitemproductsaleUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    item_product_sale_id?: IntFieldUpdateOperationsInput | number
    item_id?: IntFieldUpdateOperationsInput | number
    option_group_id?: NullableIntFieldUpdateOperationsInput | number | null
    quantity?: FloatFieldUpdateOperationsInput | number
    additional_price?: FloatFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type deliverysaleCreateInput = {
    courier_id?: string | null
    courier_name?: string | null
    courier_phone?: string | null
    courier_type?: string | null
    delivered_by?: string | null
    delivery_type?: string | null
    status?: string | null
    delivery_fee?: number | null
    courier_fee?: number | null
    timing?: string | null
    mode?: string | null
    sale: saleCreateNestedOneWithoutDeliverysalesInput
    deliveryaddresses?: deliveryaddressCreateNestedManyWithoutDeliverysaleInput
  }

  export type deliverysaleUncheckedCreateInput = {
    id?: number
    sale_id: number
    courier_id?: string | null
    courier_name?: string | null
    courier_phone?: string | null
    courier_type?: string | null
    delivered_by?: string | null
    delivery_type?: string | null
    status?: string | null
    delivery_fee?: number | null
    courier_fee?: number | null
    timing?: string | null
    mode?: string | null
    deliveryaddresses?: deliveryaddressUncheckedCreateNestedManyWithoutDeliverysaleInput
  }

  export type deliverysaleUpdateInput = {
    courier_id?: NullableStringFieldUpdateOperationsInput | string | null
    courier_name?: NullableStringFieldUpdateOperationsInput | string | null
    courier_phone?: NullableStringFieldUpdateOperationsInput | string | null
    courier_type?: NullableStringFieldUpdateOperationsInput | string | null
    delivered_by?: NullableStringFieldUpdateOperationsInput | string | null
    delivery_type?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    delivery_fee?: NullableFloatFieldUpdateOperationsInput | number | null
    courier_fee?: NullableFloatFieldUpdateOperationsInput | number | null
    timing?: NullableStringFieldUpdateOperationsInput | string | null
    mode?: NullableStringFieldUpdateOperationsInput | string | null
    sale?: saleUpdateOneRequiredWithoutDeliverysalesNestedInput
    deliveryaddresses?: deliveryaddressUpdateManyWithoutDeliverysaleNestedInput
  }

  export type deliverysaleUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    sale_id?: IntFieldUpdateOperationsInput | number
    courier_id?: NullableStringFieldUpdateOperationsInput | string | null
    courier_name?: NullableStringFieldUpdateOperationsInput | string | null
    courier_phone?: NullableStringFieldUpdateOperationsInput | string | null
    courier_type?: NullableStringFieldUpdateOperationsInput | string | null
    delivered_by?: NullableStringFieldUpdateOperationsInput | string | null
    delivery_type?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    delivery_fee?: NullableFloatFieldUpdateOperationsInput | number | null
    courier_fee?: NullableFloatFieldUpdateOperationsInput | number | null
    timing?: NullableStringFieldUpdateOperationsInput | string | null
    mode?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryaddresses?: deliveryaddressUncheckedUpdateManyWithoutDeliverysaleNestedInput
  }

  export type deliverysaleCreateManyInput = {
    id?: number
    sale_id: number
    courier_id?: string | null
    courier_name?: string | null
    courier_phone?: string | null
    courier_type?: string | null
    delivered_by?: string | null
    delivery_type?: string | null
    status?: string | null
    delivery_fee?: number | null
    courier_fee?: number | null
    timing?: string | null
    mode?: string | null
  }

  export type deliverysaleUpdateManyMutationInput = {
    courier_id?: NullableStringFieldUpdateOperationsInput | string | null
    courier_name?: NullableStringFieldUpdateOperationsInput | string | null
    courier_phone?: NullableStringFieldUpdateOperationsInput | string | null
    courier_type?: NullableStringFieldUpdateOperationsInput | string | null
    delivered_by?: NullableStringFieldUpdateOperationsInput | string | null
    delivery_type?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    delivery_fee?: NullableFloatFieldUpdateOperationsInput | number | null
    courier_fee?: NullableFloatFieldUpdateOperationsInput | number | null
    timing?: NullableStringFieldUpdateOperationsInput | string | null
    mode?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type deliverysaleUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    sale_id?: IntFieldUpdateOperationsInput | number
    courier_id?: NullableStringFieldUpdateOperationsInput | string | null
    courier_name?: NullableStringFieldUpdateOperationsInput | string | null
    courier_phone?: NullableStringFieldUpdateOperationsInput | string | null
    courier_type?: NullableStringFieldUpdateOperationsInput | string | null
    delivered_by?: NullableStringFieldUpdateOperationsInput | string | null
    delivery_type?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    delivery_fee?: NullableFloatFieldUpdateOperationsInput | number | null
    courier_fee?: NullableFloatFieldUpdateOperationsInput | number | null
    timing?: NullableStringFieldUpdateOperationsInput | string | null
    mode?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type deliveryaddressCreateInput = {
    street?: string | null
    number?: string | null
    complement?: string | null
    formatted_address?: string | null
    neighborhood?: string | null
    city?: string | null
    state?: string | null
    country?: string | null
    postal_code?: string | null
    reference?: string | null
    latitude?: number | null
    longitude?: number | null
    sale: saleCreateNestedOneWithoutDeliveryaddressInput
    deliverysale?: deliverysaleCreateNestedOneWithoutDeliveryaddressesInput
  }

  export type deliveryaddressUncheckedCreateInput = {
    id?: number
    sale_id: number
    delivery_sale_id?: number | null
    street?: string | null
    number?: string | null
    complement?: string | null
    formatted_address?: string | null
    neighborhood?: string | null
    city?: string | null
    state?: string | null
    country?: string | null
    postal_code?: string | null
    reference?: string | null
    latitude?: number | null
    longitude?: number | null
  }

  export type deliveryaddressUpdateInput = {
    street?: NullableStringFieldUpdateOperationsInput | string | null
    number?: NullableStringFieldUpdateOperationsInput | string | null
    complement?: NullableStringFieldUpdateOperationsInput | string | null
    formatted_address?: NullableStringFieldUpdateOperationsInput | string | null
    neighborhood?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    postal_code?: NullableStringFieldUpdateOperationsInput | string | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    sale?: saleUpdateOneRequiredWithoutDeliveryaddressNestedInput
    deliverysale?: deliverysaleUpdateOneWithoutDeliveryaddressesNestedInput
  }

  export type deliveryaddressUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    sale_id?: IntFieldUpdateOperationsInput | number
    delivery_sale_id?: NullableIntFieldUpdateOperationsInput | number | null
    street?: NullableStringFieldUpdateOperationsInput | string | null
    number?: NullableStringFieldUpdateOperationsInput | string | null
    complement?: NullableStringFieldUpdateOperationsInput | string | null
    formatted_address?: NullableStringFieldUpdateOperationsInput | string | null
    neighborhood?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    postal_code?: NullableStringFieldUpdateOperationsInput | string | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type deliveryaddressCreateManyInput = {
    id?: number
    sale_id: number
    delivery_sale_id?: number | null
    street?: string | null
    number?: string | null
    complement?: string | null
    formatted_address?: string | null
    neighborhood?: string | null
    city?: string | null
    state?: string | null
    country?: string | null
    postal_code?: string | null
    reference?: string | null
    latitude?: number | null
    longitude?: number | null
  }

  export type deliveryaddressUpdateManyMutationInput = {
    street?: NullableStringFieldUpdateOperationsInput | string | null
    number?: NullableStringFieldUpdateOperationsInput | string | null
    complement?: NullableStringFieldUpdateOperationsInput | string | null
    formatted_address?: NullableStringFieldUpdateOperationsInput | string | null
    neighborhood?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    postal_code?: NullableStringFieldUpdateOperationsInput | string | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type deliveryaddressUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    sale_id?: IntFieldUpdateOperationsInput | number
    delivery_sale_id?: NullableIntFieldUpdateOperationsInput | number | null
    street?: NullableStringFieldUpdateOperationsInput | string | null
    number?: NullableStringFieldUpdateOperationsInput | string | null
    complement?: NullableStringFieldUpdateOperationsInput | string | null
    formatted_address?: NullableStringFieldUpdateOperationsInput | string | null
    neighborhood?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    postal_code?: NullableStringFieldUpdateOperationsInput | string | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type paymenttypeCreateInput = {
    description: string
    brand?: brandCreateNestedOneWithoutPaymenttypesInput
    payments?: paymentCreateNestedManyWithoutPaymenttypeInput
  }

  export type paymenttypeUncheckedCreateInput = {
    id?: number
    brand_id?: number | null
    description: string
    payments?: paymentUncheckedCreateNestedManyWithoutPaymenttypeInput
  }

  export type paymenttypeUpdateInput = {
    description?: StringFieldUpdateOperationsInput | string
    brand?: brandUpdateOneWithoutPaymenttypesNestedInput
    payments?: paymentUpdateManyWithoutPaymenttypeNestedInput
  }

  export type paymenttypeUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    brand_id?: NullableIntFieldUpdateOperationsInput | number | null
    description?: StringFieldUpdateOperationsInput | string
    payments?: paymentUncheckedUpdateManyWithoutPaymenttypeNestedInput
  }

  export type paymenttypeCreateManyInput = {
    id?: number
    brand_id?: number | null
    description: string
  }

  export type paymenttypeUpdateManyMutationInput = {
    description?: StringFieldUpdateOperationsInput | string
  }

  export type paymenttypeUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    brand_id?: NullableIntFieldUpdateOperationsInput | number | null
    description?: StringFieldUpdateOperationsInput | string
  }

  export type paymentCreateInput = {
    value: Decimal | DecimalJsLike | number | string
    is_online?: boolean | null
    description?: string | null
    currency?: string | null
    sale: saleCreateNestedOneWithoutPaymentsInput
    paymenttype?: paymenttypeCreateNestedOneWithoutPaymentsInput
  }

  export type paymentUncheckedCreateInput = {
    id?: number
    sale_id: number
    payment_type_id?: number | null
    value: Decimal | DecimalJsLike | number | string
    is_online?: boolean | null
    description?: string | null
    currency?: string | null
  }

  export type paymentUpdateInput = {
    value?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    is_online?: NullableBoolFieldUpdateOperationsInput | boolean | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    sale?: saleUpdateOneRequiredWithoutPaymentsNestedInput
    paymenttype?: paymenttypeUpdateOneWithoutPaymentsNestedInput
  }

  export type paymentUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    sale_id?: IntFieldUpdateOperationsInput | number
    payment_type_id?: NullableIntFieldUpdateOperationsInput | number | null
    value?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    is_online?: NullableBoolFieldUpdateOperationsInput | boolean | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type paymentCreateManyInput = {
    id?: number
    sale_id: number
    payment_type_id?: number | null
    value: Decimal | DecimalJsLike | number | string
    is_online?: boolean | null
    description?: string | null
    currency?: string | null
  }

  export type paymentUpdateManyMutationInput = {
    value?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    is_online?: NullableBoolFieldUpdateOperationsInput | boolean | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type paymentUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    sale_id?: IntFieldUpdateOperationsInput | number
    payment_type_id?: NullableIntFieldUpdateOperationsInput | number | null
    value?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    is_online?: NullableBoolFieldUpdateOperationsInput | boolean | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type couponCreateInput = {
    code: string
    discount_type?: string | null
    discount_value?: Decimal | DecimalJsLike | number | string | null
    is_active?: boolean | null
    valid_from?: Date | string | null
    valid_until?: Date | string | null
    brand?: brandCreateNestedOneWithoutCouponsInput
    couponsales?: couponsaleCreateNestedManyWithoutCouponInput
  }

  export type couponUncheckedCreateInput = {
    id?: number
    brand_id?: number | null
    code: string
    discount_type?: string | null
    discount_value?: Decimal | DecimalJsLike | number | string | null
    is_active?: boolean | null
    valid_from?: Date | string | null
    valid_until?: Date | string | null
    couponsales?: couponsaleUncheckedCreateNestedManyWithoutCouponInput
  }

  export type couponUpdateInput = {
    code?: StringFieldUpdateOperationsInput | string
    discount_type?: NullableStringFieldUpdateOperationsInput | string | null
    discount_value?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    valid_from?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    valid_until?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    brand?: brandUpdateOneWithoutCouponsNestedInput
    couponsales?: couponsaleUpdateManyWithoutCouponNestedInput
  }

  export type couponUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    brand_id?: NullableIntFieldUpdateOperationsInput | number | null
    code?: StringFieldUpdateOperationsInput | string
    discount_type?: NullableStringFieldUpdateOperationsInput | string | null
    discount_value?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    valid_from?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    valid_until?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    couponsales?: couponsaleUncheckedUpdateManyWithoutCouponNestedInput
  }

  export type couponCreateManyInput = {
    id?: number
    brand_id?: number | null
    code: string
    discount_type?: string | null
    discount_value?: Decimal | DecimalJsLike | number | string | null
    is_active?: boolean | null
    valid_from?: Date | string | null
    valid_until?: Date | string | null
  }

  export type couponUpdateManyMutationInput = {
    code?: StringFieldUpdateOperationsInput | string
    discount_type?: NullableStringFieldUpdateOperationsInput | string | null
    discount_value?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    valid_from?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    valid_until?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type couponUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    brand_id?: NullableIntFieldUpdateOperationsInput | number | null
    code?: StringFieldUpdateOperationsInput | string
    discount_type?: NullableStringFieldUpdateOperationsInput | string | null
    discount_value?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    valid_from?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    valid_until?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type couponsaleCreateInput = {
    value?: number | null
    target?: string | null
    sponsorship?: string | null
    sale?: saleCreateNestedOneWithoutCouponsalesInput
    coupon?: couponCreateNestedOneWithoutCouponsalesInput
  }

  export type couponsaleUncheckedCreateInput = {
    id?: number
    sale_id?: number | null
    coupon_id?: number | null
    value?: number | null
    target?: string | null
    sponsorship?: string | null
  }

  export type couponsaleUpdateInput = {
    value?: NullableFloatFieldUpdateOperationsInput | number | null
    target?: NullableStringFieldUpdateOperationsInput | string | null
    sponsorship?: NullableStringFieldUpdateOperationsInput | string | null
    sale?: saleUpdateOneWithoutCouponsalesNestedInput
    coupon?: couponUpdateOneWithoutCouponsalesNestedInput
  }

  export type couponsaleUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    sale_id?: NullableIntFieldUpdateOperationsInput | number | null
    coupon_id?: NullableIntFieldUpdateOperationsInput | number | null
    value?: NullableFloatFieldUpdateOperationsInput | number | null
    target?: NullableStringFieldUpdateOperationsInput | string | null
    sponsorship?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type couponsaleCreateManyInput = {
    id?: number
    sale_id?: number | null
    coupon_id?: number | null
    value?: number | null
    target?: string | null
    sponsorship?: string | null
  }

  export type couponsaleUpdateManyMutationInput = {
    value?: NullableFloatFieldUpdateOperationsInput | number | null
    target?: NullableStringFieldUpdateOperationsInput | string | null
    sponsorship?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type couponsaleUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    sale_id?: NullableIntFieldUpdateOperationsInput | number | null
    coupon_id?: NullableIntFieldUpdateOperationsInput | number | null
    value?: NullableFloatFieldUpdateOperationsInput | number | null
    target?: NullableStringFieldUpdateOperationsInput | string | null
    sponsorship?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type SubbrandListRelationFilter = {
    every?: subbrandWhereInput
    some?: subbrandWhereInput
    none?: subbrandWhereInput
  }

  export type StoreListRelationFilter = {
    every?: storeWhereInput
    some?: storeWhereInput
    none?: storeWhereInput
  }

  export type ChannelListRelationFilter = {
    every?: channelWhereInput
    some?: channelWhereInput
    none?: channelWhereInput
  }

  export type CategoryListRelationFilter = {
    every?: categoryWhereInput
    some?: categoryWhereInput
    none?: categoryWhereInput
  }

  export type ProductListRelationFilter = {
    every?: productWhereInput
    some?: productWhereInput
    none?: productWhereInput
  }

  export type OptiongroupListRelationFilter = {
    every?: optiongroupWhereInput
    some?: optiongroupWhereInput
    none?: optiongroupWhereInput
  }

  export type ItemListRelationFilter = {
    every?: itemWhereInput
    some?: itemWhereInput
    none?: itemWhereInput
  }

  export type PaymenttypeListRelationFilter = {
    every?: paymenttypeWhereInput
    some?: paymenttypeWhereInput
    none?: paymenttypeWhereInput
  }

  export type CouponListRelationFilter = {
    every?: couponWhereInput
    some?: couponWhereInput
    none?: couponWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type subbrandOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type storeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type channelOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type categoryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type productOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type optiongroupOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type itemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type paymenttypeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type couponOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type brandCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    created_at?: SortOrder
  }

  export type brandAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type brandMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    created_at?: SortOrder
  }

  export type brandMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    created_at?: SortOrder
  }

  export type brandSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type BrandScalarRelationFilter = {
    is?: brandWhereInput
    isNot?: brandWhereInput
  }

  export type CustomerListRelationFilter = {
    every?: customerWhereInput
    some?: customerWhereInput
    none?: customerWhereInput
  }

  export type SaleListRelationFilter = {
    every?: saleWhereInput
    some?: saleWhereInput
    none?: saleWhereInput
  }

  export type customerOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type saleOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type subbrandCountOrderByAggregateInput = {
    id?: SortOrder
    brand_id?: SortOrder
    name?: SortOrder
    created_at?: SortOrder
  }

  export type subbrandAvgOrderByAggregateInput = {
    id?: SortOrder
    brand_id?: SortOrder
  }

  export type subbrandMaxOrderByAggregateInput = {
    id?: SortOrder
    brand_id?: SortOrder
    name?: SortOrder
    created_at?: SortOrder
  }

  export type subbrandMinOrderByAggregateInput = {
    id?: SortOrder
    brand_id?: SortOrder
    name?: SortOrder
    created_at?: SortOrder
  }

  export type subbrandSumOrderByAggregateInput = {
    id?: SortOrder
    brand_id?: SortOrder
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type DecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type BoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type SubbrandNullableScalarRelationFilter = {
    is?: subbrandWhereInput | null
    isNot?: subbrandWhereInput | null
  }

  export type storeCountOrderByAggregateInput = {
    id?: SortOrder
    brand_id?: SortOrder
    sub_brand_id?: SortOrder
    name?: SortOrder
    city?: SortOrder
    state?: SortOrder
    district?: SortOrder
    address_street?: SortOrder
    address_number?: SortOrder
    zipcode?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    is_active?: SortOrder
    is_own?: SortOrder
    is_holding?: SortOrder
    creation_date?: SortOrder
    created_at?: SortOrder
  }

  export type storeAvgOrderByAggregateInput = {
    id?: SortOrder
    brand_id?: SortOrder
    sub_brand_id?: SortOrder
    address_number?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
  }

  export type storeMaxOrderByAggregateInput = {
    id?: SortOrder
    brand_id?: SortOrder
    sub_brand_id?: SortOrder
    name?: SortOrder
    city?: SortOrder
    state?: SortOrder
    district?: SortOrder
    address_street?: SortOrder
    address_number?: SortOrder
    zipcode?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    is_active?: SortOrder
    is_own?: SortOrder
    is_holding?: SortOrder
    creation_date?: SortOrder
    created_at?: SortOrder
  }

  export type storeMinOrderByAggregateInput = {
    id?: SortOrder
    brand_id?: SortOrder
    sub_brand_id?: SortOrder
    name?: SortOrder
    city?: SortOrder
    state?: SortOrder
    district?: SortOrder
    address_street?: SortOrder
    address_number?: SortOrder
    zipcode?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    is_active?: SortOrder
    is_own?: SortOrder
    is_holding?: SortOrder
    creation_date?: SortOrder
    created_at?: SortOrder
  }

  export type storeSumOrderByAggregateInput = {
    id?: SortOrder
    brand_id?: SortOrder
    sub_brand_id?: SortOrder
    address_number?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type DecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type BoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type channelCountOrderByAggregateInput = {
    id?: SortOrder
    brand_id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    type?: SortOrder
    created_at?: SortOrder
  }

  export type channelAvgOrderByAggregateInput = {
    id?: SortOrder
    brand_id?: SortOrder
  }

  export type channelMaxOrderByAggregateInput = {
    id?: SortOrder
    brand_id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    type?: SortOrder
    created_at?: SortOrder
  }

  export type channelMinOrderByAggregateInput = {
    id?: SortOrder
    brand_id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    type?: SortOrder
    created_at?: SortOrder
  }

  export type channelSumOrderByAggregateInput = {
    id?: SortOrder
    brand_id?: SortOrder
  }

  export type categoryCountOrderByAggregateInput = {
    id?: SortOrder
    brand_id?: SortOrder
    sub_brand_id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    pos_uuid?: SortOrder
    deleted_at?: SortOrder
  }

  export type categoryAvgOrderByAggregateInput = {
    id?: SortOrder
    brand_id?: SortOrder
    sub_brand_id?: SortOrder
  }

  export type categoryMaxOrderByAggregateInput = {
    id?: SortOrder
    brand_id?: SortOrder
    sub_brand_id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    pos_uuid?: SortOrder
    deleted_at?: SortOrder
  }

  export type categoryMinOrderByAggregateInput = {
    id?: SortOrder
    brand_id?: SortOrder
    sub_brand_id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    pos_uuid?: SortOrder
    deleted_at?: SortOrder
  }

  export type categorySumOrderByAggregateInput = {
    id?: SortOrder
    brand_id?: SortOrder
    sub_brand_id?: SortOrder
  }

  export type CategoryNullableScalarRelationFilter = {
    is?: categoryWhereInput | null
    isNot?: categoryWhereInput | null
  }

  export type ProductsaleListRelationFilter = {
    every?: productsaleWhereInput
    some?: productsaleWhereInput
    none?: productsaleWhereInput
  }

  export type productsaleOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type productCountOrderByAggregateInput = {
    id?: SortOrder
    brand_id?: SortOrder
    sub_brand_id?: SortOrder
    category_id?: SortOrder
    name?: SortOrder
    pos_uuid?: SortOrder
    deleted_at?: SortOrder
  }

  export type productAvgOrderByAggregateInput = {
    id?: SortOrder
    brand_id?: SortOrder
    sub_brand_id?: SortOrder
    category_id?: SortOrder
  }

  export type productMaxOrderByAggregateInput = {
    id?: SortOrder
    brand_id?: SortOrder
    sub_brand_id?: SortOrder
    category_id?: SortOrder
    name?: SortOrder
    pos_uuid?: SortOrder
    deleted_at?: SortOrder
  }

  export type productMinOrderByAggregateInput = {
    id?: SortOrder
    brand_id?: SortOrder
    sub_brand_id?: SortOrder
    category_id?: SortOrder
    name?: SortOrder
    pos_uuid?: SortOrder
    deleted_at?: SortOrder
  }

  export type productSumOrderByAggregateInput = {
    id?: SortOrder
    brand_id?: SortOrder
    sub_brand_id?: SortOrder
    category_id?: SortOrder
  }

  export type ItemproductsaleListRelationFilter = {
    every?: itemproductsaleWhereInput
    some?: itemproductsaleWhereInput
    none?: itemproductsaleWhereInput
  }

  export type ItemitemproductsaleListRelationFilter = {
    every?: itemitemproductsaleWhereInput
    some?: itemitemproductsaleWhereInput
    none?: itemitemproductsaleWhereInput
  }

  export type itemproductsaleOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type itemitemproductsaleOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type optiongroupCountOrderByAggregateInput = {
    id?: SortOrder
    brand_id?: SortOrder
    sub_brand_id?: SortOrder
    category_id?: SortOrder
    name?: SortOrder
    pos_uuid?: SortOrder
    deleted_at?: SortOrder
  }

  export type optiongroupAvgOrderByAggregateInput = {
    id?: SortOrder
    brand_id?: SortOrder
    sub_brand_id?: SortOrder
    category_id?: SortOrder
  }

  export type optiongroupMaxOrderByAggregateInput = {
    id?: SortOrder
    brand_id?: SortOrder
    sub_brand_id?: SortOrder
    category_id?: SortOrder
    name?: SortOrder
    pos_uuid?: SortOrder
    deleted_at?: SortOrder
  }

  export type optiongroupMinOrderByAggregateInput = {
    id?: SortOrder
    brand_id?: SortOrder
    sub_brand_id?: SortOrder
    category_id?: SortOrder
    name?: SortOrder
    pos_uuid?: SortOrder
    deleted_at?: SortOrder
  }

  export type optiongroupSumOrderByAggregateInput = {
    id?: SortOrder
    brand_id?: SortOrder
    sub_brand_id?: SortOrder
    category_id?: SortOrder
  }

  export type itemCountOrderByAggregateInput = {
    id?: SortOrder
    brand_id?: SortOrder
    sub_brand_id?: SortOrder
    category_id?: SortOrder
    name?: SortOrder
    pos_uuid?: SortOrder
    deleted_at?: SortOrder
  }

  export type itemAvgOrderByAggregateInput = {
    id?: SortOrder
    brand_id?: SortOrder
    sub_brand_id?: SortOrder
    category_id?: SortOrder
  }

  export type itemMaxOrderByAggregateInput = {
    id?: SortOrder
    brand_id?: SortOrder
    sub_brand_id?: SortOrder
    category_id?: SortOrder
    name?: SortOrder
    pos_uuid?: SortOrder
    deleted_at?: SortOrder
  }

  export type itemMinOrderByAggregateInput = {
    id?: SortOrder
    brand_id?: SortOrder
    sub_brand_id?: SortOrder
    category_id?: SortOrder
    name?: SortOrder
    pos_uuid?: SortOrder
    deleted_at?: SortOrder
  }

  export type itemSumOrderByAggregateInput = {
    id?: SortOrder
    brand_id?: SortOrder
    sub_brand_id?: SortOrder
    category_id?: SortOrder
  }

  export type StoreNullableScalarRelationFilter = {
    is?: storeWhereInput | null
    isNot?: storeWhereInput | null
  }

  export type customerCountOrderByAggregateInput = {
    id?: SortOrder
    customer_name?: SortOrder
    email?: SortOrder
    phone_number?: SortOrder
    cpf?: SortOrder
    birth_date?: SortOrder
    gender?: SortOrder
    store_id?: SortOrder
    sub_brand_id?: SortOrder
    registration_origin?: SortOrder
    agree_terms?: SortOrder
    receive_promotions_email?: SortOrder
    receive_promotions_sms?: SortOrder
    created_at?: SortOrder
  }

  export type customerAvgOrderByAggregateInput = {
    id?: SortOrder
    store_id?: SortOrder
    sub_brand_id?: SortOrder
  }

  export type customerMaxOrderByAggregateInput = {
    id?: SortOrder
    customer_name?: SortOrder
    email?: SortOrder
    phone_number?: SortOrder
    cpf?: SortOrder
    birth_date?: SortOrder
    gender?: SortOrder
    store_id?: SortOrder
    sub_brand_id?: SortOrder
    registration_origin?: SortOrder
    agree_terms?: SortOrder
    receive_promotions_email?: SortOrder
    receive_promotions_sms?: SortOrder
    created_at?: SortOrder
  }

  export type customerMinOrderByAggregateInput = {
    id?: SortOrder
    customer_name?: SortOrder
    email?: SortOrder
    phone_number?: SortOrder
    cpf?: SortOrder
    birth_date?: SortOrder
    gender?: SortOrder
    store_id?: SortOrder
    sub_brand_id?: SortOrder
    registration_origin?: SortOrder
    agree_terms?: SortOrder
    receive_promotions_email?: SortOrder
    receive_promotions_sms?: SortOrder
    created_at?: SortOrder
  }

  export type customerSumOrderByAggregateInput = {
    id?: SortOrder
    store_id?: SortOrder
    sub_brand_id?: SortOrder
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type DecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type StoreScalarRelationFilter = {
    is?: storeWhereInput
    isNot?: storeWhereInput
  }

  export type CustomerNullableScalarRelationFilter = {
    is?: customerWhereInput | null
    isNot?: customerWhereInput | null
  }

  export type ChannelScalarRelationFilter = {
    is?: channelWhereInput
    isNot?: channelWhereInput
  }

  export type DeliverysaleListRelationFilter = {
    every?: deliverysaleWhereInput
    some?: deliverysaleWhereInput
    none?: deliverysaleWhereInput
  }

  export type DeliveryaddressListRelationFilter = {
    every?: deliveryaddressWhereInput
    some?: deliveryaddressWhereInput
    none?: deliveryaddressWhereInput
  }

  export type PaymentListRelationFilter = {
    every?: paymentWhereInput
    some?: paymentWhereInput
    none?: paymentWhereInput
  }

  export type CouponsaleListRelationFilter = {
    every?: couponsaleWhereInput
    some?: couponsaleWhereInput
    none?: couponsaleWhereInput
  }

  export type deliverysaleOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type deliveryaddressOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type paymentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type couponsaleOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type saleCountOrderByAggregateInput = {
    id?: SortOrder
    store_id?: SortOrder
    sub_brand_id?: SortOrder
    customer_id?: SortOrder
    channel_id?: SortOrder
    cod_sale1?: SortOrder
    cod_sale2?: SortOrder
    created_at?: SortOrder
    customer_name?: SortOrder
    sale_status_desc?: SortOrder
    total_amount_items?: SortOrder
    total_discount?: SortOrder
    total_increase?: SortOrder
    delivery_fee?: SortOrder
    service_tax_fee?: SortOrder
    total_amount?: SortOrder
    value_paid?: SortOrder
    production_seconds?: SortOrder
    delivery_seconds?: SortOrder
    people_quantity?: SortOrder
    discount_reason?: SortOrder
    increase_reason?: SortOrder
    origin?: SortOrder
  }

  export type saleAvgOrderByAggregateInput = {
    id?: SortOrder
    store_id?: SortOrder
    sub_brand_id?: SortOrder
    customer_id?: SortOrder
    channel_id?: SortOrder
    total_amount_items?: SortOrder
    total_discount?: SortOrder
    total_increase?: SortOrder
    delivery_fee?: SortOrder
    service_tax_fee?: SortOrder
    total_amount?: SortOrder
    value_paid?: SortOrder
    production_seconds?: SortOrder
    delivery_seconds?: SortOrder
    people_quantity?: SortOrder
  }

  export type saleMaxOrderByAggregateInput = {
    id?: SortOrder
    store_id?: SortOrder
    sub_brand_id?: SortOrder
    customer_id?: SortOrder
    channel_id?: SortOrder
    cod_sale1?: SortOrder
    cod_sale2?: SortOrder
    created_at?: SortOrder
    customer_name?: SortOrder
    sale_status_desc?: SortOrder
    total_amount_items?: SortOrder
    total_discount?: SortOrder
    total_increase?: SortOrder
    delivery_fee?: SortOrder
    service_tax_fee?: SortOrder
    total_amount?: SortOrder
    value_paid?: SortOrder
    production_seconds?: SortOrder
    delivery_seconds?: SortOrder
    people_quantity?: SortOrder
    discount_reason?: SortOrder
    increase_reason?: SortOrder
    origin?: SortOrder
  }

  export type saleMinOrderByAggregateInput = {
    id?: SortOrder
    store_id?: SortOrder
    sub_brand_id?: SortOrder
    customer_id?: SortOrder
    channel_id?: SortOrder
    cod_sale1?: SortOrder
    cod_sale2?: SortOrder
    created_at?: SortOrder
    customer_name?: SortOrder
    sale_status_desc?: SortOrder
    total_amount_items?: SortOrder
    total_discount?: SortOrder
    total_increase?: SortOrder
    delivery_fee?: SortOrder
    service_tax_fee?: SortOrder
    total_amount?: SortOrder
    value_paid?: SortOrder
    production_seconds?: SortOrder
    delivery_seconds?: SortOrder
    people_quantity?: SortOrder
    discount_reason?: SortOrder
    increase_reason?: SortOrder
    origin?: SortOrder
  }

  export type saleSumOrderByAggregateInput = {
    id?: SortOrder
    store_id?: SortOrder
    sub_brand_id?: SortOrder
    customer_id?: SortOrder
    channel_id?: SortOrder
    total_amount_items?: SortOrder
    total_discount?: SortOrder
    total_increase?: SortOrder
    delivery_fee?: SortOrder
    service_tax_fee?: SortOrder
    total_amount?: SortOrder
    value_paid?: SortOrder
    production_seconds?: SortOrder
    delivery_seconds?: SortOrder
    people_quantity?: SortOrder
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type DecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type SaleScalarRelationFilter = {
    is?: saleWhereInput
    isNot?: saleWhereInput
  }

  export type ProductScalarRelationFilter = {
    is?: productWhereInput
    isNot?: productWhereInput
  }

  export type productsaleCountOrderByAggregateInput = {
    id?: SortOrder
    sale_id?: SortOrder
    product_id?: SortOrder
    quantity?: SortOrder
    base_price?: SortOrder
    total_price?: SortOrder
    observations?: SortOrder
  }

  export type productsaleAvgOrderByAggregateInput = {
    id?: SortOrder
    sale_id?: SortOrder
    product_id?: SortOrder
    quantity?: SortOrder
    base_price?: SortOrder
    total_price?: SortOrder
  }

  export type productsaleMaxOrderByAggregateInput = {
    id?: SortOrder
    sale_id?: SortOrder
    product_id?: SortOrder
    quantity?: SortOrder
    base_price?: SortOrder
    total_price?: SortOrder
    observations?: SortOrder
  }

  export type productsaleMinOrderByAggregateInput = {
    id?: SortOrder
    sale_id?: SortOrder
    product_id?: SortOrder
    quantity?: SortOrder
    base_price?: SortOrder
    total_price?: SortOrder
    observations?: SortOrder
  }

  export type productsaleSumOrderByAggregateInput = {
    id?: SortOrder
    sale_id?: SortOrder
    product_id?: SortOrder
    quantity?: SortOrder
    base_price?: SortOrder
    total_price?: SortOrder
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type ProductsaleScalarRelationFilter = {
    is?: productsaleWhereInput
    isNot?: productsaleWhereInput
  }

  export type ItemScalarRelationFilter = {
    is?: itemWhereInput
    isNot?: itemWhereInput
  }

  export type OptiongroupNullableScalarRelationFilter = {
    is?: optiongroupWhereInput | null
    isNot?: optiongroupWhereInput | null
  }

  export type itemproductsaleCountOrderByAggregateInput = {
    id?: SortOrder
    product_sale_id?: SortOrder
    item_id?: SortOrder
    option_group_id?: SortOrder
    quantity?: SortOrder
    additional_price?: SortOrder
    price?: SortOrder
    amount?: SortOrder
    observations?: SortOrder
  }

  export type itemproductsaleAvgOrderByAggregateInput = {
    id?: SortOrder
    product_sale_id?: SortOrder
    item_id?: SortOrder
    option_group_id?: SortOrder
    quantity?: SortOrder
    additional_price?: SortOrder
    price?: SortOrder
    amount?: SortOrder
  }

  export type itemproductsaleMaxOrderByAggregateInput = {
    id?: SortOrder
    product_sale_id?: SortOrder
    item_id?: SortOrder
    option_group_id?: SortOrder
    quantity?: SortOrder
    additional_price?: SortOrder
    price?: SortOrder
    amount?: SortOrder
    observations?: SortOrder
  }

  export type itemproductsaleMinOrderByAggregateInput = {
    id?: SortOrder
    product_sale_id?: SortOrder
    item_id?: SortOrder
    option_group_id?: SortOrder
    quantity?: SortOrder
    additional_price?: SortOrder
    price?: SortOrder
    amount?: SortOrder
    observations?: SortOrder
  }

  export type itemproductsaleSumOrderByAggregateInput = {
    id?: SortOrder
    product_sale_id?: SortOrder
    item_id?: SortOrder
    option_group_id?: SortOrder
    quantity?: SortOrder
    additional_price?: SortOrder
    price?: SortOrder
    amount?: SortOrder
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type ItemproductsaleScalarRelationFilter = {
    is?: itemproductsaleWhereInput
    isNot?: itemproductsaleWhereInput
  }

  export type itemitemproductsaleCountOrderByAggregateInput = {
    id?: SortOrder
    item_product_sale_id?: SortOrder
    item_id?: SortOrder
    option_group_id?: SortOrder
    quantity?: SortOrder
    additional_price?: SortOrder
    price?: SortOrder
    amount?: SortOrder
  }

  export type itemitemproductsaleAvgOrderByAggregateInput = {
    id?: SortOrder
    item_product_sale_id?: SortOrder
    item_id?: SortOrder
    option_group_id?: SortOrder
    quantity?: SortOrder
    additional_price?: SortOrder
    price?: SortOrder
    amount?: SortOrder
  }

  export type itemitemproductsaleMaxOrderByAggregateInput = {
    id?: SortOrder
    item_product_sale_id?: SortOrder
    item_id?: SortOrder
    option_group_id?: SortOrder
    quantity?: SortOrder
    additional_price?: SortOrder
    price?: SortOrder
    amount?: SortOrder
  }

  export type itemitemproductsaleMinOrderByAggregateInput = {
    id?: SortOrder
    item_product_sale_id?: SortOrder
    item_id?: SortOrder
    option_group_id?: SortOrder
    quantity?: SortOrder
    additional_price?: SortOrder
    price?: SortOrder
    amount?: SortOrder
  }

  export type itemitemproductsaleSumOrderByAggregateInput = {
    id?: SortOrder
    item_product_sale_id?: SortOrder
    item_id?: SortOrder
    option_group_id?: SortOrder
    quantity?: SortOrder
    additional_price?: SortOrder
    price?: SortOrder
    amount?: SortOrder
  }

  export type deliverysaleCountOrderByAggregateInput = {
    id?: SortOrder
    sale_id?: SortOrder
    courier_id?: SortOrder
    courier_name?: SortOrder
    courier_phone?: SortOrder
    courier_type?: SortOrder
    delivered_by?: SortOrder
    delivery_type?: SortOrder
    status?: SortOrder
    delivery_fee?: SortOrder
    courier_fee?: SortOrder
    timing?: SortOrder
    mode?: SortOrder
  }

  export type deliverysaleAvgOrderByAggregateInput = {
    id?: SortOrder
    sale_id?: SortOrder
    delivery_fee?: SortOrder
    courier_fee?: SortOrder
  }

  export type deliverysaleMaxOrderByAggregateInput = {
    id?: SortOrder
    sale_id?: SortOrder
    courier_id?: SortOrder
    courier_name?: SortOrder
    courier_phone?: SortOrder
    courier_type?: SortOrder
    delivered_by?: SortOrder
    delivery_type?: SortOrder
    status?: SortOrder
    delivery_fee?: SortOrder
    courier_fee?: SortOrder
    timing?: SortOrder
    mode?: SortOrder
  }

  export type deliverysaleMinOrderByAggregateInput = {
    id?: SortOrder
    sale_id?: SortOrder
    courier_id?: SortOrder
    courier_name?: SortOrder
    courier_phone?: SortOrder
    courier_type?: SortOrder
    delivered_by?: SortOrder
    delivery_type?: SortOrder
    status?: SortOrder
    delivery_fee?: SortOrder
    courier_fee?: SortOrder
    timing?: SortOrder
    mode?: SortOrder
  }

  export type deliverysaleSumOrderByAggregateInput = {
    id?: SortOrder
    sale_id?: SortOrder
    delivery_fee?: SortOrder
    courier_fee?: SortOrder
  }

  export type DeliverysaleNullableScalarRelationFilter = {
    is?: deliverysaleWhereInput | null
    isNot?: deliverysaleWhereInput | null
  }

  export type deliveryaddressCountOrderByAggregateInput = {
    id?: SortOrder
    sale_id?: SortOrder
    delivery_sale_id?: SortOrder
    street?: SortOrder
    number?: SortOrder
    complement?: SortOrder
    formatted_address?: SortOrder
    neighborhood?: SortOrder
    city?: SortOrder
    state?: SortOrder
    country?: SortOrder
    postal_code?: SortOrder
    reference?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
  }

  export type deliveryaddressAvgOrderByAggregateInput = {
    id?: SortOrder
    sale_id?: SortOrder
    delivery_sale_id?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
  }

  export type deliveryaddressMaxOrderByAggregateInput = {
    id?: SortOrder
    sale_id?: SortOrder
    delivery_sale_id?: SortOrder
    street?: SortOrder
    number?: SortOrder
    complement?: SortOrder
    formatted_address?: SortOrder
    neighborhood?: SortOrder
    city?: SortOrder
    state?: SortOrder
    country?: SortOrder
    postal_code?: SortOrder
    reference?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
  }

  export type deliveryaddressMinOrderByAggregateInput = {
    id?: SortOrder
    sale_id?: SortOrder
    delivery_sale_id?: SortOrder
    street?: SortOrder
    number?: SortOrder
    complement?: SortOrder
    formatted_address?: SortOrder
    neighborhood?: SortOrder
    city?: SortOrder
    state?: SortOrder
    country?: SortOrder
    postal_code?: SortOrder
    reference?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
  }

  export type deliveryaddressSumOrderByAggregateInput = {
    id?: SortOrder
    sale_id?: SortOrder
    delivery_sale_id?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
  }

  export type BrandNullableScalarRelationFilter = {
    is?: brandWhereInput | null
    isNot?: brandWhereInput | null
  }

  export type paymenttypeCountOrderByAggregateInput = {
    id?: SortOrder
    brand_id?: SortOrder
    description?: SortOrder
  }

  export type paymenttypeAvgOrderByAggregateInput = {
    id?: SortOrder
    brand_id?: SortOrder
  }

  export type paymenttypeMaxOrderByAggregateInput = {
    id?: SortOrder
    brand_id?: SortOrder
    description?: SortOrder
  }

  export type paymenttypeMinOrderByAggregateInput = {
    id?: SortOrder
    brand_id?: SortOrder
    description?: SortOrder
  }

  export type paymenttypeSumOrderByAggregateInput = {
    id?: SortOrder
    brand_id?: SortOrder
  }

  export type PaymenttypeNullableScalarRelationFilter = {
    is?: paymenttypeWhereInput | null
    isNot?: paymenttypeWhereInput | null
  }

  export type paymentCountOrderByAggregateInput = {
    id?: SortOrder
    sale_id?: SortOrder
    payment_type_id?: SortOrder
    value?: SortOrder
    is_online?: SortOrder
    description?: SortOrder
    currency?: SortOrder
  }

  export type paymentAvgOrderByAggregateInput = {
    id?: SortOrder
    sale_id?: SortOrder
    payment_type_id?: SortOrder
    value?: SortOrder
  }

  export type paymentMaxOrderByAggregateInput = {
    id?: SortOrder
    sale_id?: SortOrder
    payment_type_id?: SortOrder
    value?: SortOrder
    is_online?: SortOrder
    description?: SortOrder
    currency?: SortOrder
  }

  export type paymentMinOrderByAggregateInput = {
    id?: SortOrder
    sale_id?: SortOrder
    payment_type_id?: SortOrder
    value?: SortOrder
    is_online?: SortOrder
    description?: SortOrder
    currency?: SortOrder
  }

  export type paymentSumOrderByAggregateInput = {
    id?: SortOrder
    sale_id?: SortOrder
    payment_type_id?: SortOrder
    value?: SortOrder
  }

  export type couponCountOrderByAggregateInput = {
    id?: SortOrder
    brand_id?: SortOrder
    code?: SortOrder
    discount_type?: SortOrder
    discount_value?: SortOrder
    is_active?: SortOrder
    valid_from?: SortOrder
    valid_until?: SortOrder
  }

  export type couponAvgOrderByAggregateInput = {
    id?: SortOrder
    brand_id?: SortOrder
    discount_value?: SortOrder
  }

  export type couponMaxOrderByAggregateInput = {
    id?: SortOrder
    brand_id?: SortOrder
    code?: SortOrder
    discount_type?: SortOrder
    discount_value?: SortOrder
    is_active?: SortOrder
    valid_from?: SortOrder
    valid_until?: SortOrder
  }

  export type couponMinOrderByAggregateInput = {
    id?: SortOrder
    brand_id?: SortOrder
    code?: SortOrder
    discount_type?: SortOrder
    discount_value?: SortOrder
    is_active?: SortOrder
    valid_from?: SortOrder
    valid_until?: SortOrder
  }

  export type couponSumOrderByAggregateInput = {
    id?: SortOrder
    brand_id?: SortOrder
    discount_value?: SortOrder
  }

  export type SaleNullableScalarRelationFilter = {
    is?: saleWhereInput | null
    isNot?: saleWhereInput | null
  }

  export type CouponNullableScalarRelationFilter = {
    is?: couponWhereInput | null
    isNot?: couponWhereInput | null
  }

  export type couponsaleCountOrderByAggregateInput = {
    id?: SortOrder
    sale_id?: SortOrder
    coupon_id?: SortOrder
    value?: SortOrder
    target?: SortOrder
    sponsorship?: SortOrder
  }

  export type couponsaleAvgOrderByAggregateInput = {
    id?: SortOrder
    sale_id?: SortOrder
    coupon_id?: SortOrder
    value?: SortOrder
  }

  export type couponsaleMaxOrderByAggregateInput = {
    id?: SortOrder
    sale_id?: SortOrder
    coupon_id?: SortOrder
    value?: SortOrder
    target?: SortOrder
    sponsorship?: SortOrder
  }

  export type couponsaleMinOrderByAggregateInput = {
    id?: SortOrder
    sale_id?: SortOrder
    coupon_id?: SortOrder
    value?: SortOrder
    target?: SortOrder
    sponsorship?: SortOrder
  }

  export type couponsaleSumOrderByAggregateInput = {
    id?: SortOrder
    sale_id?: SortOrder
    coupon_id?: SortOrder
    value?: SortOrder
  }

  export type subbrandCreateNestedManyWithoutBrandInput = {
    create?: XOR<subbrandCreateWithoutBrandInput, subbrandUncheckedCreateWithoutBrandInput> | subbrandCreateWithoutBrandInput[] | subbrandUncheckedCreateWithoutBrandInput[]
    connectOrCreate?: subbrandCreateOrConnectWithoutBrandInput | subbrandCreateOrConnectWithoutBrandInput[]
    createMany?: subbrandCreateManyBrandInputEnvelope
    connect?: subbrandWhereUniqueInput | subbrandWhereUniqueInput[]
  }

  export type storeCreateNestedManyWithoutBrandInput = {
    create?: XOR<storeCreateWithoutBrandInput, storeUncheckedCreateWithoutBrandInput> | storeCreateWithoutBrandInput[] | storeUncheckedCreateWithoutBrandInput[]
    connectOrCreate?: storeCreateOrConnectWithoutBrandInput | storeCreateOrConnectWithoutBrandInput[]
    createMany?: storeCreateManyBrandInputEnvelope
    connect?: storeWhereUniqueInput | storeWhereUniqueInput[]
  }

  export type channelCreateNestedManyWithoutBrandInput = {
    create?: XOR<channelCreateWithoutBrandInput, channelUncheckedCreateWithoutBrandInput> | channelCreateWithoutBrandInput[] | channelUncheckedCreateWithoutBrandInput[]
    connectOrCreate?: channelCreateOrConnectWithoutBrandInput | channelCreateOrConnectWithoutBrandInput[]
    createMany?: channelCreateManyBrandInputEnvelope
    connect?: channelWhereUniqueInput | channelWhereUniqueInput[]
  }

  export type categoryCreateNestedManyWithoutBrandInput = {
    create?: XOR<categoryCreateWithoutBrandInput, categoryUncheckedCreateWithoutBrandInput> | categoryCreateWithoutBrandInput[] | categoryUncheckedCreateWithoutBrandInput[]
    connectOrCreate?: categoryCreateOrConnectWithoutBrandInput | categoryCreateOrConnectWithoutBrandInput[]
    createMany?: categoryCreateManyBrandInputEnvelope
    connect?: categoryWhereUniqueInput | categoryWhereUniqueInput[]
  }

  export type productCreateNestedManyWithoutBrandInput = {
    create?: XOR<productCreateWithoutBrandInput, productUncheckedCreateWithoutBrandInput> | productCreateWithoutBrandInput[] | productUncheckedCreateWithoutBrandInput[]
    connectOrCreate?: productCreateOrConnectWithoutBrandInput | productCreateOrConnectWithoutBrandInput[]
    createMany?: productCreateManyBrandInputEnvelope
    connect?: productWhereUniqueInput | productWhereUniqueInput[]
  }

  export type optiongroupCreateNestedManyWithoutBrandInput = {
    create?: XOR<optiongroupCreateWithoutBrandInput, optiongroupUncheckedCreateWithoutBrandInput> | optiongroupCreateWithoutBrandInput[] | optiongroupUncheckedCreateWithoutBrandInput[]
    connectOrCreate?: optiongroupCreateOrConnectWithoutBrandInput | optiongroupCreateOrConnectWithoutBrandInput[]
    createMany?: optiongroupCreateManyBrandInputEnvelope
    connect?: optiongroupWhereUniqueInput | optiongroupWhereUniqueInput[]
  }

  export type itemCreateNestedManyWithoutBrandInput = {
    create?: XOR<itemCreateWithoutBrandInput, itemUncheckedCreateWithoutBrandInput> | itemCreateWithoutBrandInput[] | itemUncheckedCreateWithoutBrandInput[]
    connectOrCreate?: itemCreateOrConnectWithoutBrandInput | itemCreateOrConnectWithoutBrandInput[]
    createMany?: itemCreateManyBrandInputEnvelope
    connect?: itemWhereUniqueInput | itemWhereUniqueInput[]
  }

  export type paymenttypeCreateNestedManyWithoutBrandInput = {
    create?: XOR<paymenttypeCreateWithoutBrandInput, paymenttypeUncheckedCreateWithoutBrandInput> | paymenttypeCreateWithoutBrandInput[] | paymenttypeUncheckedCreateWithoutBrandInput[]
    connectOrCreate?: paymenttypeCreateOrConnectWithoutBrandInput | paymenttypeCreateOrConnectWithoutBrandInput[]
    createMany?: paymenttypeCreateManyBrandInputEnvelope
    connect?: paymenttypeWhereUniqueInput | paymenttypeWhereUniqueInput[]
  }

  export type couponCreateNestedManyWithoutBrandInput = {
    create?: XOR<couponCreateWithoutBrandInput, couponUncheckedCreateWithoutBrandInput> | couponCreateWithoutBrandInput[] | couponUncheckedCreateWithoutBrandInput[]
    connectOrCreate?: couponCreateOrConnectWithoutBrandInput | couponCreateOrConnectWithoutBrandInput[]
    createMany?: couponCreateManyBrandInputEnvelope
    connect?: couponWhereUniqueInput | couponWhereUniqueInput[]
  }

  export type subbrandUncheckedCreateNestedManyWithoutBrandInput = {
    create?: XOR<subbrandCreateWithoutBrandInput, subbrandUncheckedCreateWithoutBrandInput> | subbrandCreateWithoutBrandInput[] | subbrandUncheckedCreateWithoutBrandInput[]
    connectOrCreate?: subbrandCreateOrConnectWithoutBrandInput | subbrandCreateOrConnectWithoutBrandInput[]
    createMany?: subbrandCreateManyBrandInputEnvelope
    connect?: subbrandWhereUniqueInput | subbrandWhereUniqueInput[]
  }

  export type storeUncheckedCreateNestedManyWithoutBrandInput = {
    create?: XOR<storeCreateWithoutBrandInput, storeUncheckedCreateWithoutBrandInput> | storeCreateWithoutBrandInput[] | storeUncheckedCreateWithoutBrandInput[]
    connectOrCreate?: storeCreateOrConnectWithoutBrandInput | storeCreateOrConnectWithoutBrandInput[]
    createMany?: storeCreateManyBrandInputEnvelope
    connect?: storeWhereUniqueInput | storeWhereUniqueInput[]
  }

  export type channelUncheckedCreateNestedManyWithoutBrandInput = {
    create?: XOR<channelCreateWithoutBrandInput, channelUncheckedCreateWithoutBrandInput> | channelCreateWithoutBrandInput[] | channelUncheckedCreateWithoutBrandInput[]
    connectOrCreate?: channelCreateOrConnectWithoutBrandInput | channelCreateOrConnectWithoutBrandInput[]
    createMany?: channelCreateManyBrandInputEnvelope
    connect?: channelWhereUniqueInput | channelWhereUniqueInput[]
  }

  export type categoryUncheckedCreateNestedManyWithoutBrandInput = {
    create?: XOR<categoryCreateWithoutBrandInput, categoryUncheckedCreateWithoutBrandInput> | categoryCreateWithoutBrandInput[] | categoryUncheckedCreateWithoutBrandInput[]
    connectOrCreate?: categoryCreateOrConnectWithoutBrandInput | categoryCreateOrConnectWithoutBrandInput[]
    createMany?: categoryCreateManyBrandInputEnvelope
    connect?: categoryWhereUniqueInput | categoryWhereUniqueInput[]
  }

  export type productUncheckedCreateNestedManyWithoutBrandInput = {
    create?: XOR<productCreateWithoutBrandInput, productUncheckedCreateWithoutBrandInput> | productCreateWithoutBrandInput[] | productUncheckedCreateWithoutBrandInput[]
    connectOrCreate?: productCreateOrConnectWithoutBrandInput | productCreateOrConnectWithoutBrandInput[]
    createMany?: productCreateManyBrandInputEnvelope
    connect?: productWhereUniqueInput | productWhereUniqueInput[]
  }

  export type optiongroupUncheckedCreateNestedManyWithoutBrandInput = {
    create?: XOR<optiongroupCreateWithoutBrandInput, optiongroupUncheckedCreateWithoutBrandInput> | optiongroupCreateWithoutBrandInput[] | optiongroupUncheckedCreateWithoutBrandInput[]
    connectOrCreate?: optiongroupCreateOrConnectWithoutBrandInput | optiongroupCreateOrConnectWithoutBrandInput[]
    createMany?: optiongroupCreateManyBrandInputEnvelope
    connect?: optiongroupWhereUniqueInput | optiongroupWhereUniqueInput[]
  }

  export type itemUncheckedCreateNestedManyWithoutBrandInput = {
    create?: XOR<itemCreateWithoutBrandInput, itemUncheckedCreateWithoutBrandInput> | itemCreateWithoutBrandInput[] | itemUncheckedCreateWithoutBrandInput[]
    connectOrCreate?: itemCreateOrConnectWithoutBrandInput | itemCreateOrConnectWithoutBrandInput[]
    createMany?: itemCreateManyBrandInputEnvelope
    connect?: itemWhereUniqueInput | itemWhereUniqueInput[]
  }

  export type paymenttypeUncheckedCreateNestedManyWithoutBrandInput = {
    create?: XOR<paymenttypeCreateWithoutBrandInput, paymenttypeUncheckedCreateWithoutBrandInput> | paymenttypeCreateWithoutBrandInput[] | paymenttypeUncheckedCreateWithoutBrandInput[]
    connectOrCreate?: paymenttypeCreateOrConnectWithoutBrandInput | paymenttypeCreateOrConnectWithoutBrandInput[]
    createMany?: paymenttypeCreateManyBrandInputEnvelope
    connect?: paymenttypeWhereUniqueInput | paymenttypeWhereUniqueInput[]
  }

  export type couponUncheckedCreateNestedManyWithoutBrandInput = {
    create?: XOR<couponCreateWithoutBrandInput, couponUncheckedCreateWithoutBrandInput> | couponCreateWithoutBrandInput[] | couponUncheckedCreateWithoutBrandInput[]
    connectOrCreate?: couponCreateOrConnectWithoutBrandInput | couponCreateOrConnectWithoutBrandInput[]
    createMany?: couponCreateManyBrandInputEnvelope
    connect?: couponWhereUniqueInput | couponWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type subbrandUpdateManyWithoutBrandNestedInput = {
    create?: XOR<subbrandCreateWithoutBrandInput, subbrandUncheckedCreateWithoutBrandInput> | subbrandCreateWithoutBrandInput[] | subbrandUncheckedCreateWithoutBrandInput[]
    connectOrCreate?: subbrandCreateOrConnectWithoutBrandInput | subbrandCreateOrConnectWithoutBrandInput[]
    upsert?: subbrandUpsertWithWhereUniqueWithoutBrandInput | subbrandUpsertWithWhereUniqueWithoutBrandInput[]
    createMany?: subbrandCreateManyBrandInputEnvelope
    set?: subbrandWhereUniqueInput | subbrandWhereUniqueInput[]
    disconnect?: subbrandWhereUniqueInput | subbrandWhereUniqueInput[]
    delete?: subbrandWhereUniqueInput | subbrandWhereUniqueInput[]
    connect?: subbrandWhereUniqueInput | subbrandWhereUniqueInput[]
    update?: subbrandUpdateWithWhereUniqueWithoutBrandInput | subbrandUpdateWithWhereUniqueWithoutBrandInput[]
    updateMany?: subbrandUpdateManyWithWhereWithoutBrandInput | subbrandUpdateManyWithWhereWithoutBrandInput[]
    deleteMany?: subbrandScalarWhereInput | subbrandScalarWhereInput[]
  }

  export type storeUpdateManyWithoutBrandNestedInput = {
    create?: XOR<storeCreateWithoutBrandInput, storeUncheckedCreateWithoutBrandInput> | storeCreateWithoutBrandInput[] | storeUncheckedCreateWithoutBrandInput[]
    connectOrCreate?: storeCreateOrConnectWithoutBrandInput | storeCreateOrConnectWithoutBrandInput[]
    upsert?: storeUpsertWithWhereUniqueWithoutBrandInput | storeUpsertWithWhereUniqueWithoutBrandInput[]
    createMany?: storeCreateManyBrandInputEnvelope
    set?: storeWhereUniqueInput | storeWhereUniqueInput[]
    disconnect?: storeWhereUniqueInput | storeWhereUniqueInput[]
    delete?: storeWhereUniqueInput | storeWhereUniqueInput[]
    connect?: storeWhereUniqueInput | storeWhereUniqueInput[]
    update?: storeUpdateWithWhereUniqueWithoutBrandInput | storeUpdateWithWhereUniqueWithoutBrandInput[]
    updateMany?: storeUpdateManyWithWhereWithoutBrandInput | storeUpdateManyWithWhereWithoutBrandInput[]
    deleteMany?: storeScalarWhereInput | storeScalarWhereInput[]
  }

  export type channelUpdateManyWithoutBrandNestedInput = {
    create?: XOR<channelCreateWithoutBrandInput, channelUncheckedCreateWithoutBrandInput> | channelCreateWithoutBrandInput[] | channelUncheckedCreateWithoutBrandInput[]
    connectOrCreate?: channelCreateOrConnectWithoutBrandInput | channelCreateOrConnectWithoutBrandInput[]
    upsert?: channelUpsertWithWhereUniqueWithoutBrandInput | channelUpsertWithWhereUniqueWithoutBrandInput[]
    createMany?: channelCreateManyBrandInputEnvelope
    set?: channelWhereUniqueInput | channelWhereUniqueInput[]
    disconnect?: channelWhereUniqueInput | channelWhereUniqueInput[]
    delete?: channelWhereUniqueInput | channelWhereUniqueInput[]
    connect?: channelWhereUniqueInput | channelWhereUniqueInput[]
    update?: channelUpdateWithWhereUniqueWithoutBrandInput | channelUpdateWithWhereUniqueWithoutBrandInput[]
    updateMany?: channelUpdateManyWithWhereWithoutBrandInput | channelUpdateManyWithWhereWithoutBrandInput[]
    deleteMany?: channelScalarWhereInput | channelScalarWhereInput[]
  }

  export type categoryUpdateManyWithoutBrandNestedInput = {
    create?: XOR<categoryCreateWithoutBrandInput, categoryUncheckedCreateWithoutBrandInput> | categoryCreateWithoutBrandInput[] | categoryUncheckedCreateWithoutBrandInput[]
    connectOrCreate?: categoryCreateOrConnectWithoutBrandInput | categoryCreateOrConnectWithoutBrandInput[]
    upsert?: categoryUpsertWithWhereUniqueWithoutBrandInput | categoryUpsertWithWhereUniqueWithoutBrandInput[]
    createMany?: categoryCreateManyBrandInputEnvelope
    set?: categoryWhereUniqueInput | categoryWhereUniqueInput[]
    disconnect?: categoryWhereUniqueInput | categoryWhereUniqueInput[]
    delete?: categoryWhereUniqueInput | categoryWhereUniqueInput[]
    connect?: categoryWhereUniqueInput | categoryWhereUniqueInput[]
    update?: categoryUpdateWithWhereUniqueWithoutBrandInput | categoryUpdateWithWhereUniqueWithoutBrandInput[]
    updateMany?: categoryUpdateManyWithWhereWithoutBrandInput | categoryUpdateManyWithWhereWithoutBrandInput[]
    deleteMany?: categoryScalarWhereInput | categoryScalarWhereInput[]
  }

  export type productUpdateManyWithoutBrandNestedInput = {
    create?: XOR<productCreateWithoutBrandInput, productUncheckedCreateWithoutBrandInput> | productCreateWithoutBrandInput[] | productUncheckedCreateWithoutBrandInput[]
    connectOrCreate?: productCreateOrConnectWithoutBrandInput | productCreateOrConnectWithoutBrandInput[]
    upsert?: productUpsertWithWhereUniqueWithoutBrandInput | productUpsertWithWhereUniqueWithoutBrandInput[]
    createMany?: productCreateManyBrandInputEnvelope
    set?: productWhereUniqueInput | productWhereUniqueInput[]
    disconnect?: productWhereUniqueInput | productWhereUniqueInput[]
    delete?: productWhereUniqueInput | productWhereUniqueInput[]
    connect?: productWhereUniqueInput | productWhereUniqueInput[]
    update?: productUpdateWithWhereUniqueWithoutBrandInput | productUpdateWithWhereUniqueWithoutBrandInput[]
    updateMany?: productUpdateManyWithWhereWithoutBrandInput | productUpdateManyWithWhereWithoutBrandInput[]
    deleteMany?: productScalarWhereInput | productScalarWhereInput[]
  }

  export type optiongroupUpdateManyWithoutBrandNestedInput = {
    create?: XOR<optiongroupCreateWithoutBrandInput, optiongroupUncheckedCreateWithoutBrandInput> | optiongroupCreateWithoutBrandInput[] | optiongroupUncheckedCreateWithoutBrandInput[]
    connectOrCreate?: optiongroupCreateOrConnectWithoutBrandInput | optiongroupCreateOrConnectWithoutBrandInput[]
    upsert?: optiongroupUpsertWithWhereUniqueWithoutBrandInput | optiongroupUpsertWithWhereUniqueWithoutBrandInput[]
    createMany?: optiongroupCreateManyBrandInputEnvelope
    set?: optiongroupWhereUniqueInput | optiongroupWhereUniqueInput[]
    disconnect?: optiongroupWhereUniqueInput | optiongroupWhereUniqueInput[]
    delete?: optiongroupWhereUniqueInput | optiongroupWhereUniqueInput[]
    connect?: optiongroupWhereUniqueInput | optiongroupWhereUniqueInput[]
    update?: optiongroupUpdateWithWhereUniqueWithoutBrandInput | optiongroupUpdateWithWhereUniqueWithoutBrandInput[]
    updateMany?: optiongroupUpdateManyWithWhereWithoutBrandInput | optiongroupUpdateManyWithWhereWithoutBrandInput[]
    deleteMany?: optiongroupScalarWhereInput | optiongroupScalarWhereInput[]
  }

  export type itemUpdateManyWithoutBrandNestedInput = {
    create?: XOR<itemCreateWithoutBrandInput, itemUncheckedCreateWithoutBrandInput> | itemCreateWithoutBrandInput[] | itemUncheckedCreateWithoutBrandInput[]
    connectOrCreate?: itemCreateOrConnectWithoutBrandInput | itemCreateOrConnectWithoutBrandInput[]
    upsert?: itemUpsertWithWhereUniqueWithoutBrandInput | itemUpsertWithWhereUniqueWithoutBrandInput[]
    createMany?: itemCreateManyBrandInputEnvelope
    set?: itemWhereUniqueInput | itemWhereUniqueInput[]
    disconnect?: itemWhereUniqueInput | itemWhereUniqueInput[]
    delete?: itemWhereUniqueInput | itemWhereUniqueInput[]
    connect?: itemWhereUniqueInput | itemWhereUniqueInput[]
    update?: itemUpdateWithWhereUniqueWithoutBrandInput | itemUpdateWithWhereUniqueWithoutBrandInput[]
    updateMany?: itemUpdateManyWithWhereWithoutBrandInput | itemUpdateManyWithWhereWithoutBrandInput[]
    deleteMany?: itemScalarWhereInput | itemScalarWhereInput[]
  }

  export type paymenttypeUpdateManyWithoutBrandNestedInput = {
    create?: XOR<paymenttypeCreateWithoutBrandInput, paymenttypeUncheckedCreateWithoutBrandInput> | paymenttypeCreateWithoutBrandInput[] | paymenttypeUncheckedCreateWithoutBrandInput[]
    connectOrCreate?: paymenttypeCreateOrConnectWithoutBrandInput | paymenttypeCreateOrConnectWithoutBrandInput[]
    upsert?: paymenttypeUpsertWithWhereUniqueWithoutBrandInput | paymenttypeUpsertWithWhereUniqueWithoutBrandInput[]
    createMany?: paymenttypeCreateManyBrandInputEnvelope
    set?: paymenttypeWhereUniqueInput | paymenttypeWhereUniqueInput[]
    disconnect?: paymenttypeWhereUniqueInput | paymenttypeWhereUniqueInput[]
    delete?: paymenttypeWhereUniqueInput | paymenttypeWhereUniqueInput[]
    connect?: paymenttypeWhereUniqueInput | paymenttypeWhereUniqueInput[]
    update?: paymenttypeUpdateWithWhereUniqueWithoutBrandInput | paymenttypeUpdateWithWhereUniqueWithoutBrandInput[]
    updateMany?: paymenttypeUpdateManyWithWhereWithoutBrandInput | paymenttypeUpdateManyWithWhereWithoutBrandInput[]
    deleteMany?: paymenttypeScalarWhereInput | paymenttypeScalarWhereInput[]
  }

  export type couponUpdateManyWithoutBrandNestedInput = {
    create?: XOR<couponCreateWithoutBrandInput, couponUncheckedCreateWithoutBrandInput> | couponCreateWithoutBrandInput[] | couponUncheckedCreateWithoutBrandInput[]
    connectOrCreate?: couponCreateOrConnectWithoutBrandInput | couponCreateOrConnectWithoutBrandInput[]
    upsert?: couponUpsertWithWhereUniqueWithoutBrandInput | couponUpsertWithWhereUniqueWithoutBrandInput[]
    createMany?: couponCreateManyBrandInputEnvelope
    set?: couponWhereUniqueInput | couponWhereUniqueInput[]
    disconnect?: couponWhereUniqueInput | couponWhereUniqueInput[]
    delete?: couponWhereUniqueInput | couponWhereUniqueInput[]
    connect?: couponWhereUniqueInput | couponWhereUniqueInput[]
    update?: couponUpdateWithWhereUniqueWithoutBrandInput | couponUpdateWithWhereUniqueWithoutBrandInput[]
    updateMany?: couponUpdateManyWithWhereWithoutBrandInput | couponUpdateManyWithWhereWithoutBrandInput[]
    deleteMany?: couponScalarWhereInput | couponScalarWhereInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type subbrandUncheckedUpdateManyWithoutBrandNestedInput = {
    create?: XOR<subbrandCreateWithoutBrandInput, subbrandUncheckedCreateWithoutBrandInput> | subbrandCreateWithoutBrandInput[] | subbrandUncheckedCreateWithoutBrandInput[]
    connectOrCreate?: subbrandCreateOrConnectWithoutBrandInput | subbrandCreateOrConnectWithoutBrandInput[]
    upsert?: subbrandUpsertWithWhereUniqueWithoutBrandInput | subbrandUpsertWithWhereUniqueWithoutBrandInput[]
    createMany?: subbrandCreateManyBrandInputEnvelope
    set?: subbrandWhereUniqueInput | subbrandWhereUniqueInput[]
    disconnect?: subbrandWhereUniqueInput | subbrandWhereUniqueInput[]
    delete?: subbrandWhereUniqueInput | subbrandWhereUniqueInput[]
    connect?: subbrandWhereUniqueInput | subbrandWhereUniqueInput[]
    update?: subbrandUpdateWithWhereUniqueWithoutBrandInput | subbrandUpdateWithWhereUniqueWithoutBrandInput[]
    updateMany?: subbrandUpdateManyWithWhereWithoutBrandInput | subbrandUpdateManyWithWhereWithoutBrandInput[]
    deleteMany?: subbrandScalarWhereInput | subbrandScalarWhereInput[]
  }

  export type storeUncheckedUpdateManyWithoutBrandNestedInput = {
    create?: XOR<storeCreateWithoutBrandInput, storeUncheckedCreateWithoutBrandInput> | storeCreateWithoutBrandInput[] | storeUncheckedCreateWithoutBrandInput[]
    connectOrCreate?: storeCreateOrConnectWithoutBrandInput | storeCreateOrConnectWithoutBrandInput[]
    upsert?: storeUpsertWithWhereUniqueWithoutBrandInput | storeUpsertWithWhereUniqueWithoutBrandInput[]
    createMany?: storeCreateManyBrandInputEnvelope
    set?: storeWhereUniqueInput | storeWhereUniqueInput[]
    disconnect?: storeWhereUniqueInput | storeWhereUniqueInput[]
    delete?: storeWhereUniqueInput | storeWhereUniqueInput[]
    connect?: storeWhereUniqueInput | storeWhereUniqueInput[]
    update?: storeUpdateWithWhereUniqueWithoutBrandInput | storeUpdateWithWhereUniqueWithoutBrandInput[]
    updateMany?: storeUpdateManyWithWhereWithoutBrandInput | storeUpdateManyWithWhereWithoutBrandInput[]
    deleteMany?: storeScalarWhereInput | storeScalarWhereInput[]
  }

  export type channelUncheckedUpdateManyWithoutBrandNestedInput = {
    create?: XOR<channelCreateWithoutBrandInput, channelUncheckedCreateWithoutBrandInput> | channelCreateWithoutBrandInput[] | channelUncheckedCreateWithoutBrandInput[]
    connectOrCreate?: channelCreateOrConnectWithoutBrandInput | channelCreateOrConnectWithoutBrandInput[]
    upsert?: channelUpsertWithWhereUniqueWithoutBrandInput | channelUpsertWithWhereUniqueWithoutBrandInput[]
    createMany?: channelCreateManyBrandInputEnvelope
    set?: channelWhereUniqueInput | channelWhereUniqueInput[]
    disconnect?: channelWhereUniqueInput | channelWhereUniqueInput[]
    delete?: channelWhereUniqueInput | channelWhereUniqueInput[]
    connect?: channelWhereUniqueInput | channelWhereUniqueInput[]
    update?: channelUpdateWithWhereUniqueWithoutBrandInput | channelUpdateWithWhereUniqueWithoutBrandInput[]
    updateMany?: channelUpdateManyWithWhereWithoutBrandInput | channelUpdateManyWithWhereWithoutBrandInput[]
    deleteMany?: channelScalarWhereInput | channelScalarWhereInput[]
  }

  export type categoryUncheckedUpdateManyWithoutBrandNestedInput = {
    create?: XOR<categoryCreateWithoutBrandInput, categoryUncheckedCreateWithoutBrandInput> | categoryCreateWithoutBrandInput[] | categoryUncheckedCreateWithoutBrandInput[]
    connectOrCreate?: categoryCreateOrConnectWithoutBrandInput | categoryCreateOrConnectWithoutBrandInput[]
    upsert?: categoryUpsertWithWhereUniqueWithoutBrandInput | categoryUpsertWithWhereUniqueWithoutBrandInput[]
    createMany?: categoryCreateManyBrandInputEnvelope
    set?: categoryWhereUniqueInput | categoryWhereUniqueInput[]
    disconnect?: categoryWhereUniqueInput | categoryWhereUniqueInput[]
    delete?: categoryWhereUniqueInput | categoryWhereUniqueInput[]
    connect?: categoryWhereUniqueInput | categoryWhereUniqueInput[]
    update?: categoryUpdateWithWhereUniqueWithoutBrandInput | categoryUpdateWithWhereUniqueWithoutBrandInput[]
    updateMany?: categoryUpdateManyWithWhereWithoutBrandInput | categoryUpdateManyWithWhereWithoutBrandInput[]
    deleteMany?: categoryScalarWhereInput | categoryScalarWhereInput[]
  }

  export type productUncheckedUpdateManyWithoutBrandNestedInput = {
    create?: XOR<productCreateWithoutBrandInput, productUncheckedCreateWithoutBrandInput> | productCreateWithoutBrandInput[] | productUncheckedCreateWithoutBrandInput[]
    connectOrCreate?: productCreateOrConnectWithoutBrandInput | productCreateOrConnectWithoutBrandInput[]
    upsert?: productUpsertWithWhereUniqueWithoutBrandInput | productUpsertWithWhereUniqueWithoutBrandInput[]
    createMany?: productCreateManyBrandInputEnvelope
    set?: productWhereUniqueInput | productWhereUniqueInput[]
    disconnect?: productWhereUniqueInput | productWhereUniqueInput[]
    delete?: productWhereUniqueInput | productWhereUniqueInput[]
    connect?: productWhereUniqueInput | productWhereUniqueInput[]
    update?: productUpdateWithWhereUniqueWithoutBrandInput | productUpdateWithWhereUniqueWithoutBrandInput[]
    updateMany?: productUpdateManyWithWhereWithoutBrandInput | productUpdateManyWithWhereWithoutBrandInput[]
    deleteMany?: productScalarWhereInput | productScalarWhereInput[]
  }

  export type optiongroupUncheckedUpdateManyWithoutBrandNestedInput = {
    create?: XOR<optiongroupCreateWithoutBrandInput, optiongroupUncheckedCreateWithoutBrandInput> | optiongroupCreateWithoutBrandInput[] | optiongroupUncheckedCreateWithoutBrandInput[]
    connectOrCreate?: optiongroupCreateOrConnectWithoutBrandInput | optiongroupCreateOrConnectWithoutBrandInput[]
    upsert?: optiongroupUpsertWithWhereUniqueWithoutBrandInput | optiongroupUpsertWithWhereUniqueWithoutBrandInput[]
    createMany?: optiongroupCreateManyBrandInputEnvelope
    set?: optiongroupWhereUniqueInput | optiongroupWhereUniqueInput[]
    disconnect?: optiongroupWhereUniqueInput | optiongroupWhereUniqueInput[]
    delete?: optiongroupWhereUniqueInput | optiongroupWhereUniqueInput[]
    connect?: optiongroupWhereUniqueInput | optiongroupWhereUniqueInput[]
    update?: optiongroupUpdateWithWhereUniqueWithoutBrandInput | optiongroupUpdateWithWhereUniqueWithoutBrandInput[]
    updateMany?: optiongroupUpdateManyWithWhereWithoutBrandInput | optiongroupUpdateManyWithWhereWithoutBrandInput[]
    deleteMany?: optiongroupScalarWhereInput | optiongroupScalarWhereInput[]
  }

  export type itemUncheckedUpdateManyWithoutBrandNestedInput = {
    create?: XOR<itemCreateWithoutBrandInput, itemUncheckedCreateWithoutBrandInput> | itemCreateWithoutBrandInput[] | itemUncheckedCreateWithoutBrandInput[]
    connectOrCreate?: itemCreateOrConnectWithoutBrandInput | itemCreateOrConnectWithoutBrandInput[]
    upsert?: itemUpsertWithWhereUniqueWithoutBrandInput | itemUpsertWithWhereUniqueWithoutBrandInput[]
    createMany?: itemCreateManyBrandInputEnvelope
    set?: itemWhereUniqueInput | itemWhereUniqueInput[]
    disconnect?: itemWhereUniqueInput | itemWhereUniqueInput[]
    delete?: itemWhereUniqueInput | itemWhereUniqueInput[]
    connect?: itemWhereUniqueInput | itemWhereUniqueInput[]
    update?: itemUpdateWithWhereUniqueWithoutBrandInput | itemUpdateWithWhereUniqueWithoutBrandInput[]
    updateMany?: itemUpdateManyWithWhereWithoutBrandInput | itemUpdateManyWithWhereWithoutBrandInput[]
    deleteMany?: itemScalarWhereInput | itemScalarWhereInput[]
  }

  export type paymenttypeUncheckedUpdateManyWithoutBrandNestedInput = {
    create?: XOR<paymenttypeCreateWithoutBrandInput, paymenttypeUncheckedCreateWithoutBrandInput> | paymenttypeCreateWithoutBrandInput[] | paymenttypeUncheckedCreateWithoutBrandInput[]
    connectOrCreate?: paymenttypeCreateOrConnectWithoutBrandInput | paymenttypeCreateOrConnectWithoutBrandInput[]
    upsert?: paymenttypeUpsertWithWhereUniqueWithoutBrandInput | paymenttypeUpsertWithWhereUniqueWithoutBrandInput[]
    createMany?: paymenttypeCreateManyBrandInputEnvelope
    set?: paymenttypeWhereUniqueInput | paymenttypeWhereUniqueInput[]
    disconnect?: paymenttypeWhereUniqueInput | paymenttypeWhereUniqueInput[]
    delete?: paymenttypeWhereUniqueInput | paymenttypeWhereUniqueInput[]
    connect?: paymenttypeWhereUniqueInput | paymenttypeWhereUniqueInput[]
    update?: paymenttypeUpdateWithWhereUniqueWithoutBrandInput | paymenttypeUpdateWithWhereUniqueWithoutBrandInput[]
    updateMany?: paymenttypeUpdateManyWithWhereWithoutBrandInput | paymenttypeUpdateManyWithWhereWithoutBrandInput[]
    deleteMany?: paymenttypeScalarWhereInput | paymenttypeScalarWhereInput[]
  }

  export type couponUncheckedUpdateManyWithoutBrandNestedInput = {
    create?: XOR<couponCreateWithoutBrandInput, couponUncheckedCreateWithoutBrandInput> | couponCreateWithoutBrandInput[] | couponUncheckedCreateWithoutBrandInput[]
    connectOrCreate?: couponCreateOrConnectWithoutBrandInput | couponCreateOrConnectWithoutBrandInput[]
    upsert?: couponUpsertWithWhereUniqueWithoutBrandInput | couponUpsertWithWhereUniqueWithoutBrandInput[]
    createMany?: couponCreateManyBrandInputEnvelope
    set?: couponWhereUniqueInput | couponWhereUniqueInput[]
    disconnect?: couponWhereUniqueInput | couponWhereUniqueInput[]
    delete?: couponWhereUniqueInput | couponWhereUniqueInput[]
    connect?: couponWhereUniqueInput | couponWhereUniqueInput[]
    update?: couponUpdateWithWhereUniqueWithoutBrandInput | couponUpdateWithWhereUniqueWithoutBrandInput[]
    updateMany?: couponUpdateManyWithWhereWithoutBrandInput | couponUpdateManyWithWhereWithoutBrandInput[]
    deleteMany?: couponScalarWhereInput | couponScalarWhereInput[]
  }

  export type brandCreateNestedOneWithoutSubbrandsInput = {
    create?: XOR<brandCreateWithoutSubbrandsInput, brandUncheckedCreateWithoutSubbrandsInput>
    connectOrCreate?: brandCreateOrConnectWithoutSubbrandsInput
    connect?: brandWhereUniqueInput
  }

  export type storeCreateNestedManyWithoutSubbrandInput = {
    create?: XOR<storeCreateWithoutSubbrandInput, storeUncheckedCreateWithoutSubbrandInput> | storeCreateWithoutSubbrandInput[] | storeUncheckedCreateWithoutSubbrandInput[]
    connectOrCreate?: storeCreateOrConnectWithoutSubbrandInput | storeCreateOrConnectWithoutSubbrandInput[]
    createMany?: storeCreateManySubbrandInputEnvelope
    connect?: storeWhereUniqueInput | storeWhereUniqueInput[]
  }

  export type categoryCreateNestedManyWithoutSubbrandInput = {
    create?: XOR<categoryCreateWithoutSubbrandInput, categoryUncheckedCreateWithoutSubbrandInput> | categoryCreateWithoutSubbrandInput[] | categoryUncheckedCreateWithoutSubbrandInput[]
    connectOrCreate?: categoryCreateOrConnectWithoutSubbrandInput | categoryCreateOrConnectWithoutSubbrandInput[]
    createMany?: categoryCreateManySubbrandInputEnvelope
    connect?: categoryWhereUniqueInput | categoryWhereUniqueInput[]
  }

  export type productCreateNestedManyWithoutSubbrandInput = {
    create?: XOR<productCreateWithoutSubbrandInput, productUncheckedCreateWithoutSubbrandInput> | productCreateWithoutSubbrandInput[] | productUncheckedCreateWithoutSubbrandInput[]
    connectOrCreate?: productCreateOrConnectWithoutSubbrandInput | productCreateOrConnectWithoutSubbrandInput[]
    createMany?: productCreateManySubbrandInputEnvelope
    connect?: productWhereUniqueInput | productWhereUniqueInput[]
  }

  export type optiongroupCreateNestedManyWithoutSubbrandInput = {
    create?: XOR<optiongroupCreateWithoutSubbrandInput, optiongroupUncheckedCreateWithoutSubbrandInput> | optiongroupCreateWithoutSubbrandInput[] | optiongroupUncheckedCreateWithoutSubbrandInput[]
    connectOrCreate?: optiongroupCreateOrConnectWithoutSubbrandInput | optiongroupCreateOrConnectWithoutSubbrandInput[]
    createMany?: optiongroupCreateManySubbrandInputEnvelope
    connect?: optiongroupWhereUniqueInput | optiongroupWhereUniqueInput[]
  }

  export type itemCreateNestedManyWithoutSubbrandInput = {
    create?: XOR<itemCreateWithoutSubbrandInput, itemUncheckedCreateWithoutSubbrandInput> | itemCreateWithoutSubbrandInput[] | itemUncheckedCreateWithoutSubbrandInput[]
    connectOrCreate?: itemCreateOrConnectWithoutSubbrandInput | itemCreateOrConnectWithoutSubbrandInput[]
    createMany?: itemCreateManySubbrandInputEnvelope
    connect?: itemWhereUniqueInput | itemWhereUniqueInput[]
  }

  export type customerCreateNestedManyWithoutSubbrandInput = {
    create?: XOR<customerCreateWithoutSubbrandInput, customerUncheckedCreateWithoutSubbrandInput> | customerCreateWithoutSubbrandInput[] | customerUncheckedCreateWithoutSubbrandInput[]
    connectOrCreate?: customerCreateOrConnectWithoutSubbrandInput | customerCreateOrConnectWithoutSubbrandInput[]
    createMany?: customerCreateManySubbrandInputEnvelope
    connect?: customerWhereUniqueInput | customerWhereUniqueInput[]
  }

  export type saleCreateNestedManyWithoutSubbrandInput = {
    create?: XOR<saleCreateWithoutSubbrandInput, saleUncheckedCreateWithoutSubbrandInput> | saleCreateWithoutSubbrandInput[] | saleUncheckedCreateWithoutSubbrandInput[]
    connectOrCreate?: saleCreateOrConnectWithoutSubbrandInput | saleCreateOrConnectWithoutSubbrandInput[]
    createMany?: saleCreateManySubbrandInputEnvelope
    connect?: saleWhereUniqueInput | saleWhereUniqueInput[]
  }

  export type storeUncheckedCreateNestedManyWithoutSubbrandInput = {
    create?: XOR<storeCreateWithoutSubbrandInput, storeUncheckedCreateWithoutSubbrandInput> | storeCreateWithoutSubbrandInput[] | storeUncheckedCreateWithoutSubbrandInput[]
    connectOrCreate?: storeCreateOrConnectWithoutSubbrandInput | storeCreateOrConnectWithoutSubbrandInput[]
    createMany?: storeCreateManySubbrandInputEnvelope
    connect?: storeWhereUniqueInput | storeWhereUniqueInput[]
  }

  export type categoryUncheckedCreateNestedManyWithoutSubbrandInput = {
    create?: XOR<categoryCreateWithoutSubbrandInput, categoryUncheckedCreateWithoutSubbrandInput> | categoryCreateWithoutSubbrandInput[] | categoryUncheckedCreateWithoutSubbrandInput[]
    connectOrCreate?: categoryCreateOrConnectWithoutSubbrandInput | categoryCreateOrConnectWithoutSubbrandInput[]
    createMany?: categoryCreateManySubbrandInputEnvelope
    connect?: categoryWhereUniqueInput | categoryWhereUniqueInput[]
  }

  export type productUncheckedCreateNestedManyWithoutSubbrandInput = {
    create?: XOR<productCreateWithoutSubbrandInput, productUncheckedCreateWithoutSubbrandInput> | productCreateWithoutSubbrandInput[] | productUncheckedCreateWithoutSubbrandInput[]
    connectOrCreate?: productCreateOrConnectWithoutSubbrandInput | productCreateOrConnectWithoutSubbrandInput[]
    createMany?: productCreateManySubbrandInputEnvelope
    connect?: productWhereUniqueInput | productWhereUniqueInput[]
  }

  export type optiongroupUncheckedCreateNestedManyWithoutSubbrandInput = {
    create?: XOR<optiongroupCreateWithoutSubbrandInput, optiongroupUncheckedCreateWithoutSubbrandInput> | optiongroupCreateWithoutSubbrandInput[] | optiongroupUncheckedCreateWithoutSubbrandInput[]
    connectOrCreate?: optiongroupCreateOrConnectWithoutSubbrandInput | optiongroupCreateOrConnectWithoutSubbrandInput[]
    createMany?: optiongroupCreateManySubbrandInputEnvelope
    connect?: optiongroupWhereUniqueInput | optiongroupWhereUniqueInput[]
  }

  export type itemUncheckedCreateNestedManyWithoutSubbrandInput = {
    create?: XOR<itemCreateWithoutSubbrandInput, itemUncheckedCreateWithoutSubbrandInput> | itemCreateWithoutSubbrandInput[] | itemUncheckedCreateWithoutSubbrandInput[]
    connectOrCreate?: itemCreateOrConnectWithoutSubbrandInput | itemCreateOrConnectWithoutSubbrandInput[]
    createMany?: itemCreateManySubbrandInputEnvelope
    connect?: itemWhereUniqueInput | itemWhereUniqueInput[]
  }

  export type customerUncheckedCreateNestedManyWithoutSubbrandInput = {
    create?: XOR<customerCreateWithoutSubbrandInput, customerUncheckedCreateWithoutSubbrandInput> | customerCreateWithoutSubbrandInput[] | customerUncheckedCreateWithoutSubbrandInput[]
    connectOrCreate?: customerCreateOrConnectWithoutSubbrandInput | customerCreateOrConnectWithoutSubbrandInput[]
    createMany?: customerCreateManySubbrandInputEnvelope
    connect?: customerWhereUniqueInput | customerWhereUniqueInput[]
  }

  export type saleUncheckedCreateNestedManyWithoutSubbrandInput = {
    create?: XOR<saleCreateWithoutSubbrandInput, saleUncheckedCreateWithoutSubbrandInput> | saleCreateWithoutSubbrandInput[] | saleUncheckedCreateWithoutSubbrandInput[]
    connectOrCreate?: saleCreateOrConnectWithoutSubbrandInput | saleCreateOrConnectWithoutSubbrandInput[]
    createMany?: saleCreateManySubbrandInputEnvelope
    connect?: saleWhereUniqueInput | saleWhereUniqueInput[]
  }

  export type brandUpdateOneRequiredWithoutSubbrandsNestedInput = {
    create?: XOR<brandCreateWithoutSubbrandsInput, brandUncheckedCreateWithoutSubbrandsInput>
    connectOrCreate?: brandCreateOrConnectWithoutSubbrandsInput
    upsert?: brandUpsertWithoutSubbrandsInput
    connect?: brandWhereUniqueInput
    update?: XOR<XOR<brandUpdateToOneWithWhereWithoutSubbrandsInput, brandUpdateWithoutSubbrandsInput>, brandUncheckedUpdateWithoutSubbrandsInput>
  }

  export type storeUpdateManyWithoutSubbrandNestedInput = {
    create?: XOR<storeCreateWithoutSubbrandInput, storeUncheckedCreateWithoutSubbrandInput> | storeCreateWithoutSubbrandInput[] | storeUncheckedCreateWithoutSubbrandInput[]
    connectOrCreate?: storeCreateOrConnectWithoutSubbrandInput | storeCreateOrConnectWithoutSubbrandInput[]
    upsert?: storeUpsertWithWhereUniqueWithoutSubbrandInput | storeUpsertWithWhereUniqueWithoutSubbrandInput[]
    createMany?: storeCreateManySubbrandInputEnvelope
    set?: storeWhereUniqueInput | storeWhereUniqueInput[]
    disconnect?: storeWhereUniqueInput | storeWhereUniqueInput[]
    delete?: storeWhereUniqueInput | storeWhereUniqueInput[]
    connect?: storeWhereUniqueInput | storeWhereUniqueInput[]
    update?: storeUpdateWithWhereUniqueWithoutSubbrandInput | storeUpdateWithWhereUniqueWithoutSubbrandInput[]
    updateMany?: storeUpdateManyWithWhereWithoutSubbrandInput | storeUpdateManyWithWhereWithoutSubbrandInput[]
    deleteMany?: storeScalarWhereInput | storeScalarWhereInput[]
  }

  export type categoryUpdateManyWithoutSubbrandNestedInput = {
    create?: XOR<categoryCreateWithoutSubbrandInput, categoryUncheckedCreateWithoutSubbrandInput> | categoryCreateWithoutSubbrandInput[] | categoryUncheckedCreateWithoutSubbrandInput[]
    connectOrCreate?: categoryCreateOrConnectWithoutSubbrandInput | categoryCreateOrConnectWithoutSubbrandInput[]
    upsert?: categoryUpsertWithWhereUniqueWithoutSubbrandInput | categoryUpsertWithWhereUniqueWithoutSubbrandInput[]
    createMany?: categoryCreateManySubbrandInputEnvelope
    set?: categoryWhereUniqueInput | categoryWhereUniqueInput[]
    disconnect?: categoryWhereUniqueInput | categoryWhereUniqueInput[]
    delete?: categoryWhereUniqueInput | categoryWhereUniqueInput[]
    connect?: categoryWhereUniqueInput | categoryWhereUniqueInput[]
    update?: categoryUpdateWithWhereUniqueWithoutSubbrandInput | categoryUpdateWithWhereUniqueWithoutSubbrandInput[]
    updateMany?: categoryUpdateManyWithWhereWithoutSubbrandInput | categoryUpdateManyWithWhereWithoutSubbrandInput[]
    deleteMany?: categoryScalarWhereInput | categoryScalarWhereInput[]
  }

  export type productUpdateManyWithoutSubbrandNestedInput = {
    create?: XOR<productCreateWithoutSubbrandInput, productUncheckedCreateWithoutSubbrandInput> | productCreateWithoutSubbrandInput[] | productUncheckedCreateWithoutSubbrandInput[]
    connectOrCreate?: productCreateOrConnectWithoutSubbrandInput | productCreateOrConnectWithoutSubbrandInput[]
    upsert?: productUpsertWithWhereUniqueWithoutSubbrandInput | productUpsertWithWhereUniqueWithoutSubbrandInput[]
    createMany?: productCreateManySubbrandInputEnvelope
    set?: productWhereUniqueInput | productWhereUniqueInput[]
    disconnect?: productWhereUniqueInput | productWhereUniqueInput[]
    delete?: productWhereUniqueInput | productWhereUniqueInput[]
    connect?: productWhereUniqueInput | productWhereUniqueInput[]
    update?: productUpdateWithWhereUniqueWithoutSubbrandInput | productUpdateWithWhereUniqueWithoutSubbrandInput[]
    updateMany?: productUpdateManyWithWhereWithoutSubbrandInput | productUpdateManyWithWhereWithoutSubbrandInput[]
    deleteMany?: productScalarWhereInput | productScalarWhereInput[]
  }

  export type optiongroupUpdateManyWithoutSubbrandNestedInput = {
    create?: XOR<optiongroupCreateWithoutSubbrandInput, optiongroupUncheckedCreateWithoutSubbrandInput> | optiongroupCreateWithoutSubbrandInput[] | optiongroupUncheckedCreateWithoutSubbrandInput[]
    connectOrCreate?: optiongroupCreateOrConnectWithoutSubbrandInput | optiongroupCreateOrConnectWithoutSubbrandInput[]
    upsert?: optiongroupUpsertWithWhereUniqueWithoutSubbrandInput | optiongroupUpsertWithWhereUniqueWithoutSubbrandInput[]
    createMany?: optiongroupCreateManySubbrandInputEnvelope
    set?: optiongroupWhereUniqueInput | optiongroupWhereUniqueInput[]
    disconnect?: optiongroupWhereUniqueInput | optiongroupWhereUniqueInput[]
    delete?: optiongroupWhereUniqueInput | optiongroupWhereUniqueInput[]
    connect?: optiongroupWhereUniqueInput | optiongroupWhereUniqueInput[]
    update?: optiongroupUpdateWithWhereUniqueWithoutSubbrandInput | optiongroupUpdateWithWhereUniqueWithoutSubbrandInput[]
    updateMany?: optiongroupUpdateManyWithWhereWithoutSubbrandInput | optiongroupUpdateManyWithWhereWithoutSubbrandInput[]
    deleteMany?: optiongroupScalarWhereInput | optiongroupScalarWhereInput[]
  }

  export type itemUpdateManyWithoutSubbrandNestedInput = {
    create?: XOR<itemCreateWithoutSubbrandInput, itemUncheckedCreateWithoutSubbrandInput> | itemCreateWithoutSubbrandInput[] | itemUncheckedCreateWithoutSubbrandInput[]
    connectOrCreate?: itemCreateOrConnectWithoutSubbrandInput | itemCreateOrConnectWithoutSubbrandInput[]
    upsert?: itemUpsertWithWhereUniqueWithoutSubbrandInput | itemUpsertWithWhereUniqueWithoutSubbrandInput[]
    createMany?: itemCreateManySubbrandInputEnvelope
    set?: itemWhereUniqueInput | itemWhereUniqueInput[]
    disconnect?: itemWhereUniqueInput | itemWhereUniqueInput[]
    delete?: itemWhereUniqueInput | itemWhereUniqueInput[]
    connect?: itemWhereUniqueInput | itemWhereUniqueInput[]
    update?: itemUpdateWithWhereUniqueWithoutSubbrandInput | itemUpdateWithWhereUniqueWithoutSubbrandInput[]
    updateMany?: itemUpdateManyWithWhereWithoutSubbrandInput | itemUpdateManyWithWhereWithoutSubbrandInput[]
    deleteMany?: itemScalarWhereInput | itemScalarWhereInput[]
  }

  export type customerUpdateManyWithoutSubbrandNestedInput = {
    create?: XOR<customerCreateWithoutSubbrandInput, customerUncheckedCreateWithoutSubbrandInput> | customerCreateWithoutSubbrandInput[] | customerUncheckedCreateWithoutSubbrandInput[]
    connectOrCreate?: customerCreateOrConnectWithoutSubbrandInput | customerCreateOrConnectWithoutSubbrandInput[]
    upsert?: customerUpsertWithWhereUniqueWithoutSubbrandInput | customerUpsertWithWhereUniqueWithoutSubbrandInput[]
    createMany?: customerCreateManySubbrandInputEnvelope
    set?: customerWhereUniqueInput | customerWhereUniqueInput[]
    disconnect?: customerWhereUniqueInput | customerWhereUniqueInput[]
    delete?: customerWhereUniqueInput | customerWhereUniqueInput[]
    connect?: customerWhereUniqueInput | customerWhereUniqueInput[]
    update?: customerUpdateWithWhereUniqueWithoutSubbrandInput | customerUpdateWithWhereUniqueWithoutSubbrandInput[]
    updateMany?: customerUpdateManyWithWhereWithoutSubbrandInput | customerUpdateManyWithWhereWithoutSubbrandInput[]
    deleteMany?: customerScalarWhereInput | customerScalarWhereInput[]
  }

  export type saleUpdateManyWithoutSubbrandNestedInput = {
    create?: XOR<saleCreateWithoutSubbrandInput, saleUncheckedCreateWithoutSubbrandInput> | saleCreateWithoutSubbrandInput[] | saleUncheckedCreateWithoutSubbrandInput[]
    connectOrCreate?: saleCreateOrConnectWithoutSubbrandInput | saleCreateOrConnectWithoutSubbrandInput[]
    upsert?: saleUpsertWithWhereUniqueWithoutSubbrandInput | saleUpsertWithWhereUniqueWithoutSubbrandInput[]
    createMany?: saleCreateManySubbrandInputEnvelope
    set?: saleWhereUniqueInput | saleWhereUniqueInput[]
    disconnect?: saleWhereUniqueInput | saleWhereUniqueInput[]
    delete?: saleWhereUniqueInput | saleWhereUniqueInput[]
    connect?: saleWhereUniqueInput | saleWhereUniqueInput[]
    update?: saleUpdateWithWhereUniqueWithoutSubbrandInput | saleUpdateWithWhereUniqueWithoutSubbrandInput[]
    updateMany?: saleUpdateManyWithWhereWithoutSubbrandInput | saleUpdateManyWithWhereWithoutSubbrandInput[]
    deleteMany?: saleScalarWhereInput | saleScalarWhereInput[]
  }

  export type storeUncheckedUpdateManyWithoutSubbrandNestedInput = {
    create?: XOR<storeCreateWithoutSubbrandInput, storeUncheckedCreateWithoutSubbrandInput> | storeCreateWithoutSubbrandInput[] | storeUncheckedCreateWithoutSubbrandInput[]
    connectOrCreate?: storeCreateOrConnectWithoutSubbrandInput | storeCreateOrConnectWithoutSubbrandInput[]
    upsert?: storeUpsertWithWhereUniqueWithoutSubbrandInput | storeUpsertWithWhereUniqueWithoutSubbrandInput[]
    createMany?: storeCreateManySubbrandInputEnvelope
    set?: storeWhereUniqueInput | storeWhereUniqueInput[]
    disconnect?: storeWhereUniqueInput | storeWhereUniqueInput[]
    delete?: storeWhereUniqueInput | storeWhereUniqueInput[]
    connect?: storeWhereUniqueInput | storeWhereUniqueInput[]
    update?: storeUpdateWithWhereUniqueWithoutSubbrandInput | storeUpdateWithWhereUniqueWithoutSubbrandInput[]
    updateMany?: storeUpdateManyWithWhereWithoutSubbrandInput | storeUpdateManyWithWhereWithoutSubbrandInput[]
    deleteMany?: storeScalarWhereInput | storeScalarWhereInput[]
  }

  export type categoryUncheckedUpdateManyWithoutSubbrandNestedInput = {
    create?: XOR<categoryCreateWithoutSubbrandInput, categoryUncheckedCreateWithoutSubbrandInput> | categoryCreateWithoutSubbrandInput[] | categoryUncheckedCreateWithoutSubbrandInput[]
    connectOrCreate?: categoryCreateOrConnectWithoutSubbrandInput | categoryCreateOrConnectWithoutSubbrandInput[]
    upsert?: categoryUpsertWithWhereUniqueWithoutSubbrandInput | categoryUpsertWithWhereUniqueWithoutSubbrandInput[]
    createMany?: categoryCreateManySubbrandInputEnvelope
    set?: categoryWhereUniqueInput | categoryWhereUniqueInput[]
    disconnect?: categoryWhereUniqueInput | categoryWhereUniqueInput[]
    delete?: categoryWhereUniqueInput | categoryWhereUniqueInput[]
    connect?: categoryWhereUniqueInput | categoryWhereUniqueInput[]
    update?: categoryUpdateWithWhereUniqueWithoutSubbrandInput | categoryUpdateWithWhereUniqueWithoutSubbrandInput[]
    updateMany?: categoryUpdateManyWithWhereWithoutSubbrandInput | categoryUpdateManyWithWhereWithoutSubbrandInput[]
    deleteMany?: categoryScalarWhereInput | categoryScalarWhereInput[]
  }

  export type productUncheckedUpdateManyWithoutSubbrandNestedInput = {
    create?: XOR<productCreateWithoutSubbrandInput, productUncheckedCreateWithoutSubbrandInput> | productCreateWithoutSubbrandInput[] | productUncheckedCreateWithoutSubbrandInput[]
    connectOrCreate?: productCreateOrConnectWithoutSubbrandInput | productCreateOrConnectWithoutSubbrandInput[]
    upsert?: productUpsertWithWhereUniqueWithoutSubbrandInput | productUpsertWithWhereUniqueWithoutSubbrandInput[]
    createMany?: productCreateManySubbrandInputEnvelope
    set?: productWhereUniqueInput | productWhereUniqueInput[]
    disconnect?: productWhereUniqueInput | productWhereUniqueInput[]
    delete?: productWhereUniqueInput | productWhereUniqueInput[]
    connect?: productWhereUniqueInput | productWhereUniqueInput[]
    update?: productUpdateWithWhereUniqueWithoutSubbrandInput | productUpdateWithWhereUniqueWithoutSubbrandInput[]
    updateMany?: productUpdateManyWithWhereWithoutSubbrandInput | productUpdateManyWithWhereWithoutSubbrandInput[]
    deleteMany?: productScalarWhereInput | productScalarWhereInput[]
  }

  export type optiongroupUncheckedUpdateManyWithoutSubbrandNestedInput = {
    create?: XOR<optiongroupCreateWithoutSubbrandInput, optiongroupUncheckedCreateWithoutSubbrandInput> | optiongroupCreateWithoutSubbrandInput[] | optiongroupUncheckedCreateWithoutSubbrandInput[]
    connectOrCreate?: optiongroupCreateOrConnectWithoutSubbrandInput | optiongroupCreateOrConnectWithoutSubbrandInput[]
    upsert?: optiongroupUpsertWithWhereUniqueWithoutSubbrandInput | optiongroupUpsertWithWhereUniqueWithoutSubbrandInput[]
    createMany?: optiongroupCreateManySubbrandInputEnvelope
    set?: optiongroupWhereUniqueInput | optiongroupWhereUniqueInput[]
    disconnect?: optiongroupWhereUniqueInput | optiongroupWhereUniqueInput[]
    delete?: optiongroupWhereUniqueInput | optiongroupWhereUniqueInput[]
    connect?: optiongroupWhereUniqueInput | optiongroupWhereUniqueInput[]
    update?: optiongroupUpdateWithWhereUniqueWithoutSubbrandInput | optiongroupUpdateWithWhereUniqueWithoutSubbrandInput[]
    updateMany?: optiongroupUpdateManyWithWhereWithoutSubbrandInput | optiongroupUpdateManyWithWhereWithoutSubbrandInput[]
    deleteMany?: optiongroupScalarWhereInput | optiongroupScalarWhereInput[]
  }

  export type itemUncheckedUpdateManyWithoutSubbrandNestedInput = {
    create?: XOR<itemCreateWithoutSubbrandInput, itemUncheckedCreateWithoutSubbrandInput> | itemCreateWithoutSubbrandInput[] | itemUncheckedCreateWithoutSubbrandInput[]
    connectOrCreate?: itemCreateOrConnectWithoutSubbrandInput | itemCreateOrConnectWithoutSubbrandInput[]
    upsert?: itemUpsertWithWhereUniqueWithoutSubbrandInput | itemUpsertWithWhereUniqueWithoutSubbrandInput[]
    createMany?: itemCreateManySubbrandInputEnvelope
    set?: itemWhereUniqueInput | itemWhereUniqueInput[]
    disconnect?: itemWhereUniqueInput | itemWhereUniqueInput[]
    delete?: itemWhereUniqueInput | itemWhereUniqueInput[]
    connect?: itemWhereUniqueInput | itemWhereUniqueInput[]
    update?: itemUpdateWithWhereUniqueWithoutSubbrandInput | itemUpdateWithWhereUniqueWithoutSubbrandInput[]
    updateMany?: itemUpdateManyWithWhereWithoutSubbrandInput | itemUpdateManyWithWhereWithoutSubbrandInput[]
    deleteMany?: itemScalarWhereInput | itemScalarWhereInput[]
  }

  export type customerUncheckedUpdateManyWithoutSubbrandNestedInput = {
    create?: XOR<customerCreateWithoutSubbrandInput, customerUncheckedCreateWithoutSubbrandInput> | customerCreateWithoutSubbrandInput[] | customerUncheckedCreateWithoutSubbrandInput[]
    connectOrCreate?: customerCreateOrConnectWithoutSubbrandInput | customerCreateOrConnectWithoutSubbrandInput[]
    upsert?: customerUpsertWithWhereUniqueWithoutSubbrandInput | customerUpsertWithWhereUniqueWithoutSubbrandInput[]
    createMany?: customerCreateManySubbrandInputEnvelope
    set?: customerWhereUniqueInput | customerWhereUniqueInput[]
    disconnect?: customerWhereUniqueInput | customerWhereUniqueInput[]
    delete?: customerWhereUniqueInput | customerWhereUniqueInput[]
    connect?: customerWhereUniqueInput | customerWhereUniqueInput[]
    update?: customerUpdateWithWhereUniqueWithoutSubbrandInput | customerUpdateWithWhereUniqueWithoutSubbrandInput[]
    updateMany?: customerUpdateManyWithWhereWithoutSubbrandInput | customerUpdateManyWithWhereWithoutSubbrandInput[]
    deleteMany?: customerScalarWhereInput | customerScalarWhereInput[]
  }

  export type saleUncheckedUpdateManyWithoutSubbrandNestedInput = {
    create?: XOR<saleCreateWithoutSubbrandInput, saleUncheckedCreateWithoutSubbrandInput> | saleCreateWithoutSubbrandInput[] | saleUncheckedCreateWithoutSubbrandInput[]
    connectOrCreate?: saleCreateOrConnectWithoutSubbrandInput | saleCreateOrConnectWithoutSubbrandInput[]
    upsert?: saleUpsertWithWhereUniqueWithoutSubbrandInput | saleUpsertWithWhereUniqueWithoutSubbrandInput[]
    createMany?: saleCreateManySubbrandInputEnvelope
    set?: saleWhereUniqueInput | saleWhereUniqueInput[]
    disconnect?: saleWhereUniqueInput | saleWhereUniqueInput[]
    delete?: saleWhereUniqueInput | saleWhereUniqueInput[]
    connect?: saleWhereUniqueInput | saleWhereUniqueInput[]
    update?: saleUpdateWithWhereUniqueWithoutSubbrandInput | saleUpdateWithWhereUniqueWithoutSubbrandInput[]
    updateMany?: saleUpdateManyWithWhereWithoutSubbrandInput | saleUpdateManyWithWhereWithoutSubbrandInput[]
    deleteMany?: saleScalarWhereInput | saleScalarWhereInput[]
  }

  export type brandCreateNestedOneWithoutStoresInput = {
    create?: XOR<brandCreateWithoutStoresInput, brandUncheckedCreateWithoutStoresInput>
    connectOrCreate?: brandCreateOrConnectWithoutStoresInput
    connect?: brandWhereUniqueInput
  }

  export type subbrandCreateNestedOneWithoutStoresInput = {
    create?: XOR<subbrandCreateWithoutStoresInput, subbrandUncheckedCreateWithoutStoresInput>
    connectOrCreate?: subbrandCreateOrConnectWithoutStoresInput
    connect?: subbrandWhereUniqueInput
  }

  export type customerCreateNestedManyWithoutStoreInput = {
    create?: XOR<customerCreateWithoutStoreInput, customerUncheckedCreateWithoutStoreInput> | customerCreateWithoutStoreInput[] | customerUncheckedCreateWithoutStoreInput[]
    connectOrCreate?: customerCreateOrConnectWithoutStoreInput | customerCreateOrConnectWithoutStoreInput[]
    createMany?: customerCreateManyStoreInputEnvelope
    connect?: customerWhereUniqueInput | customerWhereUniqueInput[]
  }

  export type saleCreateNestedManyWithoutStoreInput = {
    create?: XOR<saleCreateWithoutStoreInput, saleUncheckedCreateWithoutStoreInput> | saleCreateWithoutStoreInput[] | saleUncheckedCreateWithoutStoreInput[]
    connectOrCreate?: saleCreateOrConnectWithoutStoreInput | saleCreateOrConnectWithoutStoreInput[]
    createMany?: saleCreateManyStoreInputEnvelope
    connect?: saleWhereUniqueInput | saleWhereUniqueInput[]
  }

  export type customerUncheckedCreateNestedManyWithoutStoreInput = {
    create?: XOR<customerCreateWithoutStoreInput, customerUncheckedCreateWithoutStoreInput> | customerCreateWithoutStoreInput[] | customerUncheckedCreateWithoutStoreInput[]
    connectOrCreate?: customerCreateOrConnectWithoutStoreInput | customerCreateOrConnectWithoutStoreInput[]
    createMany?: customerCreateManyStoreInputEnvelope
    connect?: customerWhereUniqueInput | customerWhereUniqueInput[]
  }

  export type saleUncheckedCreateNestedManyWithoutStoreInput = {
    create?: XOR<saleCreateWithoutStoreInput, saleUncheckedCreateWithoutStoreInput> | saleCreateWithoutStoreInput[] | saleUncheckedCreateWithoutStoreInput[]
    connectOrCreate?: saleCreateOrConnectWithoutStoreInput | saleCreateOrConnectWithoutStoreInput[]
    createMany?: saleCreateManyStoreInputEnvelope
    connect?: saleWhereUniqueInput | saleWhereUniqueInput[]
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableDecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string | null
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type NullableBoolFieldUpdateOperationsInput = {
    set?: boolean | null
  }

  export type brandUpdateOneRequiredWithoutStoresNestedInput = {
    create?: XOR<brandCreateWithoutStoresInput, brandUncheckedCreateWithoutStoresInput>
    connectOrCreate?: brandCreateOrConnectWithoutStoresInput
    upsert?: brandUpsertWithoutStoresInput
    connect?: brandWhereUniqueInput
    update?: XOR<XOR<brandUpdateToOneWithWhereWithoutStoresInput, brandUpdateWithoutStoresInput>, brandUncheckedUpdateWithoutStoresInput>
  }

  export type subbrandUpdateOneWithoutStoresNestedInput = {
    create?: XOR<subbrandCreateWithoutStoresInput, subbrandUncheckedCreateWithoutStoresInput>
    connectOrCreate?: subbrandCreateOrConnectWithoutStoresInput
    upsert?: subbrandUpsertWithoutStoresInput
    disconnect?: subbrandWhereInput | boolean
    delete?: subbrandWhereInput | boolean
    connect?: subbrandWhereUniqueInput
    update?: XOR<XOR<subbrandUpdateToOneWithWhereWithoutStoresInput, subbrandUpdateWithoutStoresInput>, subbrandUncheckedUpdateWithoutStoresInput>
  }

  export type customerUpdateManyWithoutStoreNestedInput = {
    create?: XOR<customerCreateWithoutStoreInput, customerUncheckedCreateWithoutStoreInput> | customerCreateWithoutStoreInput[] | customerUncheckedCreateWithoutStoreInput[]
    connectOrCreate?: customerCreateOrConnectWithoutStoreInput | customerCreateOrConnectWithoutStoreInput[]
    upsert?: customerUpsertWithWhereUniqueWithoutStoreInput | customerUpsertWithWhereUniqueWithoutStoreInput[]
    createMany?: customerCreateManyStoreInputEnvelope
    set?: customerWhereUniqueInput | customerWhereUniqueInput[]
    disconnect?: customerWhereUniqueInput | customerWhereUniqueInput[]
    delete?: customerWhereUniqueInput | customerWhereUniqueInput[]
    connect?: customerWhereUniqueInput | customerWhereUniqueInput[]
    update?: customerUpdateWithWhereUniqueWithoutStoreInput | customerUpdateWithWhereUniqueWithoutStoreInput[]
    updateMany?: customerUpdateManyWithWhereWithoutStoreInput | customerUpdateManyWithWhereWithoutStoreInput[]
    deleteMany?: customerScalarWhereInput | customerScalarWhereInput[]
  }

  export type saleUpdateManyWithoutStoreNestedInput = {
    create?: XOR<saleCreateWithoutStoreInput, saleUncheckedCreateWithoutStoreInput> | saleCreateWithoutStoreInput[] | saleUncheckedCreateWithoutStoreInput[]
    connectOrCreate?: saleCreateOrConnectWithoutStoreInput | saleCreateOrConnectWithoutStoreInput[]
    upsert?: saleUpsertWithWhereUniqueWithoutStoreInput | saleUpsertWithWhereUniqueWithoutStoreInput[]
    createMany?: saleCreateManyStoreInputEnvelope
    set?: saleWhereUniqueInput | saleWhereUniqueInput[]
    disconnect?: saleWhereUniqueInput | saleWhereUniqueInput[]
    delete?: saleWhereUniqueInput | saleWhereUniqueInput[]
    connect?: saleWhereUniqueInput | saleWhereUniqueInput[]
    update?: saleUpdateWithWhereUniqueWithoutStoreInput | saleUpdateWithWhereUniqueWithoutStoreInput[]
    updateMany?: saleUpdateManyWithWhereWithoutStoreInput | saleUpdateManyWithWhereWithoutStoreInput[]
    deleteMany?: saleScalarWhereInput | saleScalarWhereInput[]
  }

  export type customerUncheckedUpdateManyWithoutStoreNestedInput = {
    create?: XOR<customerCreateWithoutStoreInput, customerUncheckedCreateWithoutStoreInput> | customerCreateWithoutStoreInput[] | customerUncheckedCreateWithoutStoreInput[]
    connectOrCreate?: customerCreateOrConnectWithoutStoreInput | customerCreateOrConnectWithoutStoreInput[]
    upsert?: customerUpsertWithWhereUniqueWithoutStoreInput | customerUpsertWithWhereUniqueWithoutStoreInput[]
    createMany?: customerCreateManyStoreInputEnvelope
    set?: customerWhereUniqueInput | customerWhereUniqueInput[]
    disconnect?: customerWhereUniqueInput | customerWhereUniqueInput[]
    delete?: customerWhereUniqueInput | customerWhereUniqueInput[]
    connect?: customerWhereUniqueInput | customerWhereUniqueInput[]
    update?: customerUpdateWithWhereUniqueWithoutStoreInput | customerUpdateWithWhereUniqueWithoutStoreInput[]
    updateMany?: customerUpdateManyWithWhereWithoutStoreInput | customerUpdateManyWithWhereWithoutStoreInput[]
    deleteMany?: customerScalarWhereInput | customerScalarWhereInput[]
  }

  export type saleUncheckedUpdateManyWithoutStoreNestedInput = {
    create?: XOR<saleCreateWithoutStoreInput, saleUncheckedCreateWithoutStoreInput> | saleCreateWithoutStoreInput[] | saleUncheckedCreateWithoutStoreInput[]
    connectOrCreate?: saleCreateOrConnectWithoutStoreInput | saleCreateOrConnectWithoutStoreInput[]
    upsert?: saleUpsertWithWhereUniqueWithoutStoreInput | saleUpsertWithWhereUniqueWithoutStoreInput[]
    createMany?: saleCreateManyStoreInputEnvelope
    set?: saleWhereUniqueInput | saleWhereUniqueInput[]
    disconnect?: saleWhereUniqueInput | saleWhereUniqueInput[]
    delete?: saleWhereUniqueInput | saleWhereUniqueInput[]
    connect?: saleWhereUniqueInput | saleWhereUniqueInput[]
    update?: saleUpdateWithWhereUniqueWithoutStoreInput | saleUpdateWithWhereUniqueWithoutStoreInput[]
    updateMany?: saleUpdateManyWithWhereWithoutStoreInput | saleUpdateManyWithWhereWithoutStoreInput[]
    deleteMany?: saleScalarWhereInput | saleScalarWhereInput[]
  }

  export type brandCreateNestedOneWithoutChannelsInput = {
    create?: XOR<brandCreateWithoutChannelsInput, brandUncheckedCreateWithoutChannelsInput>
    connectOrCreate?: brandCreateOrConnectWithoutChannelsInput
    connect?: brandWhereUniqueInput
  }

  export type saleCreateNestedManyWithoutChannelInput = {
    create?: XOR<saleCreateWithoutChannelInput, saleUncheckedCreateWithoutChannelInput> | saleCreateWithoutChannelInput[] | saleUncheckedCreateWithoutChannelInput[]
    connectOrCreate?: saleCreateOrConnectWithoutChannelInput | saleCreateOrConnectWithoutChannelInput[]
    createMany?: saleCreateManyChannelInputEnvelope
    connect?: saleWhereUniqueInput | saleWhereUniqueInput[]
  }

  export type saleUncheckedCreateNestedManyWithoutChannelInput = {
    create?: XOR<saleCreateWithoutChannelInput, saleUncheckedCreateWithoutChannelInput> | saleCreateWithoutChannelInput[] | saleUncheckedCreateWithoutChannelInput[]
    connectOrCreate?: saleCreateOrConnectWithoutChannelInput | saleCreateOrConnectWithoutChannelInput[]
    createMany?: saleCreateManyChannelInputEnvelope
    connect?: saleWhereUniqueInput | saleWhereUniqueInput[]
  }

  export type brandUpdateOneRequiredWithoutChannelsNestedInput = {
    create?: XOR<brandCreateWithoutChannelsInput, brandUncheckedCreateWithoutChannelsInput>
    connectOrCreate?: brandCreateOrConnectWithoutChannelsInput
    upsert?: brandUpsertWithoutChannelsInput
    connect?: brandWhereUniqueInput
    update?: XOR<XOR<brandUpdateToOneWithWhereWithoutChannelsInput, brandUpdateWithoutChannelsInput>, brandUncheckedUpdateWithoutChannelsInput>
  }

  export type saleUpdateManyWithoutChannelNestedInput = {
    create?: XOR<saleCreateWithoutChannelInput, saleUncheckedCreateWithoutChannelInput> | saleCreateWithoutChannelInput[] | saleUncheckedCreateWithoutChannelInput[]
    connectOrCreate?: saleCreateOrConnectWithoutChannelInput | saleCreateOrConnectWithoutChannelInput[]
    upsert?: saleUpsertWithWhereUniqueWithoutChannelInput | saleUpsertWithWhereUniqueWithoutChannelInput[]
    createMany?: saleCreateManyChannelInputEnvelope
    set?: saleWhereUniqueInput | saleWhereUniqueInput[]
    disconnect?: saleWhereUniqueInput | saleWhereUniqueInput[]
    delete?: saleWhereUniqueInput | saleWhereUniqueInput[]
    connect?: saleWhereUniqueInput | saleWhereUniqueInput[]
    update?: saleUpdateWithWhereUniqueWithoutChannelInput | saleUpdateWithWhereUniqueWithoutChannelInput[]
    updateMany?: saleUpdateManyWithWhereWithoutChannelInput | saleUpdateManyWithWhereWithoutChannelInput[]
    deleteMany?: saleScalarWhereInput | saleScalarWhereInput[]
  }

  export type saleUncheckedUpdateManyWithoutChannelNestedInput = {
    create?: XOR<saleCreateWithoutChannelInput, saleUncheckedCreateWithoutChannelInput> | saleCreateWithoutChannelInput[] | saleUncheckedCreateWithoutChannelInput[]
    connectOrCreate?: saleCreateOrConnectWithoutChannelInput | saleCreateOrConnectWithoutChannelInput[]
    upsert?: saleUpsertWithWhereUniqueWithoutChannelInput | saleUpsertWithWhereUniqueWithoutChannelInput[]
    createMany?: saleCreateManyChannelInputEnvelope
    set?: saleWhereUniqueInput | saleWhereUniqueInput[]
    disconnect?: saleWhereUniqueInput | saleWhereUniqueInput[]
    delete?: saleWhereUniqueInput | saleWhereUniqueInput[]
    connect?: saleWhereUniqueInput | saleWhereUniqueInput[]
    update?: saleUpdateWithWhereUniqueWithoutChannelInput | saleUpdateWithWhereUniqueWithoutChannelInput[]
    updateMany?: saleUpdateManyWithWhereWithoutChannelInput | saleUpdateManyWithWhereWithoutChannelInput[]
    deleteMany?: saleScalarWhereInput | saleScalarWhereInput[]
  }

  export type brandCreateNestedOneWithoutCategoriesInput = {
    create?: XOR<brandCreateWithoutCategoriesInput, brandUncheckedCreateWithoutCategoriesInput>
    connectOrCreate?: brandCreateOrConnectWithoutCategoriesInput
    connect?: brandWhereUniqueInput
  }

  export type subbrandCreateNestedOneWithoutCategoriesInput = {
    create?: XOR<subbrandCreateWithoutCategoriesInput, subbrandUncheckedCreateWithoutCategoriesInput>
    connectOrCreate?: subbrandCreateOrConnectWithoutCategoriesInput
    connect?: subbrandWhereUniqueInput
  }

  export type productCreateNestedManyWithoutCategoryInput = {
    create?: XOR<productCreateWithoutCategoryInput, productUncheckedCreateWithoutCategoryInput> | productCreateWithoutCategoryInput[] | productUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: productCreateOrConnectWithoutCategoryInput | productCreateOrConnectWithoutCategoryInput[]
    createMany?: productCreateManyCategoryInputEnvelope
    connect?: productWhereUniqueInput | productWhereUniqueInput[]
  }

  export type optiongroupCreateNestedManyWithoutCategoryInput = {
    create?: XOR<optiongroupCreateWithoutCategoryInput, optiongroupUncheckedCreateWithoutCategoryInput> | optiongroupCreateWithoutCategoryInput[] | optiongroupUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: optiongroupCreateOrConnectWithoutCategoryInput | optiongroupCreateOrConnectWithoutCategoryInput[]
    createMany?: optiongroupCreateManyCategoryInputEnvelope
    connect?: optiongroupWhereUniqueInput | optiongroupWhereUniqueInput[]
  }

  export type itemCreateNestedManyWithoutCategoryInput = {
    create?: XOR<itemCreateWithoutCategoryInput, itemUncheckedCreateWithoutCategoryInput> | itemCreateWithoutCategoryInput[] | itemUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: itemCreateOrConnectWithoutCategoryInput | itemCreateOrConnectWithoutCategoryInput[]
    createMany?: itemCreateManyCategoryInputEnvelope
    connect?: itemWhereUniqueInput | itemWhereUniqueInput[]
  }

  export type productUncheckedCreateNestedManyWithoutCategoryInput = {
    create?: XOR<productCreateWithoutCategoryInput, productUncheckedCreateWithoutCategoryInput> | productCreateWithoutCategoryInput[] | productUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: productCreateOrConnectWithoutCategoryInput | productCreateOrConnectWithoutCategoryInput[]
    createMany?: productCreateManyCategoryInputEnvelope
    connect?: productWhereUniqueInput | productWhereUniqueInput[]
  }

  export type optiongroupUncheckedCreateNestedManyWithoutCategoryInput = {
    create?: XOR<optiongroupCreateWithoutCategoryInput, optiongroupUncheckedCreateWithoutCategoryInput> | optiongroupCreateWithoutCategoryInput[] | optiongroupUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: optiongroupCreateOrConnectWithoutCategoryInput | optiongroupCreateOrConnectWithoutCategoryInput[]
    createMany?: optiongroupCreateManyCategoryInputEnvelope
    connect?: optiongroupWhereUniqueInput | optiongroupWhereUniqueInput[]
  }

  export type itemUncheckedCreateNestedManyWithoutCategoryInput = {
    create?: XOR<itemCreateWithoutCategoryInput, itemUncheckedCreateWithoutCategoryInput> | itemCreateWithoutCategoryInput[] | itemUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: itemCreateOrConnectWithoutCategoryInput | itemCreateOrConnectWithoutCategoryInput[]
    createMany?: itemCreateManyCategoryInputEnvelope
    connect?: itemWhereUniqueInput | itemWhereUniqueInput[]
  }

  export type brandUpdateOneRequiredWithoutCategoriesNestedInput = {
    create?: XOR<brandCreateWithoutCategoriesInput, brandUncheckedCreateWithoutCategoriesInput>
    connectOrCreate?: brandCreateOrConnectWithoutCategoriesInput
    upsert?: brandUpsertWithoutCategoriesInput
    connect?: brandWhereUniqueInput
    update?: XOR<XOR<brandUpdateToOneWithWhereWithoutCategoriesInput, brandUpdateWithoutCategoriesInput>, brandUncheckedUpdateWithoutCategoriesInput>
  }

  export type subbrandUpdateOneWithoutCategoriesNestedInput = {
    create?: XOR<subbrandCreateWithoutCategoriesInput, subbrandUncheckedCreateWithoutCategoriesInput>
    connectOrCreate?: subbrandCreateOrConnectWithoutCategoriesInput
    upsert?: subbrandUpsertWithoutCategoriesInput
    disconnect?: subbrandWhereInput | boolean
    delete?: subbrandWhereInput | boolean
    connect?: subbrandWhereUniqueInput
    update?: XOR<XOR<subbrandUpdateToOneWithWhereWithoutCategoriesInput, subbrandUpdateWithoutCategoriesInput>, subbrandUncheckedUpdateWithoutCategoriesInput>
  }

  export type productUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<productCreateWithoutCategoryInput, productUncheckedCreateWithoutCategoryInput> | productCreateWithoutCategoryInput[] | productUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: productCreateOrConnectWithoutCategoryInput | productCreateOrConnectWithoutCategoryInput[]
    upsert?: productUpsertWithWhereUniqueWithoutCategoryInput | productUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: productCreateManyCategoryInputEnvelope
    set?: productWhereUniqueInput | productWhereUniqueInput[]
    disconnect?: productWhereUniqueInput | productWhereUniqueInput[]
    delete?: productWhereUniqueInput | productWhereUniqueInput[]
    connect?: productWhereUniqueInput | productWhereUniqueInput[]
    update?: productUpdateWithWhereUniqueWithoutCategoryInput | productUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: productUpdateManyWithWhereWithoutCategoryInput | productUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: productScalarWhereInput | productScalarWhereInput[]
  }

  export type optiongroupUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<optiongroupCreateWithoutCategoryInput, optiongroupUncheckedCreateWithoutCategoryInput> | optiongroupCreateWithoutCategoryInput[] | optiongroupUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: optiongroupCreateOrConnectWithoutCategoryInput | optiongroupCreateOrConnectWithoutCategoryInput[]
    upsert?: optiongroupUpsertWithWhereUniqueWithoutCategoryInput | optiongroupUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: optiongroupCreateManyCategoryInputEnvelope
    set?: optiongroupWhereUniqueInput | optiongroupWhereUniqueInput[]
    disconnect?: optiongroupWhereUniqueInput | optiongroupWhereUniqueInput[]
    delete?: optiongroupWhereUniqueInput | optiongroupWhereUniqueInput[]
    connect?: optiongroupWhereUniqueInput | optiongroupWhereUniqueInput[]
    update?: optiongroupUpdateWithWhereUniqueWithoutCategoryInput | optiongroupUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: optiongroupUpdateManyWithWhereWithoutCategoryInput | optiongroupUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: optiongroupScalarWhereInput | optiongroupScalarWhereInput[]
  }

  export type itemUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<itemCreateWithoutCategoryInput, itemUncheckedCreateWithoutCategoryInput> | itemCreateWithoutCategoryInput[] | itemUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: itemCreateOrConnectWithoutCategoryInput | itemCreateOrConnectWithoutCategoryInput[]
    upsert?: itemUpsertWithWhereUniqueWithoutCategoryInput | itemUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: itemCreateManyCategoryInputEnvelope
    set?: itemWhereUniqueInput | itemWhereUniqueInput[]
    disconnect?: itemWhereUniqueInput | itemWhereUniqueInput[]
    delete?: itemWhereUniqueInput | itemWhereUniqueInput[]
    connect?: itemWhereUniqueInput | itemWhereUniqueInput[]
    update?: itemUpdateWithWhereUniqueWithoutCategoryInput | itemUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: itemUpdateManyWithWhereWithoutCategoryInput | itemUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: itemScalarWhereInput | itemScalarWhereInput[]
  }

  export type productUncheckedUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<productCreateWithoutCategoryInput, productUncheckedCreateWithoutCategoryInput> | productCreateWithoutCategoryInput[] | productUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: productCreateOrConnectWithoutCategoryInput | productCreateOrConnectWithoutCategoryInput[]
    upsert?: productUpsertWithWhereUniqueWithoutCategoryInput | productUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: productCreateManyCategoryInputEnvelope
    set?: productWhereUniqueInput | productWhereUniqueInput[]
    disconnect?: productWhereUniqueInput | productWhereUniqueInput[]
    delete?: productWhereUniqueInput | productWhereUniqueInput[]
    connect?: productWhereUniqueInput | productWhereUniqueInput[]
    update?: productUpdateWithWhereUniqueWithoutCategoryInput | productUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: productUpdateManyWithWhereWithoutCategoryInput | productUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: productScalarWhereInput | productScalarWhereInput[]
  }

  export type optiongroupUncheckedUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<optiongroupCreateWithoutCategoryInput, optiongroupUncheckedCreateWithoutCategoryInput> | optiongroupCreateWithoutCategoryInput[] | optiongroupUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: optiongroupCreateOrConnectWithoutCategoryInput | optiongroupCreateOrConnectWithoutCategoryInput[]
    upsert?: optiongroupUpsertWithWhereUniqueWithoutCategoryInput | optiongroupUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: optiongroupCreateManyCategoryInputEnvelope
    set?: optiongroupWhereUniqueInput | optiongroupWhereUniqueInput[]
    disconnect?: optiongroupWhereUniqueInput | optiongroupWhereUniqueInput[]
    delete?: optiongroupWhereUniqueInput | optiongroupWhereUniqueInput[]
    connect?: optiongroupWhereUniqueInput | optiongroupWhereUniqueInput[]
    update?: optiongroupUpdateWithWhereUniqueWithoutCategoryInput | optiongroupUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: optiongroupUpdateManyWithWhereWithoutCategoryInput | optiongroupUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: optiongroupScalarWhereInput | optiongroupScalarWhereInput[]
  }

  export type itemUncheckedUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<itemCreateWithoutCategoryInput, itemUncheckedCreateWithoutCategoryInput> | itemCreateWithoutCategoryInput[] | itemUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: itemCreateOrConnectWithoutCategoryInput | itemCreateOrConnectWithoutCategoryInput[]
    upsert?: itemUpsertWithWhereUniqueWithoutCategoryInput | itemUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: itemCreateManyCategoryInputEnvelope
    set?: itemWhereUniqueInput | itemWhereUniqueInput[]
    disconnect?: itemWhereUniqueInput | itemWhereUniqueInput[]
    delete?: itemWhereUniqueInput | itemWhereUniqueInput[]
    connect?: itemWhereUniqueInput | itemWhereUniqueInput[]
    update?: itemUpdateWithWhereUniqueWithoutCategoryInput | itemUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: itemUpdateManyWithWhereWithoutCategoryInput | itemUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: itemScalarWhereInput | itemScalarWhereInput[]
  }

  export type brandCreateNestedOneWithoutProductsInput = {
    create?: XOR<brandCreateWithoutProductsInput, brandUncheckedCreateWithoutProductsInput>
    connectOrCreate?: brandCreateOrConnectWithoutProductsInput
    connect?: brandWhereUniqueInput
  }

  export type subbrandCreateNestedOneWithoutProductsInput = {
    create?: XOR<subbrandCreateWithoutProductsInput, subbrandUncheckedCreateWithoutProductsInput>
    connectOrCreate?: subbrandCreateOrConnectWithoutProductsInput
    connect?: subbrandWhereUniqueInput
  }

  export type categoryCreateNestedOneWithoutProductsInput = {
    create?: XOR<categoryCreateWithoutProductsInput, categoryUncheckedCreateWithoutProductsInput>
    connectOrCreate?: categoryCreateOrConnectWithoutProductsInput
    connect?: categoryWhereUniqueInput
  }

  export type productsaleCreateNestedManyWithoutProductInput = {
    create?: XOR<productsaleCreateWithoutProductInput, productsaleUncheckedCreateWithoutProductInput> | productsaleCreateWithoutProductInput[] | productsaleUncheckedCreateWithoutProductInput[]
    connectOrCreate?: productsaleCreateOrConnectWithoutProductInput | productsaleCreateOrConnectWithoutProductInput[]
    createMany?: productsaleCreateManyProductInputEnvelope
    connect?: productsaleWhereUniqueInput | productsaleWhereUniqueInput[]
  }

  export type productsaleUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<productsaleCreateWithoutProductInput, productsaleUncheckedCreateWithoutProductInput> | productsaleCreateWithoutProductInput[] | productsaleUncheckedCreateWithoutProductInput[]
    connectOrCreate?: productsaleCreateOrConnectWithoutProductInput | productsaleCreateOrConnectWithoutProductInput[]
    createMany?: productsaleCreateManyProductInputEnvelope
    connect?: productsaleWhereUniqueInput | productsaleWhereUniqueInput[]
  }

  export type brandUpdateOneRequiredWithoutProductsNestedInput = {
    create?: XOR<brandCreateWithoutProductsInput, brandUncheckedCreateWithoutProductsInput>
    connectOrCreate?: brandCreateOrConnectWithoutProductsInput
    upsert?: brandUpsertWithoutProductsInput
    connect?: brandWhereUniqueInput
    update?: XOR<XOR<brandUpdateToOneWithWhereWithoutProductsInput, brandUpdateWithoutProductsInput>, brandUncheckedUpdateWithoutProductsInput>
  }

  export type subbrandUpdateOneWithoutProductsNestedInput = {
    create?: XOR<subbrandCreateWithoutProductsInput, subbrandUncheckedCreateWithoutProductsInput>
    connectOrCreate?: subbrandCreateOrConnectWithoutProductsInput
    upsert?: subbrandUpsertWithoutProductsInput
    disconnect?: subbrandWhereInput | boolean
    delete?: subbrandWhereInput | boolean
    connect?: subbrandWhereUniqueInput
    update?: XOR<XOR<subbrandUpdateToOneWithWhereWithoutProductsInput, subbrandUpdateWithoutProductsInput>, subbrandUncheckedUpdateWithoutProductsInput>
  }

  export type categoryUpdateOneWithoutProductsNestedInput = {
    create?: XOR<categoryCreateWithoutProductsInput, categoryUncheckedCreateWithoutProductsInput>
    connectOrCreate?: categoryCreateOrConnectWithoutProductsInput
    upsert?: categoryUpsertWithoutProductsInput
    disconnect?: categoryWhereInput | boolean
    delete?: categoryWhereInput | boolean
    connect?: categoryWhereUniqueInput
    update?: XOR<XOR<categoryUpdateToOneWithWhereWithoutProductsInput, categoryUpdateWithoutProductsInput>, categoryUncheckedUpdateWithoutProductsInput>
  }

  export type productsaleUpdateManyWithoutProductNestedInput = {
    create?: XOR<productsaleCreateWithoutProductInput, productsaleUncheckedCreateWithoutProductInput> | productsaleCreateWithoutProductInput[] | productsaleUncheckedCreateWithoutProductInput[]
    connectOrCreate?: productsaleCreateOrConnectWithoutProductInput | productsaleCreateOrConnectWithoutProductInput[]
    upsert?: productsaleUpsertWithWhereUniqueWithoutProductInput | productsaleUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: productsaleCreateManyProductInputEnvelope
    set?: productsaleWhereUniqueInput | productsaleWhereUniqueInput[]
    disconnect?: productsaleWhereUniqueInput | productsaleWhereUniqueInput[]
    delete?: productsaleWhereUniqueInput | productsaleWhereUniqueInput[]
    connect?: productsaleWhereUniqueInput | productsaleWhereUniqueInput[]
    update?: productsaleUpdateWithWhereUniqueWithoutProductInput | productsaleUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: productsaleUpdateManyWithWhereWithoutProductInput | productsaleUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: productsaleScalarWhereInput | productsaleScalarWhereInput[]
  }

  export type productsaleUncheckedUpdateManyWithoutProductNestedInput = {
    create?: XOR<productsaleCreateWithoutProductInput, productsaleUncheckedCreateWithoutProductInput> | productsaleCreateWithoutProductInput[] | productsaleUncheckedCreateWithoutProductInput[]
    connectOrCreate?: productsaleCreateOrConnectWithoutProductInput | productsaleCreateOrConnectWithoutProductInput[]
    upsert?: productsaleUpsertWithWhereUniqueWithoutProductInput | productsaleUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: productsaleCreateManyProductInputEnvelope
    set?: productsaleWhereUniqueInput | productsaleWhereUniqueInput[]
    disconnect?: productsaleWhereUniqueInput | productsaleWhereUniqueInput[]
    delete?: productsaleWhereUniqueInput | productsaleWhereUniqueInput[]
    connect?: productsaleWhereUniqueInput | productsaleWhereUniqueInput[]
    update?: productsaleUpdateWithWhereUniqueWithoutProductInput | productsaleUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: productsaleUpdateManyWithWhereWithoutProductInput | productsaleUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: productsaleScalarWhereInput | productsaleScalarWhereInput[]
  }

  export type brandCreateNestedOneWithoutOptiongroupsInput = {
    create?: XOR<brandCreateWithoutOptiongroupsInput, brandUncheckedCreateWithoutOptiongroupsInput>
    connectOrCreate?: brandCreateOrConnectWithoutOptiongroupsInput
    connect?: brandWhereUniqueInput
  }

  export type subbrandCreateNestedOneWithoutOptiongroupsInput = {
    create?: XOR<subbrandCreateWithoutOptiongroupsInput, subbrandUncheckedCreateWithoutOptiongroupsInput>
    connectOrCreate?: subbrandCreateOrConnectWithoutOptiongroupsInput
    connect?: subbrandWhereUniqueInput
  }

  export type categoryCreateNestedOneWithoutOptiongroupsInput = {
    create?: XOR<categoryCreateWithoutOptiongroupsInput, categoryUncheckedCreateWithoutOptiongroupsInput>
    connectOrCreate?: categoryCreateOrConnectWithoutOptiongroupsInput
    connect?: categoryWhereUniqueInput
  }

  export type itemproductsaleCreateNestedManyWithoutOptiongroupInput = {
    create?: XOR<itemproductsaleCreateWithoutOptiongroupInput, itemproductsaleUncheckedCreateWithoutOptiongroupInput> | itemproductsaleCreateWithoutOptiongroupInput[] | itemproductsaleUncheckedCreateWithoutOptiongroupInput[]
    connectOrCreate?: itemproductsaleCreateOrConnectWithoutOptiongroupInput | itemproductsaleCreateOrConnectWithoutOptiongroupInput[]
    createMany?: itemproductsaleCreateManyOptiongroupInputEnvelope
    connect?: itemproductsaleWhereUniqueInput | itemproductsaleWhereUniqueInput[]
  }

  export type itemitemproductsaleCreateNestedManyWithoutOptiongroupInput = {
    create?: XOR<itemitemproductsaleCreateWithoutOptiongroupInput, itemitemproductsaleUncheckedCreateWithoutOptiongroupInput> | itemitemproductsaleCreateWithoutOptiongroupInput[] | itemitemproductsaleUncheckedCreateWithoutOptiongroupInput[]
    connectOrCreate?: itemitemproductsaleCreateOrConnectWithoutOptiongroupInput | itemitemproductsaleCreateOrConnectWithoutOptiongroupInput[]
    createMany?: itemitemproductsaleCreateManyOptiongroupInputEnvelope
    connect?: itemitemproductsaleWhereUniqueInput | itemitemproductsaleWhereUniqueInput[]
  }

  export type itemproductsaleUncheckedCreateNestedManyWithoutOptiongroupInput = {
    create?: XOR<itemproductsaleCreateWithoutOptiongroupInput, itemproductsaleUncheckedCreateWithoutOptiongroupInput> | itemproductsaleCreateWithoutOptiongroupInput[] | itemproductsaleUncheckedCreateWithoutOptiongroupInput[]
    connectOrCreate?: itemproductsaleCreateOrConnectWithoutOptiongroupInput | itemproductsaleCreateOrConnectWithoutOptiongroupInput[]
    createMany?: itemproductsaleCreateManyOptiongroupInputEnvelope
    connect?: itemproductsaleWhereUniqueInput | itemproductsaleWhereUniqueInput[]
  }

  export type itemitemproductsaleUncheckedCreateNestedManyWithoutOptiongroupInput = {
    create?: XOR<itemitemproductsaleCreateWithoutOptiongroupInput, itemitemproductsaleUncheckedCreateWithoutOptiongroupInput> | itemitemproductsaleCreateWithoutOptiongroupInput[] | itemitemproductsaleUncheckedCreateWithoutOptiongroupInput[]
    connectOrCreate?: itemitemproductsaleCreateOrConnectWithoutOptiongroupInput | itemitemproductsaleCreateOrConnectWithoutOptiongroupInput[]
    createMany?: itemitemproductsaleCreateManyOptiongroupInputEnvelope
    connect?: itemitemproductsaleWhereUniqueInput | itemitemproductsaleWhereUniqueInput[]
  }

  export type brandUpdateOneRequiredWithoutOptiongroupsNestedInput = {
    create?: XOR<brandCreateWithoutOptiongroupsInput, brandUncheckedCreateWithoutOptiongroupsInput>
    connectOrCreate?: brandCreateOrConnectWithoutOptiongroupsInput
    upsert?: brandUpsertWithoutOptiongroupsInput
    connect?: brandWhereUniqueInput
    update?: XOR<XOR<brandUpdateToOneWithWhereWithoutOptiongroupsInput, brandUpdateWithoutOptiongroupsInput>, brandUncheckedUpdateWithoutOptiongroupsInput>
  }

  export type subbrandUpdateOneWithoutOptiongroupsNestedInput = {
    create?: XOR<subbrandCreateWithoutOptiongroupsInput, subbrandUncheckedCreateWithoutOptiongroupsInput>
    connectOrCreate?: subbrandCreateOrConnectWithoutOptiongroupsInput
    upsert?: subbrandUpsertWithoutOptiongroupsInput
    disconnect?: subbrandWhereInput | boolean
    delete?: subbrandWhereInput | boolean
    connect?: subbrandWhereUniqueInput
    update?: XOR<XOR<subbrandUpdateToOneWithWhereWithoutOptiongroupsInput, subbrandUpdateWithoutOptiongroupsInput>, subbrandUncheckedUpdateWithoutOptiongroupsInput>
  }

  export type categoryUpdateOneWithoutOptiongroupsNestedInput = {
    create?: XOR<categoryCreateWithoutOptiongroupsInput, categoryUncheckedCreateWithoutOptiongroupsInput>
    connectOrCreate?: categoryCreateOrConnectWithoutOptiongroupsInput
    upsert?: categoryUpsertWithoutOptiongroupsInput
    disconnect?: categoryWhereInput | boolean
    delete?: categoryWhereInput | boolean
    connect?: categoryWhereUniqueInput
    update?: XOR<XOR<categoryUpdateToOneWithWhereWithoutOptiongroupsInput, categoryUpdateWithoutOptiongroupsInput>, categoryUncheckedUpdateWithoutOptiongroupsInput>
  }

  export type itemproductsaleUpdateManyWithoutOptiongroupNestedInput = {
    create?: XOR<itemproductsaleCreateWithoutOptiongroupInput, itemproductsaleUncheckedCreateWithoutOptiongroupInput> | itemproductsaleCreateWithoutOptiongroupInput[] | itemproductsaleUncheckedCreateWithoutOptiongroupInput[]
    connectOrCreate?: itemproductsaleCreateOrConnectWithoutOptiongroupInput | itemproductsaleCreateOrConnectWithoutOptiongroupInput[]
    upsert?: itemproductsaleUpsertWithWhereUniqueWithoutOptiongroupInput | itemproductsaleUpsertWithWhereUniqueWithoutOptiongroupInput[]
    createMany?: itemproductsaleCreateManyOptiongroupInputEnvelope
    set?: itemproductsaleWhereUniqueInput | itemproductsaleWhereUniqueInput[]
    disconnect?: itemproductsaleWhereUniqueInput | itemproductsaleWhereUniqueInput[]
    delete?: itemproductsaleWhereUniqueInput | itemproductsaleWhereUniqueInput[]
    connect?: itemproductsaleWhereUniqueInput | itemproductsaleWhereUniqueInput[]
    update?: itemproductsaleUpdateWithWhereUniqueWithoutOptiongroupInput | itemproductsaleUpdateWithWhereUniqueWithoutOptiongroupInput[]
    updateMany?: itemproductsaleUpdateManyWithWhereWithoutOptiongroupInput | itemproductsaleUpdateManyWithWhereWithoutOptiongroupInput[]
    deleteMany?: itemproductsaleScalarWhereInput | itemproductsaleScalarWhereInput[]
  }

  export type itemitemproductsaleUpdateManyWithoutOptiongroupNestedInput = {
    create?: XOR<itemitemproductsaleCreateWithoutOptiongroupInput, itemitemproductsaleUncheckedCreateWithoutOptiongroupInput> | itemitemproductsaleCreateWithoutOptiongroupInput[] | itemitemproductsaleUncheckedCreateWithoutOptiongroupInput[]
    connectOrCreate?: itemitemproductsaleCreateOrConnectWithoutOptiongroupInput | itemitemproductsaleCreateOrConnectWithoutOptiongroupInput[]
    upsert?: itemitemproductsaleUpsertWithWhereUniqueWithoutOptiongroupInput | itemitemproductsaleUpsertWithWhereUniqueWithoutOptiongroupInput[]
    createMany?: itemitemproductsaleCreateManyOptiongroupInputEnvelope
    set?: itemitemproductsaleWhereUniqueInput | itemitemproductsaleWhereUniqueInput[]
    disconnect?: itemitemproductsaleWhereUniqueInput | itemitemproductsaleWhereUniqueInput[]
    delete?: itemitemproductsaleWhereUniqueInput | itemitemproductsaleWhereUniqueInput[]
    connect?: itemitemproductsaleWhereUniqueInput | itemitemproductsaleWhereUniqueInput[]
    update?: itemitemproductsaleUpdateWithWhereUniqueWithoutOptiongroupInput | itemitemproductsaleUpdateWithWhereUniqueWithoutOptiongroupInput[]
    updateMany?: itemitemproductsaleUpdateManyWithWhereWithoutOptiongroupInput | itemitemproductsaleUpdateManyWithWhereWithoutOptiongroupInput[]
    deleteMany?: itemitemproductsaleScalarWhereInput | itemitemproductsaleScalarWhereInput[]
  }

  export type itemproductsaleUncheckedUpdateManyWithoutOptiongroupNestedInput = {
    create?: XOR<itemproductsaleCreateWithoutOptiongroupInput, itemproductsaleUncheckedCreateWithoutOptiongroupInput> | itemproductsaleCreateWithoutOptiongroupInput[] | itemproductsaleUncheckedCreateWithoutOptiongroupInput[]
    connectOrCreate?: itemproductsaleCreateOrConnectWithoutOptiongroupInput | itemproductsaleCreateOrConnectWithoutOptiongroupInput[]
    upsert?: itemproductsaleUpsertWithWhereUniqueWithoutOptiongroupInput | itemproductsaleUpsertWithWhereUniqueWithoutOptiongroupInput[]
    createMany?: itemproductsaleCreateManyOptiongroupInputEnvelope
    set?: itemproductsaleWhereUniqueInput | itemproductsaleWhereUniqueInput[]
    disconnect?: itemproductsaleWhereUniqueInput | itemproductsaleWhereUniqueInput[]
    delete?: itemproductsaleWhereUniqueInput | itemproductsaleWhereUniqueInput[]
    connect?: itemproductsaleWhereUniqueInput | itemproductsaleWhereUniqueInput[]
    update?: itemproductsaleUpdateWithWhereUniqueWithoutOptiongroupInput | itemproductsaleUpdateWithWhereUniqueWithoutOptiongroupInput[]
    updateMany?: itemproductsaleUpdateManyWithWhereWithoutOptiongroupInput | itemproductsaleUpdateManyWithWhereWithoutOptiongroupInput[]
    deleteMany?: itemproductsaleScalarWhereInput | itemproductsaleScalarWhereInput[]
  }

  export type itemitemproductsaleUncheckedUpdateManyWithoutOptiongroupNestedInput = {
    create?: XOR<itemitemproductsaleCreateWithoutOptiongroupInput, itemitemproductsaleUncheckedCreateWithoutOptiongroupInput> | itemitemproductsaleCreateWithoutOptiongroupInput[] | itemitemproductsaleUncheckedCreateWithoutOptiongroupInput[]
    connectOrCreate?: itemitemproductsaleCreateOrConnectWithoutOptiongroupInput | itemitemproductsaleCreateOrConnectWithoutOptiongroupInput[]
    upsert?: itemitemproductsaleUpsertWithWhereUniqueWithoutOptiongroupInput | itemitemproductsaleUpsertWithWhereUniqueWithoutOptiongroupInput[]
    createMany?: itemitemproductsaleCreateManyOptiongroupInputEnvelope
    set?: itemitemproductsaleWhereUniqueInput | itemitemproductsaleWhereUniqueInput[]
    disconnect?: itemitemproductsaleWhereUniqueInput | itemitemproductsaleWhereUniqueInput[]
    delete?: itemitemproductsaleWhereUniqueInput | itemitemproductsaleWhereUniqueInput[]
    connect?: itemitemproductsaleWhereUniqueInput | itemitemproductsaleWhereUniqueInput[]
    update?: itemitemproductsaleUpdateWithWhereUniqueWithoutOptiongroupInput | itemitemproductsaleUpdateWithWhereUniqueWithoutOptiongroupInput[]
    updateMany?: itemitemproductsaleUpdateManyWithWhereWithoutOptiongroupInput | itemitemproductsaleUpdateManyWithWhereWithoutOptiongroupInput[]
    deleteMany?: itemitemproductsaleScalarWhereInput | itemitemproductsaleScalarWhereInput[]
  }

  export type brandCreateNestedOneWithoutItemsInput = {
    create?: XOR<brandCreateWithoutItemsInput, brandUncheckedCreateWithoutItemsInput>
    connectOrCreate?: brandCreateOrConnectWithoutItemsInput
    connect?: brandWhereUniqueInput
  }

  export type subbrandCreateNestedOneWithoutItemsInput = {
    create?: XOR<subbrandCreateWithoutItemsInput, subbrandUncheckedCreateWithoutItemsInput>
    connectOrCreate?: subbrandCreateOrConnectWithoutItemsInput
    connect?: subbrandWhereUniqueInput
  }

  export type categoryCreateNestedOneWithoutItemsInput = {
    create?: XOR<categoryCreateWithoutItemsInput, categoryUncheckedCreateWithoutItemsInput>
    connectOrCreate?: categoryCreateOrConnectWithoutItemsInput
    connect?: categoryWhereUniqueInput
  }

  export type itemproductsaleCreateNestedManyWithoutItemInput = {
    create?: XOR<itemproductsaleCreateWithoutItemInput, itemproductsaleUncheckedCreateWithoutItemInput> | itemproductsaleCreateWithoutItemInput[] | itemproductsaleUncheckedCreateWithoutItemInput[]
    connectOrCreate?: itemproductsaleCreateOrConnectWithoutItemInput | itemproductsaleCreateOrConnectWithoutItemInput[]
    createMany?: itemproductsaleCreateManyItemInputEnvelope
    connect?: itemproductsaleWhereUniqueInput | itemproductsaleWhereUniqueInput[]
  }

  export type itemitemproductsaleCreateNestedManyWithoutItemInput = {
    create?: XOR<itemitemproductsaleCreateWithoutItemInput, itemitemproductsaleUncheckedCreateWithoutItemInput> | itemitemproductsaleCreateWithoutItemInput[] | itemitemproductsaleUncheckedCreateWithoutItemInput[]
    connectOrCreate?: itemitemproductsaleCreateOrConnectWithoutItemInput | itemitemproductsaleCreateOrConnectWithoutItemInput[]
    createMany?: itemitemproductsaleCreateManyItemInputEnvelope
    connect?: itemitemproductsaleWhereUniqueInput | itemitemproductsaleWhereUniqueInput[]
  }

  export type itemproductsaleUncheckedCreateNestedManyWithoutItemInput = {
    create?: XOR<itemproductsaleCreateWithoutItemInput, itemproductsaleUncheckedCreateWithoutItemInput> | itemproductsaleCreateWithoutItemInput[] | itemproductsaleUncheckedCreateWithoutItemInput[]
    connectOrCreate?: itemproductsaleCreateOrConnectWithoutItemInput | itemproductsaleCreateOrConnectWithoutItemInput[]
    createMany?: itemproductsaleCreateManyItemInputEnvelope
    connect?: itemproductsaleWhereUniqueInput | itemproductsaleWhereUniqueInput[]
  }

  export type itemitemproductsaleUncheckedCreateNestedManyWithoutItemInput = {
    create?: XOR<itemitemproductsaleCreateWithoutItemInput, itemitemproductsaleUncheckedCreateWithoutItemInput> | itemitemproductsaleCreateWithoutItemInput[] | itemitemproductsaleUncheckedCreateWithoutItemInput[]
    connectOrCreate?: itemitemproductsaleCreateOrConnectWithoutItemInput | itemitemproductsaleCreateOrConnectWithoutItemInput[]
    createMany?: itemitemproductsaleCreateManyItemInputEnvelope
    connect?: itemitemproductsaleWhereUniqueInput | itemitemproductsaleWhereUniqueInput[]
  }

  export type brandUpdateOneRequiredWithoutItemsNestedInput = {
    create?: XOR<brandCreateWithoutItemsInput, brandUncheckedCreateWithoutItemsInput>
    connectOrCreate?: brandCreateOrConnectWithoutItemsInput
    upsert?: brandUpsertWithoutItemsInput
    connect?: brandWhereUniqueInput
    update?: XOR<XOR<brandUpdateToOneWithWhereWithoutItemsInput, brandUpdateWithoutItemsInput>, brandUncheckedUpdateWithoutItemsInput>
  }

  export type subbrandUpdateOneWithoutItemsNestedInput = {
    create?: XOR<subbrandCreateWithoutItemsInput, subbrandUncheckedCreateWithoutItemsInput>
    connectOrCreate?: subbrandCreateOrConnectWithoutItemsInput
    upsert?: subbrandUpsertWithoutItemsInput
    disconnect?: subbrandWhereInput | boolean
    delete?: subbrandWhereInput | boolean
    connect?: subbrandWhereUniqueInput
    update?: XOR<XOR<subbrandUpdateToOneWithWhereWithoutItemsInput, subbrandUpdateWithoutItemsInput>, subbrandUncheckedUpdateWithoutItemsInput>
  }

  export type categoryUpdateOneWithoutItemsNestedInput = {
    create?: XOR<categoryCreateWithoutItemsInput, categoryUncheckedCreateWithoutItemsInput>
    connectOrCreate?: categoryCreateOrConnectWithoutItemsInput
    upsert?: categoryUpsertWithoutItemsInput
    disconnect?: categoryWhereInput | boolean
    delete?: categoryWhereInput | boolean
    connect?: categoryWhereUniqueInput
    update?: XOR<XOR<categoryUpdateToOneWithWhereWithoutItemsInput, categoryUpdateWithoutItemsInput>, categoryUncheckedUpdateWithoutItemsInput>
  }

  export type itemproductsaleUpdateManyWithoutItemNestedInput = {
    create?: XOR<itemproductsaleCreateWithoutItemInput, itemproductsaleUncheckedCreateWithoutItemInput> | itemproductsaleCreateWithoutItemInput[] | itemproductsaleUncheckedCreateWithoutItemInput[]
    connectOrCreate?: itemproductsaleCreateOrConnectWithoutItemInput | itemproductsaleCreateOrConnectWithoutItemInput[]
    upsert?: itemproductsaleUpsertWithWhereUniqueWithoutItemInput | itemproductsaleUpsertWithWhereUniqueWithoutItemInput[]
    createMany?: itemproductsaleCreateManyItemInputEnvelope
    set?: itemproductsaleWhereUniqueInput | itemproductsaleWhereUniqueInput[]
    disconnect?: itemproductsaleWhereUniqueInput | itemproductsaleWhereUniqueInput[]
    delete?: itemproductsaleWhereUniqueInput | itemproductsaleWhereUniqueInput[]
    connect?: itemproductsaleWhereUniqueInput | itemproductsaleWhereUniqueInput[]
    update?: itemproductsaleUpdateWithWhereUniqueWithoutItemInput | itemproductsaleUpdateWithWhereUniqueWithoutItemInput[]
    updateMany?: itemproductsaleUpdateManyWithWhereWithoutItemInput | itemproductsaleUpdateManyWithWhereWithoutItemInput[]
    deleteMany?: itemproductsaleScalarWhereInput | itemproductsaleScalarWhereInput[]
  }

  export type itemitemproductsaleUpdateManyWithoutItemNestedInput = {
    create?: XOR<itemitemproductsaleCreateWithoutItemInput, itemitemproductsaleUncheckedCreateWithoutItemInput> | itemitemproductsaleCreateWithoutItemInput[] | itemitemproductsaleUncheckedCreateWithoutItemInput[]
    connectOrCreate?: itemitemproductsaleCreateOrConnectWithoutItemInput | itemitemproductsaleCreateOrConnectWithoutItemInput[]
    upsert?: itemitemproductsaleUpsertWithWhereUniqueWithoutItemInput | itemitemproductsaleUpsertWithWhereUniqueWithoutItemInput[]
    createMany?: itemitemproductsaleCreateManyItemInputEnvelope
    set?: itemitemproductsaleWhereUniqueInput | itemitemproductsaleWhereUniqueInput[]
    disconnect?: itemitemproductsaleWhereUniqueInput | itemitemproductsaleWhereUniqueInput[]
    delete?: itemitemproductsaleWhereUniqueInput | itemitemproductsaleWhereUniqueInput[]
    connect?: itemitemproductsaleWhereUniqueInput | itemitemproductsaleWhereUniqueInput[]
    update?: itemitemproductsaleUpdateWithWhereUniqueWithoutItemInput | itemitemproductsaleUpdateWithWhereUniqueWithoutItemInput[]
    updateMany?: itemitemproductsaleUpdateManyWithWhereWithoutItemInput | itemitemproductsaleUpdateManyWithWhereWithoutItemInput[]
    deleteMany?: itemitemproductsaleScalarWhereInput | itemitemproductsaleScalarWhereInput[]
  }

  export type itemproductsaleUncheckedUpdateManyWithoutItemNestedInput = {
    create?: XOR<itemproductsaleCreateWithoutItemInput, itemproductsaleUncheckedCreateWithoutItemInput> | itemproductsaleCreateWithoutItemInput[] | itemproductsaleUncheckedCreateWithoutItemInput[]
    connectOrCreate?: itemproductsaleCreateOrConnectWithoutItemInput | itemproductsaleCreateOrConnectWithoutItemInput[]
    upsert?: itemproductsaleUpsertWithWhereUniqueWithoutItemInput | itemproductsaleUpsertWithWhereUniqueWithoutItemInput[]
    createMany?: itemproductsaleCreateManyItemInputEnvelope
    set?: itemproductsaleWhereUniqueInput | itemproductsaleWhereUniqueInput[]
    disconnect?: itemproductsaleWhereUniqueInput | itemproductsaleWhereUniqueInput[]
    delete?: itemproductsaleWhereUniqueInput | itemproductsaleWhereUniqueInput[]
    connect?: itemproductsaleWhereUniqueInput | itemproductsaleWhereUniqueInput[]
    update?: itemproductsaleUpdateWithWhereUniqueWithoutItemInput | itemproductsaleUpdateWithWhereUniqueWithoutItemInput[]
    updateMany?: itemproductsaleUpdateManyWithWhereWithoutItemInput | itemproductsaleUpdateManyWithWhereWithoutItemInput[]
    deleteMany?: itemproductsaleScalarWhereInput | itemproductsaleScalarWhereInput[]
  }

  export type itemitemproductsaleUncheckedUpdateManyWithoutItemNestedInput = {
    create?: XOR<itemitemproductsaleCreateWithoutItemInput, itemitemproductsaleUncheckedCreateWithoutItemInput> | itemitemproductsaleCreateWithoutItemInput[] | itemitemproductsaleUncheckedCreateWithoutItemInput[]
    connectOrCreate?: itemitemproductsaleCreateOrConnectWithoutItemInput | itemitemproductsaleCreateOrConnectWithoutItemInput[]
    upsert?: itemitemproductsaleUpsertWithWhereUniqueWithoutItemInput | itemitemproductsaleUpsertWithWhereUniqueWithoutItemInput[]
    createMany?: itemitemproductsaleCreateManyItemInputEnvelope
    set?: itemitemproductsaleWhereUniqueInput | itemitemproductsaleWhereUniqueInput[]
    disconnect?: itemitemproductsaleWhereUniqueInput | itemitemproductsaleWhereUniqueInput[]
    delete?: itemitemproductsaleWhereUniqueInput | itemitemproductsaleWhereUniqueInput[]
    connect?: itemitemproductsaleWhereUniqueInput | itemitemproductsaleWhereUniqueInput[]
    update?: itemitemproductsaleUpdateWithWhereUniqueWithoutItemInput | itemitemproductsaleUpdateWithWhereUniqueWithoutItemInput[]
    updateMany?: itemitemproductsaleUpdateManyWithWhereWithoutItemInput | itemitemproductsaleUpdateManyWithWhereWithoutItemInput[]
    deleteMany?: itemitemproductsaleScalarWhereInput | itemitemproductsaleScalarWhereInput[]
  }

  export type storeCreateNestedOneWithoutCustomersInput = {
    create?: XOR<storeCreateWithoutCustomersInput, storeUncheckedCreateWithoutCustomersInput>
    connectOrCreate?: storeCreateOrConnectWithoutCustomersInput
    connect?: storeWhereUniqueInput
  }

  export type subbrandCreateNestedOneWithoutCustomersInput = {
    create?: XOR<subbrandCreateWithoutCustomersInput, subbrandUncheckedCreateWithoutCustomersInput>
    connectOrCreate?: subbrandCreateOrConnectWithoutCustomersInput
    connect?: subbrandWhereUniqueInput
  }

  export type saleCreateNestedManyWithoutCustomerInput = {
    create?: XOR<saleCreateWithoutCustomerInput, saleUncheckedCreateWithoutCustomerInput> | saleCreateWithoutCustomerInput[] | saleUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: saleCreateOrConnectWithoutCustomerInput | saleCreateOrConnectWithoutCustomerInput[]
    createMany?: saleCreateManyCustomerInputEnvelope
    connect?: saleWhereUniqueInput | saleWhereUniqueInput[]
  }

  export type saleUncheckedCreateNestedManyWithoutCustomerInput = {
    create?: XOR<saleCreateWithoutCustomerInput, saleUncheckedCreateWithoutCustomerInput> | saleCreateWithoutCustomerInput[] | saleUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: saleCreateOrConnectWithoutCustomerInput | saleCreateOrConnectWithoutCustomerInput[]
    createMany?: saleCreateManyCustomerInputEnvelope
    connect?: saleWhereUniqueInput | saleWhereUniqueInput[]
  }

  export type storeUpdateOneWithoutCustomersNestedInput = {
    create?: XOR<storeCreateWithoutCustomersInput, storeUncheckedCreateWithoutCustomersInput>
    connectOrCreate?: storeCreateOrConnectWithoutCustomersInput
    upsert?: storeUpsertWithoutCustomersInput
    disconnect?: storeWhereInput | boolean
    delete?: storeWhereInput | boolean
    connect?: storeWhereUniqueInput
    update?: XOR<XOR<storeUpdateToOneWithWhereWithoutCustomersInput, storeUpdateWithoutCustomersInput>, storeUncheckedUpdateWithoutCustomersInput>
  }

  export type subbrandUpdateOneWithoutCustomersNestedInput = {
    create?: XOR<subbrandCreateWithoutCustomersInput, subbrandUncheckedCreateWithoutCustomersInput>
    connectOrCreate?: subbrandCreateOrConnectWithoutCustomersInput
    upsert?: subbrandUpsertWithoutCustomersInput
    disconnect?: subbrandWhereInput | boolean
    delete?: subbrandWhereInput | boolean
    connect?: subbrandWhereUniqueInput
    update?: XOR<XOR<subbrandUpdateToOneWithWhereWithoutCustomersInput, subbrandUpdateWithoutCustomersInput>, subbrandUncheckedUpdateWithoutCustomersInput>
  }

  export type saleUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<saleCreateWithoutCustomerInput, saleUncheckedCreateWithoutCustomerInput> | saleCreateWithoutCustomerInput[] | saleUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: saleCreateOrConnectWithoutCustomerInput | saleCreateOrConnectWithoutCustomerInput[]
    upsert?: saleUpsertWithWhereUniqueWithoutCustomerInput | saleUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: saleCreateManyCustomerInputEnvelope
    set?: saleWhereUniqueInput | saleWhereUniqueInput[]
    disconnect?: saleWhereUniqueInput | saleWhereUniqueInput[]
    delete?: saleWhereUniqueInput | saleWhereUniqueInput[]
    connect?: saleWhereUniqueInput | saleWhereUniqueInput[]
    update?: saleUpdateWithWhereUniqueWithoutCustomerInput | saleUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: saleUpdateManyWithWhereWithoutCustomerInput | saleUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: saleScalarWhereInput | saleScalarWhereInput[]
  }

  export type saleUncheckedUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<saleCreateWithoutCustomerInput, saleUncheckedCreateWithoutCustomerInput> | saleCreateWithoutCustomerInput[] | saleUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: saleCreateOrConnectWithoutCustomerInput | saleCreateOrConnectWithoutCustomerInput[]
    upsert?: saleUpsertWithWhereUniqueWithoutCustomerInput | saleUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: saleCreateManyCustomerInputEnvelope
    set?: saleWhereUniqueInput | saleWhereUniqueInput[]
    disconnect?: saleWhereUniqueInput | saleWhereUniqueInput[]
    delete?: saleWhereUniqueInput | saleWhereUniqueInput[]
    connect?: saleWhereUniqueInput | saleWhereUniqueInput[]
    update?: saleUpdateWithWhereUniqueWithoutCustomerInput | saleUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: saleUpdateManyWithWhereWithoutCustomerInput | saleUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: saleScalarWhereInput | saleScalarWhereInput[]
  }

  export type storeCreateNestedOneWithoutSalesInput = {
    create?: XOR<storeCreateWithoutSalesInput, storeUncheckedCreateWithoutSalesInput>
    connectOrCreate?: storeCreateOrConnectWithoutSalesInput
    connect?: storeWhereUniqueInput
  }

  export type subbrandCreateNestedOneWithoutSalesInput = {
    create?: XOR<subbrandCreateWithoutSalesInput, subbrandUncheckedCreateWithoutSalesInput>
    connectOrCreate?: subbrandCreateOrConnectWithoutSalesInput
    connect?: subbrandWhereUniqueInput
  }

  export type customerCreateNestedOneWithoutSalesInput = {
    create?: XOR<customerCreateWithoutSalesInput, customerUncheckedCreateWithoutSalesInput>
    connectOrCreate?: customerCreateOrConnectWithoutSalesInput
    connect?: customerWhereUniqueInput
  }

  export type channelCreateNestedOneWithoutSalesInput = {
    create?: XOR<channelCreateWithoutSalesInput, channelUncheckedCreateWithoutSalesInput>
    connectOrCreate?: channelCreateOrConnectWithoutSalesInput
    connect?: channelWhereUniqueInput
  }

  export type productsaleCreateNestedManyWithoutSaleInput = {
    create?: XOR<productsaleCreateWithoutSaleInput, productsaleUncheckedCreateWithoutSaleInput> | productsaleCreateWithoutSaleInput[] | productsaleUncheckedCreateWithoutSaleInput[]
    connectOrCreate?: productsaleCreateOrConnectWithoutSaleInput | productsaleCreateOrConnectWithoutSaleInput[]
    createMany?: productsaleCreateManySaleInputEnvelope
    connect?: productsaleWhereUniqueInput | productsaleWhereUniqueInput[]
  }

  export type deliverysaleCreateNestedManyWithoutSaleInput = {
    create?: XOR<deliverysaleCreateWithoutSaleInput, deliverysaleUncheckedCreateWithoutSaleInput> | deliverysaleCreateWithoutSaleInput[] | deliverysaleUncheckedCreateWithoutSaleInput[]
    connectOrCreate?: deliverysaleCreateOrConnectWithoutSaleInput | deliverysaleCreateOrConnectWithoutSaleInput[]
    createMany?: deliverysaleCreateManySaleInputEnvelope
    connect?: deliverysaleWhereUniqueInput | deliverysaleWhereUniqueInput[]
  }

  export type deliveryaddressCreateNestedManyWithoutSaleInput = {
    create?: XOR<deliveryaddressCreateWithoutSaleInput, deliveryaddressUncheckedCreateWithoutSaleInput> | deliveryaddressCreateWithoutSaleInput[] | deliveryaddressUncheckedCreateWithoutSaleInput[]
    connectOrCreate?: deliveryaddressCreateOrConnectWithoutSaleInput | deliveryaddressCreateOrConnectWithoutSaleInput[]
    createMany?: deliveryaddressCreateManySaleInputEnvelope
    connect?: deliveryaddressWhereUniqueInput | deliveryaddressWhereUniqueInput[]
  }

  export type paymentCreateNestedManyWithoutSaleInput = {
    create?: XOR<paymentCreateWithoutSaleInput, paymentUncheckedCreateWithoutSaleInput> | paymentCreateWithoutSaleInput[] | paymentUncheckedCreateWithoutSaleInput[]
    connectOrCreate?: paymentCreateOrConnectWithoutSaleInput | paymentCreateOrConnectWithoutSaleInput[]
    createMany?: paymentCreateManySaleInputEnvelope
    connect?: paymentWhereUniqueInput | paymentWhereUniqueInput[]
  }

  export type couponsaleCreateNestedManyWithoutSaleInput = {
    create?: XOR<couponsaleCreateWithoutSaleInput, couponsaleUncheckedCreateWithoutSaleInput> | couponsaleCreateWithoutSaleInput[] | couponsaleUncheckedCreateWithoutSaleInput[]
    connectOrCreate?: couponsaleCreateOrConnectWithoutSaleInput | couponsaleCreateOrConnectWithoutSaleInput[]
    createMany?: couponsaleCreateManySaleInputEnvelope
    connect?: couponsaleWhereUniqueInput | couponsaleWhereUniqueInput[]
  }

  export type productsaleUncheckedCreateNestedManyWithoutSaleInput = {
    create?: XOR<productsaleCreateWithoutSaleInput, productsaleUncheckedCreateWithoutSaleInput> | productsaleCreateWithoutSaleInput[] | productsaleUncheckedCreateWithoutSaleInput[]
    connectOrCreate?: productsaleCreateOrConnectWithoutSaleInput | productsaleCreateOrConnectWithoutSaleInput[]
    createMany?: productsaleCreateManySaleInputEnvelope
    connect?: productsaleWhereUniqueInput | productsaleWhereUniqueInput[]
  }

  export type deliverysaleUncheckedCreateNestedManyWithoutSaleInput = {
    create?: XOR<deliverysaleCreateWithoutSaleInput, deliverysaleUncheckedCreateWithoutSaleInput> | deliverysaleCreateWithoutSaleInput[] | deliverysaleUncheckedCreateWithoutSaleInput[]
    connectOrCreate?: deliverysaleCreateOrConnectWithoutSaleInput | deliverysaleCreateOrConnectWithoutSaleInput[]
    createMany?: deliverysaleCreateManySaleInputEnvelope
    connect?: deliverysaleWhereUniqueInput | deliverysaleWhereUniqueInput[]
  }

  export type deliveryaddressUncheckedCreateNestedManyWithoutSaleInput = {
    create?: XOR<deliveryaddressCreateWithoutSaleInput, deliveryaddressUncheckedCreateWithoutSaleInput> | deliveryaddressCreateWithoutSaleInput[] | deliveryaddressUncheckedCreateWithoutSaleInput[]
    connectOrCreate?: deliveryaddressCreateOrConnectWithoutSaleInput | deliveryaddressCreateOrConnectWithoutSaleInput[]
    createMany?: deliveryaddressCreateManySaleInputEnvelope
    connect?: deliveryaddressWhereUniqueInput | deliveryaddressWhereUniqueInput[]
  }

  export type paymentUncheckedCreateNestedManyWithoutSaleInput = {
    create?: XOR<paymentCreateWithoutSaleInput, paymentUncheckedCreateWithoutSaleInput> | paymentCreateWithoutSaleInput[] | paymentUncheckedCreateWithoutSaleInput[]
    connectOrCreate?: paymentCreateOrConnectWithoutSaleInput | paymentCreateOrConnectWithoutSaleInput[]
    createMany?: paymentCreateManySaleInputEnvelope
    connect?: paymentWhereUniqueInput | paymentWhereUniqueInput[]
  }

  export type couponsaleUncheckedCreateNestedManyWithoutSaleInput = {
    create?: XOR<couponsaleCreateWithoutSaleInput, couponsaleUncheckedCreateWithoutSaleInput> | couponsaleCreateWithoutSaleInput[] | couponsaleUncheckedCreateWithoutSaleInput[]
    connectOrCreate?: couponsaleCreateOrConnectWithoutSaleInput | couponsaleCreateOrConnectWithoutSaleInput[]
    createMany?: couponsaleCreateManySaleInputEnvelope
    connect?: couponsaleWhereUniqueInput | couponsaleWhereUniqueInput[]
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type DecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type storeUpdateOneRequiredWithoutSalesNestedInput = {
    create?: XOR<storeCreateWithoutSalesInput, storeUncheckedCreateWithoutSalesInput>
    connectOrCreate?: storeCreateOrConnectWithoutSalesInput
    upsert?: storeUpsertWithoutSalesInput
    connect?: storeWhereUniqueInput
    update?: XOR<XOR<storeUpdateToOneWithWhereWithoutSalesInput, storeUpdateWithoutSalesInput>, storeUncheckedUpdateWithoutSalesInput>
  }

  export type subbrandUpdateOneWithoutSalesNestedInput = {
    create?: XOR<subbrandCreateWithoutSalesInput, subbrandUncheckedCreateWithoutSalesInput>
    connectOrCreate?: subbrandCreateOrConnectWithoutSalesInput
    upsert?: subbrandUpsertWithoutSalesInput
    disconnect?: subbrandWhereInput | boolean
    delete?: subbrandWhereInput | boolean
    connect?: subbrandWhereUniqueInput
    update?: XOR<XOR<subbrandUpdateToOneWithWhereWithoutSalesInput, subbrandUpdateWithoutSalesInput>, subbrandUncheckedUpdateWithoutSalesInput>
  }

  export type customerUpdateOneWithoutSalesNestedInput = {
    create?: XOR<customerCreateWithoutSalesInput, customerUncheckedCreateWithoutSalesInput>
    connectOrCreate?: customerCreateOrConnectWithoutSalesInput
    upsert?: customerUpsertWithoutSalesInput
    disconnect?: customerWhereInput | boolean
    delete?: customerWhereInput | boolean
    connect?: customerWhereUniqueInput
    update?: XOR<XOR<customerUpdateToOneWithWhereWithoutSalesInput, customerUpdateWithoutSalesInput>, customerUncheckedUpdateWithoutSalesInput>
  }

  export type channelUpdateOneRequiredWithoutSalesNestedInput = {
    create?: XOR<channelCreateWithoutSalesInput, channelUncheckedCreateWithoutSalesInput>
    connectOrCreate?: channelCreateOrConnectWithoutSalesInput
    upsert?: channelUpsertWithoutSalesInput
    connect?: channelWhereUniqueInput
    update?: XOR<XOR<channelUpdateToOneWithWhereWithoutSalesInput, channelUpdateWithoutSalesInput>, channelUncheckedUpdateWithoutSalesInput>
  }

  export type productsaleUpdateManyWithoutSaleNestedInput = {
    create?: XOR<productsaleCreateWithoutSaleInput, productsaleUncheckedCreateWithoutSaleInput> | productsaleCreateWithoutSaleInput[] | productsaleUncheckedCreateWithoutSaleInput[]
    connectOrCreate?: productsaleCreateOrConnectWithoutSaleInput | productsaleCreateOrConnectWithoutSaleInput[]
    upsert?: productsaleUpsertWithWhereUniqueWithoutSaleInput | productsaleUpsertWithWhereUniqueWithoutSaleInput[]
    createMany?: productsaleCreateManySaleInputEnvelope
    set?: productsaleWhereUniqueInput | productsaleWhereUniqueInput[]
    disconnect?: productsaleWhereUniqueInput | productsaleWhereUniqueInput[]
    delete?: productsaleWhereUniqueInput | productsaleWhereUniqueInput[]
    connect?: productsaleWhereUniqueInput | productsaleWhereUniqueInput[]
    update?: productsaleUpdateWithWhereUniqueWithoutSaleInput | productsaleUpdateWithWhereUniqueWithoutSaleInput[]
    updateMany?: productsaleUpdateManyWithWhereWithoutSaleInput | productsaleUpdateManyWithWhereWithoutSaleInput[]
    deleteMany?: productsaleScalarWhereInput | productsaleScalarWhereInput[]
  }

  export type deliverysaleUpdateManyWithoutSaleNestedInput = {
    create?: XOR<deliverysaleCreateWithoutSaleInput, deliverysaleUncheckedCreateWithoutSaleInput> | deliverysaleCreateWithoutSaleInput[] | deliverysaleUncheckedCreateWithoutSaleInput[]
    connectOrCreate?: deliverysaleCreateOrConnectWithoutSaleInput | deliverysaleCreateOrConnectWithoutSaleInput[]
    upsert?: deliverysaleUpsertWithWhereUniqueWithoutSaleInput | deliverysaleUpsertWithWhereUniqueWithoutSaleInput[]
    createMany?: deliverysaleCreateManySaleInputEnvelope
    set?: deliverysaleWhereUniqueInput | deliverysaleWhereUniqueInput[]
    disconnect?: deliverysaleWhereUniqueInput | deliverysaleWhereUniqueInput[]
    delete?: deliverysaleWhereUniqueInput | deliverysaleWhereUniqueInput[]
    connect?: deliverysaleWhereUniqueInput | deliverysaleWhereUniqueInput[]
    update?: deliverysaleUpdateWithWhereUniqueWithoutSaleInput | deliverysaleUpdateWithWhereUniqueWithoutSaleInput[]
    updateMany?: deliverysaleUpdateManyWithWhereWithoutSaleInput | deliverysaleUpdateManyWithWhereWithoutSaleInput[]
    deleteMany?: deliverysaleScalarWhereInput | deliverysaleScalarWhereInput[]
  }

  export type deliveryaddressUpdateManyWithoutSaleNestedInput = {
    create?: XOR<deliveryaddressCreateWithoutSaleInput, deliveryaddressUncheckedCreateWithoutSaleInput> | deliveryaddressCreateWithoutSaleInput[] | deliveryaddressUncheckedCreateWithoutSaleInput[]
    connectOrCreate?: deliveryaddressCreateOrConnectWithoutSaleInput | deliveryaddressCreateOrConnectWithoutSaleInput[]
    upsert?: deliveryaddressUpsertWithWhereUniqueWithoutSaleInput | deliveryaddressUpsertWithWhereUniqueWithoutSaleInput[]
    createMany?: deliveryaddressCreateManySaleInputEnvelope
    set?: deliveryaddressWhereUniqueInput | deliveryaddressWhereUniqueInput[]
    disconnect?: deliveryaddressWhereUniqueInput | deliveryaddressWhereUniqueInput[]
    delete?: deliveryaddressWhereUniqueInput | deliveryaddressWhereUniqueInput[]
    connect?: deliveryaddressWhereUniqueInput | deliveryaddressWhereUniqueInput[]
    update?: deliveryaddressUpdateWithWhereUniqueWithoutSaleInput | deliveryaddressUpdateWithWhereUniqueWithoutSaleInput[]
    updateMany?: deliveryaddressUpdateManyWithWhereWithoutSaleInput | deliveryaddressUpdateManyWithWhereWithoutSaleInput[]
    deleteMany?: deliveryaddressScalarWhereInput | deliveryaddressScalarWhereInput[]
  }

  export type paymentUpdateManyWithoutSaleNestedInput = {
    create?: XOR<paymentCreateWithoutSaleInput, paymentUncheckedCreateWithoutSaleInput> | paymentCreateWithoutSaleInput[] | paymentUncheckedCreateWithoutSaleInput[]
    connectOrCreate?: paymentCreateOrConnectWithoutSaleInput | paymentCreateOrConnectWithoutSaleInput[]
    upsert?: paymentUpsertWithWhereUniqueWithoutSaleInput | paymentUpsertWithWhereUniqueWithoutSaleInput[]
    createMany?: paymentCreateManySaleInputEnvelope
    set?: paymentWhereUniqueInput | paymentWhereUniqueInput[]
    disconnect?: paymentWhereUniqueInput | paymentWhereUniqueInput[]
    delete?: paymentWhereUniqueInput | paymentWhereUniqueInput[]
    connect?: paymentWhereUniqueInput | paymentWhereUniqueInput[]
    update?: paymentUpdateWithWhereUniqueWithoutSaleInput | paymentUpdateWithWhereUniqueWithoutSaleInput[]
    updateMany?: paymentUpdateManyWithWhereWithoutSaleInput | paymentUpdateManyWithWhereWithoutSaleInput[]
    deleteMany?: paymentScalarWhereInput | paymentScalarWhereInput[]
  }

  export type couponsaleUpdateManyWithoutSaleNestedInput = {
    create?: XOR<couponsaleCreateWithoutSaleInput, couponsaleUncheckedCreateWithoutSaleInput> | couponsaleCreateWithoutSaleInput[] | couponsaleUncheckedCreateWithoutSaleInput[]
    connectOrCreate?: couponsaleCreateOrConnectWithoutSaleInput | couponsaleCreateOrConnectWithoutSaleInput[]
    upsert?: couponsaleUpsertWithWhereUniqueWithoutSaleInput | couponsaleUpsertWithWhereUniqueWithoutSaleInput[]
    createMany?: couponsaleCreateManySaleInputEnvelope
    set?: couponsaleWhereUniqueInput | couponsaleWhereUniqueInput[]
    disconnect?: couponsaleWhereUniqueInput | couponsaleWhereUniqueInput[]
    delete?: couponsaleWhereUniqueInput | couponsaleWhereUniqueInput[]
    connect?: couponsaleWhereUniqueInput | couponsaleWhereUniqueInput[]
    update?: couponsaleUpdateWithWhereUniqueWithoutSaleInput | couponsaleUpdateWithWhereUniqueWithoutSaleInput[]
    updateMany?: couponsaleUpdateManyWithWhereWithoutSaleInput | couponsaleUpdateManyWithWhereWithoutSaleInput[]
    deleteMany?: couponsaleScalarWhereInput | couponsaleScalarWhereInput[]
  }

  export type productsaleUncheckedUpdateManyWithoutSaleNestedInput = {
    create?: XOR<productsaleCreateWithoutSaleInput, productsaleUncheckedCreateWithoutSaleInput> | productsaleCreateWithoutSaleInput[] | productsaleUncheckedCreateWithoutSaleInput[]
    connectOrCreate?: productsaleCreateOrConnectWithoutSaleInput | productsaleCreateOrConnectWithoutSaleInput[]
    upsert?: productsaleUpsertWithWhereUniqueWithoutSaleInput | productsaleUpsertWithWhereUniqueWithoutSaleInput[]
    createMany?: productsaleCreateManySaleInputEnvelope
    set?: productsaleWhereUniqueInput | productsaleWhereUniqueInput[]
    disconnect?: productsaleWhereUniqueInput | productsaleWhereUniqueInput[]
    delete?: productsaleWhereUniqueInput | productsaleWhereUniqueInput[]
    connect?: productsaleWhereUniqueInput | productsaleWhereUniqueInput[]
    update?: productsaleUpdateWithWhereUniqueWithoutSaleInput | productsaleUpdateWithWhereUniqueWithoutSaleInput[]
    updateMany?: productsaleUpdateManyWithWhereWithoutSaleInput | productsaleUpdateManyWithWhereWithoutSaleInput[]
    deleteMany?: productsaleScalarWhereInput | productsaleScalarWhereInput[]
  }

  export type deliverysaleUncheckedUpdateManyWithoutSaleNestedInput = {
    create?: XOR<deliverysaleCreateWithoutSaleInput, deliverysaleUncheckedCreateWithoutSaleInput> | deliverysaleCreateWithoutSaleInput[] | deliverysaleUncheckedCreateWithoutSaleInput[]
    connectOrCreate?: deliverysaleCreateOrConnectWithoutSaleInput | deliverysaleCreateOrConnectWithoutSaleInput[]
    upsert?: deliverysaleUpsertWithWhereUniqueWithoutSaleInput | deliverysaleUpsertWithWhereUniqueWithoutSaleInput[]
    createMany?: deliverysaleCreateManySaleInputEnvelope
    set?: deliverysaleWhereUniqueInput | deliverysaleWhereUniqueInput[]
    disconnect?: deliverysaleWhereUniqueInput | deliverysaleWhereUniqueInput[]
    delete?: deliverysaleWhereUniqueInput | deliverysaleWhereUniqueInput[]
    connect?: deliverysaleWhereUniqueInput | deliverysaleWhereUniqueInput[]
    update?: deliverysaleUpdateWithWhereUniqueWithoutSaleInput | deliverysaleUpdateWithWhereUniqueWithoutSaleInput[]
    updateMany?: deliverysaleUpdateManyWithWhereWithoutSaleInput | deliverysaleUpdateManyWithWhereWithoutSaleInput[]
    deleteMany?: deliverysaleScalarWhereInput | deliverysaleScalarWhereInput[]
  }

  export type deliveryaddressUncheckedUpdateManyWithoutSaleNestedInput = {
    create?: XOR<deliveryaddressCreateWithoutSaleInput, deliveryaddressUncheckedCreateWithoutSaleInput> | deliveryaddressCreateWithoutSaleInput[] | deliveryaddressUncheckedCreateWithoutSaleInput[]
    connectOrCreate?: deliveryaddressCreateOrConnectWithoutSaleInput | deliveryaddressCreateOrConnectWithoutSaleInput[]
    upsert?: deliveryaddressUpsertWithWhereUniqueWithoutSaleInput | deliveryaddressUpsertWithWhereUniqueWithoutSaleInput[]
    createMany?: deliveryaddressCreateManySaleInputEnvelope
    set?: deliveryaddressWhereUniqueInput | deliveryaddressWhereUniqueInput[]
    disconnect?: deliveryaddressWhereUniqueInput | deliveryaddressWhereUniqueInput[]
    delete?: deliveryaddressWhereUniqueInput | deliveryaddressWhereUniqueInput[]
    connect?: deliveryaddressWhereUniqueInput | deliveryaddressWhereUniqueInput[]
    update?: deliveryaddressUpdateWithWhereUniqueWithoutSaleInput | deliveryaddressUpdateWithWhereUniqueWithoutSaleInput[]
    updateMany?: deliveryaddressUpdateManyWithWhereWithoutSaleInput | deliveryaddressUpdateManyWithWhereWithoutSaleInput[]
    deleteMany?: deliveryaddressScalarWhereInput | deliveryaddressScalarWhereInput[]
  }

  export type paymentUncheckedUpdateManyWithoutSaleNestedInput = {
    create?: XOR<paymentCreateWithoutSaleInput, paymentUncheckedCreateWithoutSaleInput> | paymentCreateWithoutSaleInput[] | paymentUncheckedCreateWithoutSaleInput[]
    connectOrCreate?: paymentCreateOrConnectWithoutSaleInput | paymentCreateOrConnectWithoutSaleInput[]
    upsert?: paymentUpsertWithWhereUniqueWithoutSaleInput | paymentUpsertWithWhereUniqueWithoutSaleInput[]
    createMany?: paymentCreateManySaleInputEnvelope
    set?: paymentWhereUniqueInput | paymentWhereUniqueInput[]
    disconnect?: paymentWhereUniqueInput | paymentWhereUniqueInput[]
    delete?: paymentWhereUniqueInput | paymentWhereUniqueInput[]
    connect?: paymentWhereUniqueInput | paymentWhereUniqueInput[]
    update?: paymentUpdateWithWhereUniqueWithoutSaleInput | paymentUpdateWithWhereUniqueWithoutSaleInput[]
    updateMany?: paymentUpdateManyWithWhereWithoutSaleInput | paymentUpdateManyWithWhereWithoutSaleInput[]
    deleteMany?: paymentScalarWhereInput | paymentScalarWhereInput[]
  }

  export type couponsaleUncheckedUpdateManyWithoutSaleNestedInput = {
    create?: XOR<couponsaleCreateWithoutSaleInput, couponsaleUncheckedCreateWithoutSaleInput> | couponsaleCreateWithoutSaleInput[] | couponsaleUncheckedCreateWithoutSaleInput[]
    connectOrCreate?: couponsaleCreateOrConnectWithoutSaleInput | couponsaleCreateOrConnectWithoutSaleInput[]
    upsert?: couponsaleUpsertWithWhereUniqueWithoutSaleInput | couponsaleUpsertWithWhereUniqueWithoutSaleInput[]
    createMany?: couponsaleCreateManySaleInputEnvelope
    set?: couponsaleWhereUniqueInput | couponsaleWhereUniqueInput[]
    disconnect?: couponsaleWhereUniqueInput | couponsaleWhereUniqueInput[]
    delete?: couponsaleWhereUniqueInput | couponsaleWhereUniqueInput[]
    connect?: couponsaleWhereUniqueInput | couponsaleWhereUniqueInput[]
    update?: couponsaleUpdateWithWhereUniqueWithoutSaleInput | couponsaleUpdateWithWhereUniqueWithoutSaleInput[]
    updateMany?: couponsaleUpdateManyWithWhereWithoutSaleInput | couponsaleUpdateManyWithWhereWithoutSaleInput[]
    deleteMany?: couponsaleScalarWhereInput | couponsaleScalarWhereInput[]
  }

  export type saleCreateNestedOneWithoutProductsalesInput = {
    create?: XOR<saleCreateWithoutProductsalesInput, saleUncheckedCreateWithoutProductsalesInput>
    connectOrCreate?: saleCreateOrConnectWithoutProductsalesInput
    connect?: saleWhereUniqueInput
  }

  export type productCreateNestedOneWithoutProductsalesInput = {
    create?: XOR<productCreateWithoutProductsalesInput, productUncheckedCreateWithoutProductsalesInput>
    connectOrCreate?: productCreateOrConnectWithoutProductsalesInput
    connect?: productWhereUniqueInput
  }

  export type itemproductsaleCreateNestedManyWithoutProductsaleInput = {
    create?: XOR<itemproductsaleCreateWithoutProductsaleInput, itemproductsaleUncheckedCreateWithoutProductsaleInput> | itemproductsaleCreateWithoutProductsaleInput[] | itemproductsaleUncheckedCreateWithoutProductsaleInput[]
    connectOrCreate?: itemproductsaleCreateOrConnectWithoutProductsaleInput | itemproductsaleCreateOrConnectWithoutProductsaleInput[]
    createMany?: itemproductsaleCreateManyProductsaleInputEnvelope
    connect?: itemproductsaleWhereUniqueInput | itemproductsaleWhereUniqueInput[]
  }

  export type itemproductsaleUncheckedCreateNestedManyWithoutProductsaleInput = {
    create?: XOR<itemproductsaleCreateWithoutProductsaleInput, itemproductsaleUncheckedCreateWithoutProductsaleInput> | itemproductsaleCreateWithoutProductsaleInput[] | itemproductsaleUncheckedCreateWithoutProductsaleInput[]
    connectOrCreate?: itemproductsaleCreateOrConnectWithoutProductsaleInput | itemproductsaleCreateOrConnectWithoutProductsaleInput[]
    createMany?: itemproductsaleCreateManyProductsaleInputEnvelope
    connect?: itemproductsaleWhereUniqueInput | itemproductsaleWhereUniqueInput[]
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type saleUpdateOneRequiredWithoutProductsalesNestedInput = {
    create?: XOR<saleCreateWithoutProductsalesInput, saleUncheckedCreateWithoutProductsalesInput>
    connectOrCreate?: saleCreateOrConnectWithoutProductsalesInput
    upsert?: saleUpsertWithoutProductsalesInput
    connect?: saleWhereUniqueInput
    update?: XOR<XOR<saleUpdateToOneWithWhereWithoutProductsalesInput, saleUpdateWithoutProductsalesInput>, saleUncheckedUpdateWithoutProductsalesInput>
  }

  export type productUpdateOneRequiredWithoutProductsalesNestedInput = {
    create?: XOR<productCreateWithoutProductsalesInput, productUncheckedCreateWithoutProductsalesInput>
    connectOrCreate?: productCreateOrConnectWithoutProductsalesInput
    upsert?: productUpsertWithoutProductsalesInput
    connect?: productWhereUniqueInput
    update?: XOR<XOR<productUpdateToOneWithWhereWithoutProductsalesInput, productUpdateWithoutProductsalesInput>, productUncheckedUpdateWithoutProductsalesInput>
  }

  export type itemproductsaleUpdateManyWithoutProductsaleNestedInput = {
    create?: XOR<itemproductsaleCreateWithoutProductsaleInput, itemproductsaleUncheckedCreateWithoutProductsaleInput> | itemproductsaleCreateWithoutProductsaleInput[] | itemproductsaleUncheckedCreateWithoutProductsaleInput[]
    connectOrCreate?: itemproductsaleCreateOrConnectWithoutProductsaleInput | itemproductsaleCreateOrConnectWithoutProductsaleInput[]
    upsert?: itemproductsaleUpsertWithWhereUniqueWithoutProductsaleInput | itemproductsaleUpsertWithWhereUniqueWithoutProductsaleInput[]
    createMany?: itemproductsaleCreateManyProductsaleInputEnvelope
    set?: itemproductsaleWhereUniqueInput | itemproductsaleWhereUniqueInput[]
    disconnect?: itemproductsaleWhereUniqueInput | itemproductsaleWhereUniqueInput[]
    delete?: itemproductsaleWhereUniqueInput | itemproductsaleWhereUniqueInput[]
    connect?: itemproductsaleWhereUniqueInput | itemproductsaleWhereUniqueInput[]
    update?: itemproductsaleUpdateWithWhereUniqueWithoutProductsaleInput | itemproductsaleUpdateWithWhereUniqueWithoutProductsaleInput[]
    updateMany?: itemproductsaleUpdateManyWithWhereWithoutProductsaleInput | itemproductsaleUpdateManyWithWhereWithoutProductsaleInput[]
    deleteMany?: itemproductsaleScalarWhereInput | itemproductsaleScalarWhereInput[]
  }

  export type itemproductsaleUncheckedUpdateManyWithoutProductsaleNestedInput = {
    create?: XOR<itemproductsaleCreateWithoutProductsaleInput, itemproductsaleUncheckedCreateWithoutProductsaleInput> | itemproductsaleCreateWithoutProductsaleInput[] | itemproductsaleUncheckedCreateWithoutProductsaleInput[]
    connectOrCreate?: itemproductsaleCreateOrConnectWithoutProductsaleInput | itemproductsaleCreateOrConnectWithoutProductsaleInput[]
    upsert?: itemproductsaleUpsertWithWhereUniqueWithoutProductsaleInput | itemproductsaleUpsertWithWhereUniqueWithoutProductsaleInput[]
    createMany?: itemproductsaleCreateManyProductsaleInputEnvelope
    set?: itemproductsaleWhereUniqueInput | itemproductsaleWhereUniqueInput[]
    disconnect?: itemproductsaleWhereUniqueInput | itemproductsaleWhereUniqueInput[]
    delete?: itemproductsaleWhereUniqueInput | itemproductsaleWhereUniqueInput[]
    connect?: itemproductsaleWhereUniqueInput | itemproductsaleWhereUniqueInput[]
    update?: itemproductsaleUpdateWithWhereUniqueWithoutProductsaleInput | itemproductsaleUpdateWithWhereUniqueWithoutProductsaleInput[]
    updateMany?: itemproductsaleUpdateManyWithWhereWithoutProductsaleInput | itemproductsaleUpdateManyWithWhereWithoutProductsaleInput[]
    deleteMany?: itemproductsaleScalarWhereInput | itemproductsaleScalarWhereInput[]
  }

  export type productsaleCreateNestedOneWithoutItemproductsalesInput = {
    create?: XOR<productsaleCreateWithoutItemproductsalesInput, productsaleUncheckedCreateWithoutItemproductsalesInput>
    connectOrCreate?: productsaleCreateOrConnectWithoutItemproductsalesInput
    connect?: productsaleWhereUniqueInput
  }

  export type itemCreateNestedOneWithoutItemproductsalesInput = {
    create?: XOR<itemCreateWithoutItemproductsalesInput, itemUncheckedCreateWithoutItemproductsalesInput>
    connectOrCreate?: itemCreateOrConnectWithoutItemproductsalesInput
    connect?: itemWhereUniqueInput
  }

  export type optiongroupCreateNestedOneWithoutItemproductsalesInput = {
    create?: XOR<optiongroupCreateWithoutItemproductsalesInput, optiongroupUncheckedCreateWithoutItemproductsalesInput>
    connectOrCreate?: optiongroupCreateOrConnectWithoutItemproductsalesInput
    connect?: optiongroupWhereUniqueInput
  }

  export type itemitemproductsaleCreateNestedManyWithoutItemproductsaleInput = {
    create?: XOR<itemitemproductsaleCreateWithoutItemproductsaleInput, itemitemproductsaleUncheckedCreateWithoutItemproductsaleInput> | itemitemproductsaleCreateWithoutItemproductsaleInput[] | itemitemproductsaleUncheckedCreateWithoutItemproductsaleInput[]
    connectOrCreate?: itemitemproductsaleCreateOrConnectWithoutItemproductsaleInput | itemitemproductsaleCreateOrConnectWithoutItemproductsaleInput[]
    createMany?: itemitemproductsaleCreateManyItemproductsaleInputEnvelope
    connect?: itemitemproductsaleWhereUniqueInput | itemitemproductsaleWhereUniqueInput[]
  }

  export type itemitemproductsaleUncheckedCreateNestedManyWithoutItemproductsaleInput = {
    create?: XOR<itemitemproductsaleCreateWithoutItemproductsaleInput, itemitemproductsaleUncheckedCreateWithoutItemproductsaleInput> | itemitemproductsaleCreateWithoutItemproductsaleInput[] | itemitemproductsaleUncheckedCreateWithoutItemproductsaleInput[]
    connectOrCreate?: itemitemproductsaleCreateOrConnectWithoutItemproductsaleInput | itemitemproductsaleCreateOrConnectWithoutItemproductsaleInput[]
    createMany?: itemitemproductsaleCreateManyItemproductsaleInputEnvelope
    connect?: itemitemproductsaleWhereUniqueInput | itemitemproductsaleWhereUniqueInput[]
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type productsaleUpdateOneRequiredWithoutItemproductsalesNestedInput = {
    create?: XOR<productsaleCreateWithoutItemproductsalesInput, productsaleUncheckedCreateWithoutItemproductsalesInput>
    connectOrCreate?: productsaleCreateOrConnectWithoutItemproductsalesInput
    upsert?: productsaleUpsertWithoutItemproductsalesInput
    connect?: productsaleWhereUniqueInput
    update?: XOR<XOR<productsaleUpdateToOneWithWhereWithoutItemproductsalesInput, productsaleUpdateWithoutItemproductsalesInput>, productsaleUncheckedUpdateWithoutItemproductsalesInput>
  }

  export type itemUpdateOneRequiredWithoutItemproductsalesNestedInput = {
    create?: XOR<itemCreateWithoutItemproductsalesInput, itemUncheckedCreateWithoutItemproductsalesInput>
    connectOrCreate?: itemCreateOrConnectWithoutItemproductsalesInput
    upsert?: itemUpsertWithoutItemproductsalesInput
    connect?: itemWhereUniqueInput
    update?: XOR<XOR<itemUpdateToOneWithWhereWithoutItemproductsalesInput, itemUpdateWithoutItemproductsalesInput>, itemUncheckedUpdateWithoutItemproductsalesInput>
  }

  export type optiongroupUpdateOneWithoutItemproductsalesNestedInput = {
    create?: XOR<optiongroupCreateWithoutItemproductsalesInput, optiongroupUncheckedCreateWithoutItemproductsalesInput>
    connectOrCreate?: optiongroupCreateOrConnectWithoutItemproductsalesInput
    upsert?: optiongroupUpsertWithoutItemproductsalesInput
    disconnect?: optiongroupWhereInput | boolean
    delete?: optiongroupWhereInput | boolean
    connect?: optiongroupWhereUniqueInput
    update?: XOR<XOR<optiongroupUpdateToOneWithWhereWithoutItemproductsalesInput, optiongroupUpdateWithoutItemproductsalesInput>, optiongroupUncheckedUpdateWithoutItemproductsalesInput>
  }

  export type itemitemproductsaleUpdateManyWithoutItemproductsaleNestedInput = {
    create?: XOR<itemitemproductsaleCreateWithoutItemproductsaleInput, itemitemproductsaleUncheckedCreateWithoutItemproductsaleInput> | itemitemproductsaleCreateWithoutItemproductsaleInput[] | itemitemproductsaleUncheckedCreateWithoutItemproductsaleInput[]
    connectOrCreate?: itemitemproductsaleCreateOrConnectWithoutItemproductsaleInput | itemitemproductsaleCreateOrConnectWithoutItemproductsaleInput[]
    upsert?: itemitemproductsaleUpsertWithWhereUniqueWithoutItemproductsaleInput | itemitemproductsaleUpsertWithWhereUniqueWithoutItemproductsaleInput[]
    createMany?: itemitemproductsaleCreateManyItemproductsaleInputEnvelope
    set?: itemitemproductsaleWhereUniqueInput | itemitemproductsaleWhereUniqueInput[]
    disconnect?: itemitemproductsaleWhereUniqueInput | itemitemproductsaleWhereUniqueInput[]
    delete?: itemitemproductsaleWhereUniqueInput | itemitemproductsaleWhereUniqueInput[]
    connect?: itemitemproductsaleWhereUniqueInput | itemitemproductsaleWhereUniqueInput[]
    update?: itemitemproductsaleUpdateWithWhereUniqueWithoutItemproductsaleInput | itemitemproductsaleUpdateWithWhereUniqueWithoutItemproductsaleInput[]
    updateMany?: itemitemproductsaleUpdateManyWithWhereWithoutItemproductsaleInput | itemitemproductsaleUpdateManyWithWhereWithoutItemproductsaleInput[]
    deleteMany?: itemitemproductsaleScalarWhereInput | itemitemproductsaleScalarWhereInput[]
  }

  export type itemitemproductsaleUncheckedUpdateManyWithoutItemproductsaleNestedInput = {
    create?: XOR<itemitemproductsaleCreateWithoutItemproductsaleInput, itemitemproductsaleUncheckedCreateWithoutItemproductsaleInput> | itemitemproductsaleCreateWithoutItemproductsaleInput[] | itemitemproductsaleUncheckedCreateWithoutItemproductsaleInput[]
    connectOrCreate?: itemitemproductsaleCreateOrConnectWithoutItemproductsaleInput | itemitemproductsaleCreateOrConnectWithoutItemproductsaleInput[]
    upsert?: itemitemproductsaleUpsertWithWhereUniqueWithoutItemproductsaleInput | itemitemproductsaleUpsertWithWhereUniqueWithoutItemproductsaleInput[]
    createMany?: itemitemproductsaleCreateManyItemproductsaleInputEnvelope
    set?: itemitemproductsaleWhereUniqueInput | itemitemproductsaleWhereUniqueInput[]
    disconnect?: itemitemproductsaleWhereUniqueInput | itemitemproductsaleWhereUniqueInput[]
    delete?: itemitemproductsaleWhereUniqueInput | itemitemproductsaleWhereUniqueInput[]
    connect?: itemitemproductsaleWhereUniqueInput | itemitemproductsaleWhereUniqueInput[]
    update?: itemitemproductsaleUpdateWithWhereUniqueWithoutItemproductsaleInput | itemitemproductsaleUpdateWithWhereUniqueWithoutItemproductsaleInput[]
    updateMany?: itemitemproductsaleUpdateManyWithWhereWithoutItemproductsaleInput | itemitemproductsaleUpdateManyWithWhereWithoutItemproductsaleInput[]
    deleteMany?: itemitemproductsaleScalarWhereInput | itemitemproductsaleScalarWhereInput[]
  }

  export type itemproductsaleCreateNestedOneWithoutItemitemproductsalesInput = {
    create?: XOR<itemproductsaleCreateWithoutItemitemproductsalesInput, itemproductsaleUncheckedCreateWithoutItemitemproductsalesInput>
    connectOrCreate?: itemproductsaleCreateOrConnectWithoutItemitemproductsalesInput
    connect?: itemproductsaleWhereUniqueInput
  }

  export type itemCreateNestedOneWithoutItemitemproductsalesInput = {
    create?: XOR<itemCreateWithoutItemitemproductsalesInput, itemUncheckedCreateWithoutItemitemproductsalesInput>
    connectOrCreate?: itemCreateOrConnectWithoutItemitemproductsalesInput
    connect?: itemWhereUniqueInput
  }

  export type optiongroupCreateNestedOneWithoutItemitemproductsalesInput = {
    create?: XOR<optiongroupCreateWithoutItemitemproductsalesInput, optiongroupUncheckedCreateWithoutItemitemproductsalesInput>
    connectOrCreate?: optiongroupCreateOrConnectWithoutItemitemproductsalesInput
    connect?: optiongroupWhereUniqueInput
  }

  export type itemproductsaleUpdateOneRequiredWithoutItemitemproductsalesNestedInput = {
    create?: XOR<itemproductsaleCreateWithoutItemitemproductsalesInput, itemproductsaleUncheckedCreateWithoutItemitemproductsalesInput>
    connectOrCreate?: itemproductsaleCreateOrConnectWithoutItemitemproductsalesInput
    upsert?: itemproductsaleUpsertWithoutItemitemproductsalesInput
    connect?: itemproductsaleWhereUniqueInput
    update?: XOR<XOR<itemproductsaleUpdateToOneWithWhereWithoutItemitemproductsalesInput, itemproductsaleUpdateWithoutItemitemproductsalesInput>, itemproductsaleUncheckedUpdateWithoutItemitemproductsalesInput>
  }

  export type itemUpdateOneRequiredWithoutItemitemproductsalesNestedInput = {
    create?: XOR<itemCreateWithoutItemitemproductsalesInput, itemUncheckedCreateWithoutItemitemproductsalesInput>
    connectOrCreate?: itemCreateOrConnectWithoutItemitemproductsalesInput
    upsert?: itemUpsertWithoutItemitemproductsalesInput
    connect?: itemWhereUniqueInput
    update?: XOR<XOR<itemUpdateToOneWithWhereWithoutItemitemproductsalesInput, itemUpdateWithoutItemitemproductsalesInput>, itemUncheckedUpdateWithoutItemitemproductsalesInput>
  }

  export type optiongroupUpdateOneWithoutItemitemproductsalesNestedInput = {
    create?: XOR<optiongroupCreateWithoutItemitemproductsalesInput, optiongroupUncheckedCreateWithoutItemitemproductsalesInput>
    connectOrCreate?: optiongroupCreateOrConnectWithoutItemitemproductsalesInput
    upsert?: optiongroupUpsertWithoutItemitemproductsalesInput
    disconnect?: optiongroupWhereInput | boolean
    delete?: optiongroupWhereInput | boolean
    connect?: optiongroupWhereUniqueInput
    update?: XOR<XOR<optiongroupUpdateToOneWithWhereWithoutItemitemproductsalesInput, optiongroupUpdateWithoutItemitemproductsalesInput>, optiongroupUncheckedUpdateWithoutItemitemproductsalesInput>
  }

  export type saleCreateNestedOneWithoutDeliverysalesInput = {
    create?: XOR<saleCreateWithoutDeliverysalesInput, saleUncheckedCreateWithoutDeliverysalesInput>
    connectOrCreate?: saleCreateOrConnectWithoutDeliverysalesInput
    connect?: saleWhereUniqueInput
  }

  export type deliveryaddressCreateNestedManyWithoutDeliverysaleInput = {
    create?: XOR<deliveryaddressCreateWithoutDeliverysaleInput, deliveryaddressUncheckedCreateWithoutDeliverysaleInput> | deliveryaddressCreateWithoutDeliverysaleInput[] | deliveryaddressUncheckedCreateWithoutDeliverysaleInput[]
    connectOrCreate?: deliveryaddressCreateOrConnectWithoutDeliverysaleInput | deliveryaddressCreateOrConnectWithoutDeliverysaleInput[]
    createMany?: deliveryaddressCreateManyDeliverysaleInputEnvelope
    connect?: deliveryaddressWhereUniqueInput | deliveryaddressWhereUniqueInput[]
  }

  export type deliveryaddressUncheckedCreateNestedManyWithoutDeliverysaleInput = {
    create?: XOR<deliveryaddressCreateWithoutDeliverysaleInput, deliveryaddressUncheckedCreateWithoutDeliverysaleInput> | deliveryaddressCreateWithoutDeliverysaleInput[] | deliveryaddressUncheckedCreateWithoutDeliverysaleInput[]
    connectOrCreate?: deliveryaddressCreateOrConnectWithoutDeliverysaleInput | deliveryaddressCreateOrConnectWithoutDeliverysaleInput[]
    createMany?: deliveryaddressCreateManyDeliverysaleInputEnvelope
    connect?: deliveryaddressWhereUniqueInput | deliveryaddressWhereUniqueInput[]
  }

  export type saleUpdateOneRequiredWithoutDeliverysalesNestedInput = {
    create?: XOR<saleCreateWithoutDeliverysalesInput, saleUncheckedCreateWithoutDeliverysalesInput>
    connectOrCreate?: saleCreateOrConnectWithoutDeliverysalesInput
    upsert?: saleUpsertWithoutDeliverysalesInput
    connect?: saleWhereUniqueInput
    update?: XOR<XOR<saleUpdateToOneWithWhereWithoutDeliverysalesInput, saleUpdateWithoutDeliverysalesInput>, saleUncheckedUpdateWithoutDeliverysalesInput>
  }

  export type deliveryaddressUpdateManyWithoutDeliverysaleNestedInput = {
    create?: XOR<deliveryaddressCreateWithoutDeliverysaleInput, deliveryaddressUncheckedCreateWithoutDeliverysaleInput> | deliveryaddressCreateWithoutDeliverysaleInput[] | deliveryaddressUncheckedCreateWithoutDeliverysaleInput[]
    connectOrCreate?: deliveryaddressCreateOrConnectWithoutDeliverysaleInput | deliveryaddressCreateOrConnectWithoutDeliverysaleInput[]
    upsert?: deliveryaddressUpsertWithWhereUniqueWithoutDeliverysaleInput | deliveryaddressUpsertWithWhereUniqueWithoutDeliverysaleInput[]
    createMany?: deliveryaddressCreateManyDeliverysaleInputEnvelope
    set?: deliveryaddressWhereUniqueInput | deliveryaddressWhereUniqueInput[]
    disconnect?: deliveryaddressWhereUniqueInput | deliveryaddressWhereUniqueInput[]
    delete?: deliveryaddressWhereUniqueInput | deliveryaddressWhereUniqueInput[]
    connect?: deliveryaddressWhereUniqueInput | deliveryaddressWhereUniqueInput[]
    update?: deliveryaddressUpdateWithWhereUniqueWithoutDeliverysaleInput | deliveryaddressUpdateWithWhereUniqueWithoutDeliverysaleInput[]
    updateMany?: deliveryaddressUpdateManyWithWhereWithoutDeliverysaleInput | deliveryaddressUpdateManyWithWhereWithoutDeliverysaleInput[]
    deleteMany?: deliveryaddressScalarWhereInput | deliveryaddressScalarWhereInput[]
  }

  export type deliveryaddressUncheckedUpdateManyWithoutDeliverysaleNestedInput = {
    create?: XOR<deliveryaddressCreateWithoutDeliverysaleInput, deliveryaddressUncheckedCreateWithoutDeliverysaleInput> | deliveryaddressCreateWithoutDeliverysaleInput[] | deliveryaddressUncheckedCreateWithoutDeliverysaleInput[]
    connectOrCreate?: deliveryaddressCreateOrConnectWithoutDeliverysaleInput | deliveryaddressCreateOrConnectWithoutDeliverysaleInput[]
    upsert?: deliveryaddressUpsertWithWhereUniqueWithoutDeliverysaleInput | deliveryaddressUpsertWithWhereUniqueWithoutDeliverysaleInput[]
    createMany?: deliveryaddressCreateManyDeliverysaleInputEnvelope
    set?: deliveryaddressWhereUniqueInput | deliveryaddressWhereUniqueInput[]
    disconnect?: deliveryaddressWhereUniqueInput | deliveryaddressWhereUniqueInput[]
    delete?: deliveryaddressWhereUniqueInput | deliveryaddressWhereUniqueInput[]
    connect?: deliveryaddressWhereUniqueInput | deliveryaddressWhereUniqueInput[]
    update?: deliveryaddressUpdateWithWhereUniqueWithoutDeliverysaleInput | deliveryaddressUpdateWithWhereUniqueWithoutDeliverysaleInput[]
    updateMany?: deliveryaddressUpdateManyWithWhereWithoutDeliverysaleInput | deliveryaddressUpdateManyWithWhereWithoutDeliverysaleInput[]
    deleteMany?: deliveryaddressScalarWhereInput | deliveryaddressScalarWhereInput[]
  }

  export type saleCreateNestedOneWithoutDeliveryaddressInput = {
    create?: XOR<saleCreateWithoutDeliveryaddressInput, saleUncheckedCreateWithoutDeliveryaddressInput>
    connectOrCreate?: saleCreateOrConnectWithoutDeliveryaddressInput
    connect?: saleWhereUniqueInput
  }

  export type deliverysaleCreateNestedOneWithoutDeliveryaddressesInput = {
    create?: XOR<deliverysaleCreateWithoutDeliveryaddressesInput, deliverysaleUncheckedCreateWithoutDeliveryaddressesInput>
    connectOrCreate?: deliverysaleCreateOrConnectWithoutDeliveryaddressesInput
    connect?: deliverysaleWhereUniqueInput
  }

  export type saleUpdateOneRequiredWithoutDeliveryaddressNestedInput = {
    create?: XOR<saleCreateWithoutDeliveryaddressInput, saleUncheckedCreateWithoutDeliveryaddressInput>
    connectOrCreate?: saleCreateOrConnectWithoutDeliveryaddressInput
    upsert?: saleUpsertWithoutDeliveryaddressInput
    connect?: saleWhereUniqueInput
    update?: XOR<XOR<saleUpdateToOneWithWhereWithoutDeliveryaddressInput, saleUpdateWithoutDeliveryaddressInput>, saleUncheckedUpdateWithoutDeliveryaddressInput>
  }

  export type deliverysaleUpdateOneWithoutDeliveryaddressesNestedInput = {
    create?: XOR<deliverysaleCreateWithoutDeliveryaddressesInput, deliverysaleUncheckedCreateWithoutDeliveryaddressesInput>
    connectOrCreate?: deliverysaleCreateOrConnectWithoutDeliveryaddressesInput
    upsert?: deliverysaleUpsertWithoutDeliveryaddressesInput
    disconnect?: deliverysaleWhereInput | boolean
    delete?: deliverysaleWhereInput | boolean
    connect?: deliverysaleWhereUniqueInput
    update?: XOR<XOR<deliverysaleUpdateToOneWithWhereWithoutDeliveryaddressesInput, deliverysaleUpdateWithoutDeliveryaddressesInput>, deliverysaleUncheckedUpdateWithoutDeliveryaddressesInput>
  }

  export type brandCreateNestedOneWithoutPaymenttypesInput = {
    create?: XOR<brandCreateWithoutPaymenttypesInput, brandUncheckedCreateWithoutPaymenttypesInput>
    connectOrCreate?: brandCreateOrConnectWithoutPaymenttypesInput
    connect?: brandWhereUniqueInput
  }

  export type paymentCreateNestedManyWithoutPaymenttypeInput = {
    create?: XOR<paymentCreateWithoutPaymenttypeInput, paymentUncheckedCreateWithoutPaymenttypeInput> | paymentCreateWithoutPaymenttypeInput[] | paymentUncheckedCreateWithoutPaymenttypeInput[]
    connectOrCreate?: paymentCreateOrConnectWithoutPaymenttypeInput | paymentCreateOrConnectWithoutPaymenttypeInput[]
    createMany?: paymentCreateManyPaymenttypeInputEnvelope
    connect?: paymentWhereUniqueInput | paymentWhereUniqueInput[]
  }

  export type paymentUncheckedCreateNestedManyWithoutPaymenttypeInput = {
    create?: XOR<paymentCreateWithoutPaymenttypeInput, paymentUncheckedCreateWithoutPaymenttypeInput> | paymentCreateWithoutPaymenttypeInput[] | paymentUncheckedCreateWithoutPaymenttypeInput[]
    connectOrCreate?: paymentCreateOrConnectWithoutPaymenttypeInput | paymentCreateOrConnectWithoutPaymenttypeInput[]
    createMany?: paymentCreateManyPaymenttypeInputEnvelope
    connect?: paymentWhereUniqueInput | paymentWhereUniqueInput[]
  }

  export type brandUpdateOneWithoutPaymenttypesNestedInput = {
    create?: XOR<brandCreateWithoutPaymenttypesInput, brandUncheckedCreateWithoutPaymenttypesInput>
    connectOrCreate?: brandCreateOrConnectWithoutPaymenttypesInput
    upsert?: brandUpsertWithoutPaymenttypesInput
    disconnect?: brandWhereInput | boolean
    delete?: brandWhereInput | boolean
    connect?: brandWhereUniqueInput
    update?: XOR<XOR<brandUpdateToOneWithWhereWithoutPaymenttypesInput, brandUpdateWithoutPaymenttypesInput>, brandUncheckedUpdateWithoutPaymenttypesInput>
  }

  export type paymentUpdateManyWithoutPaymenttypeNestedInput = {
    create?: XOR<paymentCreateWithoutPaymenttypeInput, paymentUncheckedCreateWithoutPaymenttypeInput> | paymentCreateWithoutPaymenttypeInput[] | paymentUncheckedCreateWithoutPaymenttypeInput[]
    connectOrCreate?: paymentCreateOrConnectWithoutPaymenttypeInput | paymentCreateOrConnectWithoutPaymenttypeInput[]
    upsert?: paymentUpsertWithWhereUniqueWithoutPaymenttypeInput | paymentUpsertWithWhereUniqueWithoutPaymenttypeInput[]
    createMany?: paymentCreateManyPaymenttypeInputEnvelope
    set?: paymentWhereUniqueInput | paymentWhereUniqueInput[]
    disconnect?: paymentWhereUniqueInput | paymentWhereUniqueInput[]
    delete?: paymentWhereUniqueInput | paymentWhereUniqueInput[]
    connect?: paymentWhereUniqueInput | paymentWhereUniqueInput[]
    update?: paymentUpdateWithWhereUniqueWithoutPaymenttypeInput | paymentUpdateWithWhereUniqueWithoutPaymenttypeInput[]
    updateMany?: paymentUpdateManyWithWhereWithoutPaymenttypeInput | paymentUpdateManyWithWhereWithoutPaymenttypeInput[]
    deleteMany?: paymentScalarWhereInput | paymentScalarWhereInput[]
  }

  export type paymentUncheckedUpdateManyWithoutPaymenttypeNestedInput = {
    create?: XOR<paymentCreateWithoutPaymenttypeInput, paymentUncheckedCreateWithoutPaymenttypeInput> | paymentCreateWithoutPaymenttypeInput[] | paymentUncheckedCreateWithoutPaymenttypeInput[]
    connectOrCreate?: paymentCreateOrConnectWithoutPaymenttypeInput | paymentCreateOrConnectWithoutPaymenttypeInput[]
    upsert?: paymentUpsertWithWhereUniqueWithoutPaymenttypeInput | paymentUpsertWithWhereUniqueWithoutPaymenttypeInput[]
    createMany?: paymentCreateManyPaymenttypeInputEnvelope
    set?: paymentWhereUniqueInput | paymentWhereUniqueInput[]
    disconnect?: paymentWhereUniqueInput | paymentWhereUniqueInput[]
    delete?: paymentWhereUniqueInput | paymentWhereUniqueInput[]
    connect?: paymentWhereUniqueInput | paymentWhereUniqueInput[]
    update?: paymentUpdateWithWhereUniqueWithoutPaymenttypeInput | paymentUpdateWithWhereUniqueWithoutPaymenttypeInput[]
    updateMany?: paymentUpdateManyWithWhereWithoutPaymenttypeInput | paymentUpdateManyWithWhereWithoutPaymenttypeInput[]
    deleteMany?: paymentScalarWhereInput | paymentScalarWhereInput[]
  }

  export type saleCreateNestedOneWithoutPaymentsInput = {
    create?: XOR<saleCreateWithoutPaymentsInput, saleUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: saleCreateOrConnectWithoutPaymentsInput
    connect?: saleWhereUniqueInput
  }

  export type paymenttypeCreateNestedOneWithoutPaymentsInput = {
    create?: XOR<paymenttypeCreateWithoutPaymentsInput, paymenttypeUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: paymenttypeCreateOrConnectWithoutPaymentsInput
    connect?: paymenttypeWhereUniqueInput
  }

  export type saleUpdateOneRequiredWithoutPaymentsNestedInput = {
    create?: XOR<saleCreateWithoutPaymentsInput, saleUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: saleCreateOrConnectWithoutPaymentsInput
    upsert?: saleUpsertWithoutPaymentsInput
    connect?: saleWhereUniqueInput
    update?: XOR<XOR<saleUpdateToOneWithWhereWithoutPaymentsInput, saleUpdateWithoutPaymentsInput>, saleUncheckedUpdateWithoutPaymentsInput>
  }

  export type paymenttypeUpdateOneWithoutPaymentsNestedInput = {
    create?: XOR<paymenttypeCreateWithoutPaymentsInput, paymenttypeUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: paymenttypeCreateOrConnectWithoutPaymentsInput
    upsert?: paymenttypeUpsertWithoutPaymentsInput
    disconnect?: paymenttypeWhereInput | boolean
    delete?: paymenttypeWhereInput | boolean
    connect?: paymenttypeWhereUniqueInput
    update?: XOR<XOR<paymenttypeUpdateToOneWithWhereWithoutPaymentsInput, paymenttypeUpdateWithoutPaymentsInput>, paymenttypeUncheckedUpdateWithoutPaymentsInput>
  }

  export type brandCreateNestedOneWithoutCouponsInput = {
    create?: XOR<brandCreateWithoutCouponsInput, brandUncheckedCreateWithoutCouponsInput>
    connectOrCreate?: brandCreateOrConnectWithoutCouponsInput
    connect?: brandWhereUniqueInput
  }

  export type couponsaleCreateNestedManyWithoutCouponInput = {
    create?: XOR<couponsaleCreateWithoutCouponInput, couponsaleUncheckedCreateWithoutCouponInput> | couponsaleCreateWithoutCouponInput[] | couponsaleUncheckedCreateWithoutCouponInput[]
    connectOrCreate?: couponsaleCreateOrConnectWithoutCouponInput | couponsaleCreateOrConnectWithoutCouponInput[]
    createMany?: couponsaleCreateManyCouponInputEnvelope
    connect?: couponsaleWhereUniqueInput | couponsaleWhereUniqueInput[]
  }

  export type couponsaleUncheckedCreateNestedManyWithoutCouponInput = {
    create?: XOR<couponsaleCreateWithoutCouponInput, couponsaleUncheckedCreateWithoutCouponInput> | couponsaleCreateWithoutCouponInput[] | couponsaleUncheckedCreateWithoutCouponInput[]
    connectOrCreate?: couponsaleCreateOrConnectWithoutCouponInput | couponsaleCreateOrConnectWithoutCouponInput[]
    createMany?: couponsaleCreateManyCouponInputEnvelope
    connect?: couponsaleWhereUniqueInput | couponsaleWhereUniqueInput[]
  }

  export type brandUpdateOneWithoutCouponsNestedInput = {
    create?: XOR<brandCreateWithoutCouponsInput, brandUncheckedCreateWithoutCouponsInput>
    connectOrCreate?: brandCreateOrConnectWithoutCouponsInput
    upsert?: brandUpsertWithoutCouponsInput
    disconnect?: brandWhereInput | boolean
    delete?: brandWhereInput | boolean
    connect?: brandWhereUniqueInput
    update?: XOR<XOR<brandUpdateToOneWithWhereWithoutCouponsInput, brandUpdateWithoutCouponsInput>, brandUncheckedUpdateWithoutCouponsInput>
  }

  export type couponsaleUpdateManyWithoutCouponNestedInput = {
    create?: XOR<couponsaleCreateWithoutCouponInput, couponsaleUncheckedCreateWithoutCouponInput> | couponsaleCreateWithoutCouponInput[] | couponsaleUncheckedCreateWithoutCouponInput[]
    connectOrCreate?: couponsaleCreateOrConnectWithoutCouponInput | couponsaleCreateOrConnectWithoutCouponInput[]
    upsert?: couponsaleUpsertWithWhereUniqueWithoutCouponInput | couponsaleUpsertWithWhereUniqueWithoutCouponInput[]
    createMany?: couponsaleCreateManyCouponInputEnvelope
    set?: couponsaleWhereUniqueInput | couponsaleWhereUniqueInput[]
    disconnect?: couponsaleWhereUniqueInput | couponsaleWhereUniqueInput[]
    delete?: couponsaleWhereUniqueInput | couponsaleWhereUniqueInput[]
    connect?: couponsaleWhereUniqueInput | couponsaleWhereUniqueInput[]
    update?: couponsaleUpdateWithWhereUniqueWithoutCouponInput | couponsaleUpdateWithWhereUniqueWithoutCouponInput[]
    updateMany?: couponsaleUpdateManyWithWhereWithoutCouponInput | couponsaleUpdateManyWithWhereWithoutCouponInput[]
    deleteMany?: couponsaleScalarWhereInput | couponsaleScalarWhereInput[]
  }

  export type couponsaleUncheckedUpdateManyWithoutCouponNestedInput = {
    create?: XOR<couponsaleCreateWithoutCouponInput, couponsaleUncheckedCreateWithoutCouponInput> | couponsaleCreateWithoutCouponInput[] | couponsaleUncheckedCreateWithoutCouponInput[]
    connectOrCreate?: couponsaleCreateOrConnectWithoutCouponInput | couponsaleCreateOrConnectWithoutCouponInput[]
    upsert?: couponsaleUpsertWithWhereUniqueWithoutCouponInput | couponsaleUpsertWithWhereUniqueWithoutCouponInput[]
    createMany?: couponsaleCreateManyCouponInputEnvelope
    set?: couponsaleWhereUniqueInput | couponsaleWhereUniqueInput[]
    disconnect?: couponsaleWhereUniqueInput | couponsaleWhereUniqueInput[]
    delete?: couponsaleWhereUniqueInput | couponsaleWhereUniqueInput[]
    connect?: couponsaleWhereUniqueInput | couponsaleWhereUniqueInput[]
    update?: couponsaleUpdateWithWhereUniqueWithoutCouponInput | couponsaleUpdateWithWhereUniqueWithoutCouponInput[]
    updateMany?: couponsaleUpdateManyWithWhereWithoutCouponInput | couponsaleUpdateManyWithWhereWithoutCouponInput[]
    deleteMany?: couponsaleScalarWhereInput | couponsaleScalarWhereInput[]
  }

  export type saleCreateNestedOneWithoutCouponsalesInput = {
    create?: XOR<saleCreateWithoutCouponsalesInput, saleUncheckedCreateWithoutCouponsalesInput>
    connectOrCreate?: saleCreateOrConnectWithoutCouponsalesInput
    connect?: saleWhereUniqueInput
  }

  export type couponCreateNestedOneWithoutCouponsalesInput = {
    create?: XOR<couponCreateWithoutCouponsalesInput, couponUncheckedCreateWithoutCouponsalesInput>
    connectOrCreate?: couponCreateOrConnectWithoutCouponsalesInput
    connect?: couponWhereUniqueInput
  }

  export type saleUpdateOneWithoutCouponsalesNestedInput = {
    create?: XOR<saleCreateWithoutCouponsalesInput, saleUncheckedCreateWithoutCouponsalesInput>
    connectOrCreate?: saleCreateOrConnectWithoutCouponsalesInput
    upsert?: saleUpsertWithoutCouponsalesInput
    disconnect?: saleWhereInput | boolean
    delete?: saleWhereInput | boolean
    connect?: saleWhereUniqueInput
    update?: XOR<XOR<saleUpdateToOneWithWhereWithoutCouponsalesInput, saleUpdateWithoutCouponsalesInput>, saleUncheckedUpdateWithoutCouponsalesInput>
  }

  export type couponUpdateOneWithoutCouponsalesNestedInput = {
    create?: XOR<couponCreateWithoutCouponsalesInput, couponUncheckedCreateWithoutCouponsalesInput>
    connectOrCreate?: couponCreateOrConnectWithoutCouponsalesInput
    upsert?: couponUpsertWithoutCouponsalesInput
    disconnect?: couponWhereInput | boolean
    delete?: couponWhereInput | boolean
    connect?: couponWhereUniqueInput
    update?: XOR<XOR<couponUpdateToOneWithWhereWithoutCouponsalesInput, couponUpdateWithoutCouponsalesInput>, couponUncheckedUpdateWithoutCouponsalesInput>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedDecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type NestedBoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedDecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type NestedBoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedDecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedDecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type subbrandCreateWithoutBrandInput = {
    name: string
    created_at?: Date | string | null
    stores?: storeCreateNestedManyWithoutSubbrandInput
    categories?: categoryCreateNestedManyWithoutSubbrandInput
    products?: productCreateNestedManyWithoutSubbrandInput
    optiongroups?: optiongroupCreateNestedManyWithoutSubbrandInput
    items?: itemCreateNestedManyWithoutSubbrandInput
    customers?: customerCreateNestedManyWithoutSubbrandInput
    sales?: saleCreateNestedManyWithoutSubbrandInput
  }

  export type subbrandUncheckedCreateWithoutBrandInput = {
    id?: number
    name: string
    created_at?: Date | string | null
    stores?: storeUncheckedCreateNestedManyWithoutSubbrandInput
    categories?: categoryUncheckedCreateNestedManyWithoutSubbrandInput
    products?: productUncheckedCreateNestedManyWithoutSubbrandInput
    optiongroups?: optiongroupUncheckedCreateNestedManyWithoutSubbrandInput
    items?: itemUncheckedCreateNestedManyWithoutSubbrandInput
    customers?: customerUncheckedCreateNestedManyWithoutSubbrandInput
    sales?: saleUncheckedCreateNestedManyWithoutSubbrandInput
  }

  export type subbrandCreateOrConnectWithoutBrandInput = {
    where: subbrandWhereUniqueInput
    create: XOR<subbrandCreateWithoutBrandInput, subbrandUncheckedCreateWithoutBrandInput>
  }

  export type subbrandCreateManyBrandInputEnvelope = {
    data: subbrandCreateManyBrandInput | subbrandCreateManyBrandInput[]
    skipDuplicates?: boolean
  }

  export type storeCreateWithoutBrandInput = {
    name: string
    city?: string | null
    state?: string | null
    district?: string | null
    address_street?: string | null
    address_number?: number | null
    zipcode?: string | null
    latitude?: Decimal | DecimalJsLike | number | string | null
    longitude?: Decimal | DecimalJsLike | number | string | null
    is_active?: boolean | null
    is_own?: boolean | null
    is_holding?: boolean | null
    creation_date?: Date | string | null
    created_at?: Date | string | null
    subbrand?: subbrandCreateNestedOneWithoutStoresInput
    customers?: customerCreateNestedManyWithoutStoreInput
    sales?: saleCreateNestedManyWithoutStoreInput
  }

  export type storeUncheckedCreateWithoutBrandInput = {
    id?: number
    sub_brand_id?: number | null
    name: string
    city?: string | null
    state?: string | null
    district?: string | null
    address_street?: string | null
    address_number?: number | null
    zipcode?: string | null
    latitude?: Decimal | DecimalJsLike | number | string | null
    longitude?: Decimal | DecimalJsLike | number | string | null
    is_active?: boolean | null
    is_own?: boolean | null
    is_holding?: boolean | null
    creation_date?: Date | string | null
    created_at?: Date | string | null
    customers?: customerUncheckedCreateNestedManyWithoutStoreInput
    sales?: saleUncheckedCreateNestedManyWithoutStoreInput
  }

  export type storeCreateOrConnectWithoutBrandInput = {
    where: storeWhereUniqueInput
    create: XOR<storeCreateWithoutBrandInput, storeUncheckedCreateWithoutBrandInput>
  }

  export type storeCreateManyBrandInputEnvelope = {
    data: storeCreateManyBrandInput | storeCreateManyBrandInput[]
    skipDuplicates?: boolean
  }

  export type channelCreateWithoutBrandInput = {
    name: string
    description?: string | null
    type?: string | null
    created_at?: Date | string | null
    sales?: saleCreateNestedManyWithoutChannelInput
  }

  export type channelUncheckedCreateWithoutBrandInput = {
    id?: number
    name: string
    description?: string | null
    type?: string | null
    created_at?: Date | string | null
    sales?: saleUncheckedCreateNestedManyWithoutChannelInput
  }

  export type channelCreateOrConnectWithoutBrandInput = {
    where: channelWhereUniqueInput
    create: XOR<channelCreateWithoutBrandInput, channelUncheckedCreateWithoutBrandInput>
  }

  export type channelCreateManyBrandInputEnvelope = {
    data: channelCreateManyBrandInput | channelCreateManyBrandInput[]
    skipDuplicates?: boolean
  }

  export type categoryCreateWithoutBrandInput = {
    name: string
    type?: string | null
    pos_uuid?: string | null
    deleted_at?: Date | string | null
    subbrand?: subbrandCreateNestedOneWithoutCategoriesInput
    products?: productCreateNestedManyWithoutCategoryInput
    optiongroups?: optiongroupCreateNestedManyWithoutCategoryInput
    items?: itemCreateNestedManyWithoutCategoryInput
  }

  export type categoryUncheckedCreateWithoutBrandInput = {
    id?: number
    sub_brand_id?: number | null
    name: string
    type?: string | null
    pos_uuid?: string | null
    deleted_at?: Date | string | null
    products?: productUncheckedCreateNestedManyWithoutCategoryInput
    optiongroups?: optiongroupUncheckedCreateNestedManyWithoutCategoryInput
    items?: itemUncheckedCreateNestedManyWithoutCategoryInput
  }

  export type categoryCreateOrConnectWithoutBrandInput = {
    where: categoryWhereUniqueInput
    create: XOR<categoryCreateWithoutBrandInput, categoryUncheckedCreateWithoutBrandInput>
  }

  export type categoryCreateManyBrandInputEnvelope = {
    data: categoryCreateManyBrandInput | categoryCreateManyBrandInput[]
    skipDuplicates?: boolean
  }

  export type productCreateWithoutBrandInput = {
    name: string
    pos_uuid?: string | null
    deleted_at?: Date | string | null
    subbrand?: subbrandCreateNestedOneWithoutProductsInput
    category?: categoryCreateNestedOneWithoutProductsInput
    productsales?: productsaleCreateNestedManyWithoutProductInput
  }

  export type productUncheckedCreateWithoutBrandInput = {
    id?: number
    sub_brand_id?: number | null
    category_id?: number | null
    name: string
    pos_uuid?: string | null
    deleted_at?: Date | string | null
    productsales?: productsaleUncheckedCreateNestedManyWithoutProductInput
  }

  export type productCreateOrConnectWithoutBrandInput = {
    where: productWhereUniqueInput
    create: XOR<productCreateWithoutBrandInput, productUncheckedCreateWithoutBrandInput>
  }

  export type productCreateManyBrandInputEnvelope = {
    data: productCreateManyBrandInput | productCreateManyBrandInput[]
    skipDuplicates?: boolean
  }

  export type optiongroupCreateWithoutBrandInput = {
    name: string
    pos_uuid?: string | null
    deleted_at?: Date | string | null
    subbrand?: subbrandCreateNestedOneWithoutOptiongroupsInput
    category?: categoryCreateNestedOneWithoutOptiongroupsInput
    itemproductsales?: itemproductsaleCreateNestedManyWithoutOptiongroupInput
    itemitemproductsales?: itemitemproductsaleCreateNestedManyWithoutOptiongroupInput
  }

  export type optiongroupUncheckedCreateWithoutBrandInput = {
    id?: number
    sub_brand_id?: number | null
    category_id?: number | null
    name: string
    pos_uuid?: string | null
    deleted_at?: Date | string | null
    itemproductsales?: itemproductsaleUncheckedCreateNestedManyWithoutOptiongroupInput
    itemitemproductsales?: itemitemproductsaleUncheckedCreateNestedManyWithoutOptiongroupInput
  }

  export type optiongroupCreateOrConnectWithoutBrandInput = {
    where: optiongroupWhereUniqueInput
    create: XOR<optiongroupCreateWithoutBrandInput, optiongroupUncheckedCreateWithoutBrandInput>
  }

  export type optiongroupCreateManyBrandInputEnvelope = {
    data: optiongroupCreateManyBrandInput | optiongroupCreateManyBrandInput[]
    skipDuplicates?: boolean
  }

  export type itemCreateWithoutBrandInput = {
    name: string
    pos_uuid?: string | null
    deleted_at?: Date | string | null
    subbrand?: subbrandCreateNestedOneWithoutItemsInput
    category?: categoryCreateNestedOneWithoutItemsInput
    itemproductsales?: itemproductsaleCreateNestedManyWithoutItemInput
    itemitemproductsales?: itemitemproductsaleCreateNestedManyWithoutItemInput
  }

  export type itemUncheckedCreateWithoutBrandInput = {
    id?: number
    sub_brand_id?: number | null
    category_id?: number | null
    name: string
    pos_uuid?: string | null
    deleted_at?: Date | string | null
    itemproductsales?: itemproductsaleUncheckedCreateNestedManyWithoutItemInput
    itemitemproductsales?: itemitemproductsaleUncheckedCreateNestedManyWithoutItemInput
  }

  export type itemCreateOrConnectWithoutBrandInput = {
    where: itemWhereUniqueInput
    create: XOR<itemCreateWithoutBrandInput, itemUncheckedCreateWithoutBrandInput>
  }

  export type itemCreateManyBrandInputEnvelope = {
    data: itemCreateManyBrandInput | itemCreateManyBrandInput[]
    skipDuplicates?: boolean
  }

  export type paymenttypeCreateWithoutBrandInput = {
    description: string
    payments?: paymentCreateNestedManyWithoutPaymenttypeInput
  }

  export type paymenttypeUncheckedCreateWithoutBrandInput = {
    id?: number
    description: string
    payments?: paymentUncheckedCreateNestedManyWithoutPaymenttypeInput
  }

  export type paymenttypeCreateOrConnectWithoutBrandInput = {
    where: paymenttypeWhereUniqueInput
    create: XOR<paymenttypeCreateWithoutBrandInput, paymenttypeUncheckedCreateWithoutBrandInput>
  }

  export type paymenttypeCreateManyBrandInputEnvelope = {
    data: paymenttypeCreateManyBrandInput | paymenttypeCreateManyBrandInput[]
    skipDuplicates?: boolean
  }

  export type couponCreateWithoutBrandInput = {
    code: string
    discount_type?: string | null
    discount_value?: Decimal | DecimalJsLike | number | string | null
    is_active?: boolean | null
    valid_from?: Date | string | null
    valid_until?: Date | string | null
    couponsales?: couponsaleCreateNestedManyWithoutCouponInput
  }

  export type couponUncheckedCreateWithoutBrandInput = {
    id?: number
    code: string
    discount_type?: string | null
    discount_value?: Decimal | DecimalJsLike | number | string | null
    is_active?: boolean | null
    valid_from?: Date | string | null
    valid_until?: Date | string | null
    couponsales?: couponsaleUncheckedCreateNestedManyWithoutCouponInput
  }

  export type couponCreateOrConnectWithoutBrandInput = {
    where: couponWhereUniqueInput
    create: XOR<couponCreateWithoutBrandInput, couponUncheckedCreateWithoutBrandInput>
  }

  export type couponCreateManyBrandInputEnvelope = {
    data: couponCreateManyBrandInput | couponCreateManyBrandInput[]
    skipDuplicates?: boolean
  }

  export type subbrandUpsertWithWhereUniqueWithoutBrandInput = {
    where: subbrandWhereUniqueInput
    update: XOR<subbrandUpdateWithoutBrandInput, subbrandUncheckedUpdateWithoutBrandInput>
    create: XOR<subbrandCreateWithoutBrandInput, subbrandUncheckedCreateWithoutBrandInput>
  }

  export type subbrandUpdateWithWhereUniqueWithoutBrandInput = {
    where: subbrandWhereUniqueInput
    data: XOR<subbrandUpdateWithoutBrandInput, subbrandUncheckedUpdateWithoutBrandInput>
  }

  export type subbrandUpdateManyWithWhereWithoutBrandInput = {
    where: subbrandScalarWhereInput
    data: XOR<subbrandUpdateManyMutationInput, subbrandUncheckedUpdateManyWithoutBrandInput>
  }

  export type subbrandScalarWhereInput = {
    AND?: subbrandScalarWhereInput | subbrandScalarWhereInput[]
    OR?: subbrandScalarWhereInput[]
    NOT?: subbrandScalarWhereInput | subbrandScalarWhereInput[]
    id?: IntFilter<"subbrand"> | number
    brand_id?: IntFilter<"subbrand"> | number
    name?: StringFilter<"subbrand"> | string
    created_at?: DateTimeNullableFilter<"subbrand"> | Date | string | null
  }

  export type storeUpsertWithWhereUniqueWithoutBrandInput = {
    where: storeWhereUniqueInput
    update: XOR<storeUpdateWithoutBrandInput, storeUncheckedUpdateWithoutBrandInput>
    create: XOR<storeCreateWithoutBrandInput, storeUncheckedCreateWithoutBrandInput>
  }

  export type storeUpdateWithWhereUniqueWithoutBrandInput = {
    where: storeWhereUniqueInput
    data: XOR<storeUpdateWithoutBrandInput, storeUncheckedUpdateWithoutBrandInput>
  }

  export type storeUpdateManyWithWhereWithoutBrandInput = {
    where: storeScalarWhereInput
    data: XOR<storeUpdateManyMutationInput, storeUncheckedUpdateManyWithoutBrandInput>
  }

  export type storeScalarWhereInput = {
    AND?: storeScalarWhereInput | storeScalarWhereInput[]
    OR?: storeScalarWhereInput[]
    NOT?: storeScalarWhereInput | storeScalarWhereInput[]
    id?: IntFilter<"store"> | number
    brand_id?: IntFilter<"store"> | number
    sub_brand_id?: IntNullableFilter<"store"> | number | null
    name?: StringFilter<"store"> | string
    city?: StringNullableFilter<"store"> | string | null
    state?: StringNullableFilter<"store"> | string | null
    district?: StringNullableFilter<"store"> | string | null
    address_street?: StringNullableFilter<"store"> | string | null
    address_number?: IntNullableFilter<"store"> | number | null
    zipcode?: StringNullableFilter<"store"> | string | null
    latitude?: DecimalNullableFilter<"store"> | Decimal | DecimalJsLike | number | string | null
    longitude?: DecimalNullableFilter<"store"> | Decimal | DecimalJsLike | number | string | null
    is_active?: BoolNullableFilter<"store"> | boolean | null
    is_own?: BoolNullableFilter<"store"> | boolean | null
    is_holding?: BoolNullableFilter<"store"> | boolean | null
    creation_date?: DateTimeNullableFilter<"store"> | Date | string | null
    created_at?: DateTimeNullableFilter<"store"> | Date | string | null
  }

  export type channelUpsertWithWhereUniqueWithoutBrandInput = {
    where: channelWhereUniqueInput
    update: XOR<channelUpdateWithoutBrandInput, channelUncheckedUpdateWithoutBrandInput>
    create: XOR<channelCreateWithoutBrandInput, channelUncheckedCreateWithoutBrandInput>
  }

  export type channelUpdateWithWhereUniqueWithoutBrandInput = {
    where: channelWhereUniqueInput
    data: XOR<channelUpdateWithoutBrandInput, channelUncheckedUpdateWithoutBrandInput>
  }

  export type channelUpdateManyWithWhereWithoutBrandInput = {
    where: channelScalarWhereInput
    data: XOR<channelUpdateManyMutationInput, channelUncheckedUpdateManyWithoutBrandInput>
  }

  export type channelScalarWhereInput = {
    AND?: channelScalarWhereInput | channelScalarWhereInput[]
    OR?: channelScalarWhereInput[]
    NOT?: channelScalarWhereInput | channelScalarWhereInput[]
    id?: IntFilter<"channel"> | number
    brand_id?: IntFilter<"channel"> | number
    name?: StringFilter<"channel"> | string
    description?: StringNullableFilter<"channel"> | string | null
    type?: StringNullableFilter<"channel"> | string | null
    created_at?: DateTimeNullableFilter<"channel"> | Date | string | null
  }

  export type categoryUpsertWithWhereUniqueWithoutBrandInput = {
    where: categoryWhereUniqueInput
    update: XOR<categoryUpdateWithoutBrandInput, categoryUncheckedUpdateWithoutBrandInput>
    create: XOR<categoryCreateWithoutBrandInput, categoryUncheckedCreateWithoutBrandInput>
  }

  export type categoryUpdateWithWhereUniqueWithoutBrandInput = {
    where: categoryWhereUniqueInput
    data: XOR<categoryUpdateWithoutBrandInput, categoryUncheckedUpdateWithoutBrandInput>
  }

  export type categoryUpdateManyWithWhereWithoutBrandInput = {
    where: categoryScalarWhereInput
    data: XOR<categoryUpdateManyMutationInput, categoryUncheckedUpdateManyWithoutBrandInput>
  }

  export type categoryScalarWhereInput = {
    AND?: categoryScalarWhereInput | categoryScalarWhereInput[]
    OR?: categoryScalarWhereInput[]
    NOT?: categoryScalarWhereInput | categoryScalarWhereInput[]
    id?: IntFilter<"category"> | number
    brand_id?: IntFilter<"category"> | number
    sub_brand_id?: IntNullableFilter<"category"> | number | null
    name?: StringFilter<"category"> | string
    type?: StringNullableFilter<"category"> | string | null
    pos_uuid?: StringNullableFilter<"category"> | string | null
    deleted_at?: DateTimeNullableFilter<"category"> | Date | string | null
  }

  export type productUpsertWithWhereUniqueWithoutBrandInput = {
    where: productWhereUniqueInput
    update: XOR<productUpdateWithoutBrandInput, productUncheckedUpdateWithoutBrandInput>
    create: XOR<productCreateWithoutBrandInput, productUncheckedCreateWithoutBrandInput>
  }

  export type productUpdateWithWhereUniqueWithoutBrandInput = {
    where: productWhereUniqueInput
    data: XOR<productUpdateWithoutBrandInput, productUncheckedUpdateWithoutBrandInput>
  }

  export type productUpdateManyWithWhereWithoutBrandInput = {
    where: productScalarWhereInput
    data: XOR<productUpdateManyMutationInput, productUncheckedUpdateManyWithoutBrandInput>
  }

  export type productScalarWhereInput = {
    AND?: productScalarWhereInput | productScalarWhereInput[]
    OR?: productScalarWhereInput[]
    NOT?: productScalarWhereInput | productScalarWhereInput[]
    id?: IntFilter<"product"> | number
    brand_id?: IntFilter<"product"> | number
    sub_brand_id?: IntNullableFilter<"product"> | number | null
    category_id?: IntNullableFilter<"product"> | number | null
    name?: StringFilter<"product"> | string
    pos_uuid?: StringNullableFilter<"product"> | string | null
    deleted_at?: DateTimeNullableFilter<"product"> | Date | string | null
  }

  export type optiongroupUpsertWithWhereUniqueWithoutBrandInput = {
    where: optiongroupWhereUniqueInput
    update: XOR<optiongroupUpdateWithoutBrandInput, optiongroupUncheckedUpdateWithoutBrandInput>
    create: XOR<optiongroupCreateWithoutBrandInput, optiongroupUncheckedCreateWithoutBrandInput>
  }

  export type optiongroupUpdateWithWhereUniqueWithoutBrandInput = {
    where: optiongroupWhereUniqueInput
    data: XOR<optiongroupUpdateWithoutBrandInput, optiongroupUncheckedUpdateWithoutBrandInput>
  }

  export type optiongroupUpdateManyWithWhereWithoutBrandInput = {
    where: optiongroupScalarWhereInput
    data: XOR<optiongroupUpdateManyMutationInput, optiongroupUncheckedUpdateManyWithoutBrandInput>
  }

  export type optiongroupScalarWhereInput = {
    AND?: optiongroupScalarWhereInput | optiongroupScalarWhereInput[]
    OR?: optiongroupScalarWhereInput[]
    NOT?: optiongroupScalarWhereInput | optiongroupScalarWhereInput[]
    id?: IntFilter<"optiongroup"> | number
    brand_id?: IntFilter<"optiongroup"> | number
    sub_brand_id?: IntNullableFilter<"optiongroup"> | number | null
    category_id?: IntNullableFilter<"optiongroup"> | number | null
    name?: StringFilter<"optiongroup"> | string
    pos_uuid?: StringNullableFilter<"optiongroup"> | string | null
    deleted_at?: DateTimeNullableFilter<"optiongroup"> | Date | string | null
  }

  export type itemUpsertWithWhereUniqueWithoutBrandInput = {
    where: itemWhereUniqueInput
    update: XOR<itemUpdateWithoutBrandInput, itemUncheckedUpdateWithoutBrandInput>
    create: XOR<itemCreateWithoutBrandInput, itemUncheckedCreateWithoutBrandInput>
  }

  export type itemUpdateWithWhereUniqueWithoutBrandInput = {
    where: itemWhereUniqueInput
    data: XOR<itemUpdateWithoutBrandInput, itemUncheckedUpdateWithoutBrandInput>
  }

  export type itemUpdateManyWithWhereWithoutBrandInput = {
    where: itemScalarWhereInput
    data: XOR<itemUpdateManyMutationInput, itemUncheckedUpdateManyWithoutBrandInput>
  }

  export type itemScalarWhereInput = {
    AND?: itemScalarWhereInput | itemScalarWhereInput[]
    OR?: itemScalarWhereInput[]
    NOT?: itemScalarWhereInput | itemScalarWhereInput[]
    id?: IntFilter<"item"> | number
    brand_id?: IntFilter<"item"> | number
    sub_brand_id?: IntNullableFilter<"item"> | number | null
    category_id?: IntNullableFilter<"item"> | number | null
    name?: StringFilter<"item"> | string
    pos_uuid?: StringNullableFilter<"item"> | string | null
    deleted_at?: DateTimeNullableFilter<"item"> | Date | string | null
  }

  export type paymenttypeUpsertWithWhereUniqueWithoutBrandInput = {
    where: paymenttypeWhereUniqueInput
    update: XOR<paymenttypeUpdateWithoutBrandInput, paymenttypeUncheckedUpdateWithoutBrandInput>
    create: XOR<paymenttypeCreateWithoutBrandInput, paymenttypeUncheckedCreateWithoutBrandInput>
  }

  export type paymenttypeUpdateWithWhereUniqueWithoutBrandInput = {
    where: paymenttypeWhereUniqueInput
    data: XOR<paymenttypeUpdateWithoutBrandInput, paymenttypeUncheckedUpdateWithoutBrandInput>
  }

  export type paymenttypeUpdateManyWithWhereWithoutBrandInput = {
    where: paymenttypeScalarWhereInput
    data: XOR<paymenttypeUpdateManyMutationInput, paymenttypeUncheckedUpdateManyWithoutBrandInput>
  }

  export type paymenttypeScalarWhereInput = {
    AND?: paymenttypeScalarWhereInput | paymenttypeScalarWhereInput[]
    OR?: paymenttypeScalarWhereInput[]
    NOT?: paymenttypeScalarWhereInput | paymenttypeScalarWhereInput[]
    id?: IntFilter<"paymenttype"> | number
    brand_id?: IntNullableFilter<"paymenttype"> | number | null
    description?: StringFilter<"paymenttype"> | string
  }

  export type couponUpsertWithWhereUniqueWithoutBrandInput = {
    where: couponWhereUniqueInput
    update: XOR<couponUpdateWithoutBrandInput, couponUncheckedUpdateWithoutBrandInput>
    create: XOR<couponCreateWithoutBrandInput, couponUncheckedCreateWithoutBrandInput>
  }

  export type couponUpdateWithWhereUniqueWithoutBrandInput = {
    where: couponWhereUniqueInput
    data: XOR<couponUpdateWithoutBrandInput, couponUncheckedUpdateWithoutBrandInput>
  }

  export type couponUpdateManyWithWhereWithoutBrandInput = {
    where: couponScalarWhereInput
    data: XOR<couponUpdateManyMutationInput, couponUncheckedUpdateManyWithoutBrandInput>
  }

  export type couponScalarWhereInput = {
    AND?: couponScalarWhereInput | couponScalarWhereInput[]
    OR?: couponScalarWhereInput[]
    NOT?: couponScalarWhereInput | couponScalarWhereInput[]
    id?: IntFilter<"coupon"> | number
    brand_id?: IntNullableFilter<"coupon"> | number | null
    code?: StringFilter<"coupon"> | string
    discount_type?: StringNullableFilter<"coupon"> | string | null
    discount_value?: DecimalNullableFilter<"coupon"> | Decimal | DecimalJsLike | number | string | null
    is_active?: BoolNullableFilter<"coupon"> | boolean | null
    valid_from?: DateTimeNullableFilter<"coupon"> | Date | string | null
    valid_until?: DateTimeNullableFilter<"coupon"> | Date | string | null
  }

  export type brandCreateWithoutSubbrandsInput = {
    name: string
    created_at?: Date | string | null
    stores?: storeCreateNestedManyWithoutBrandInput
    channels?: channelCreateNestedManyWithoutBrandInput
    categories?: categoryCreateNestedManyWithoutBrandInput
    products?: productCreateNestedManyWithoutBrandInput
    optiongroups?: optiongroupCreateNestedManyWithoutBrandInput
    items?: itemCreateNestedManyWithoutBrandInput
    paymenttypes?: paymenttypeCreateNestedManyWithoutBrandInput
    coupons?: couponCreateNestedManyWithoutBrandInput
  }

  export type brandUncheckedCreateWithoutSubbrandsInput = {
    id?: number
    name: string
    created_at?: Date | string | null
    stores?: storeUncheckedCreateNestedManyWithoutBrandInput
    channels?: channelUncheckedCreateNestedManyWithoutBrandInput
    categories?: categoryUncheckedCreateNestedManyWithoutBrandInput
    products?: productUncheckedCreateNestedManyWithoutBrandInput
    optiongroups?: optiongroupUncheckedCreateNestedManyWithoutBrandInput
    items?: itemUncheckedCreateNestedManyWithoutBrandInput
    paymenttypes?: paymenttypeUncheckedCreateNestedManyWithoutBrandInput
    coupons?: couponUncheckedCreateNestedManyWithoutBrandInput
  }

  export type brandCreateOrConnectWithoutSubbrandsInput = {
    where: brandWhereUniqueInput
    create: XOR<brandCreateWithoutSubbrandsInput, brandUncheckedCreateWithoutSubbrandsInput>
  }

  export type storeCreateWithoutSubbrandInput = {
    name: string
    city?: string | null
    state?: string | null
    district?: string | null
    address_street?: string | null
    address_number?: number | null
    zipcode?: string | null
    latitude?: Decimal | DecimalJsLike | number | string | null
    longitude?: Decimal | DecimalJsLike | number | string | null
    is_active?: boolean | null
    is_own?: boolean | null
    is_holding?: boolean | null
    creation_date?: Date | string | null
    created_at?: Date | string | null
    brand: brandCreateNestedOneWithoutStoresInput
    customers?: customerCreateNestedManyWithoutStoreInput
    sales?: saleCreateNestedManyWithoutStoreInput
  }

  export type storeUncheckedCreateWithoutSubbrandInput = {
    id?: number
    brand_id: number
    name: string
    city?: string | null
    state?: string | null
    district?: string | null
    address_street?: string | null
    address_number?: number | null
    zipcode?: string | null
    latitude?: Decimal | DecimalJsLike | number | string | null
    longitude?: Decimal | DecimalJsLike | number | string | null
    is_active?: boolean | null
    is_own?: boolean | null
    is_holding?: boolean | null
    creation_date?: Date | string | null
    created_at?: Date | string | null
    customers?: customerUncheckedCreateNestedManyWithoutStoreInput
    sales?: saleUncheckedCreateNestedManyWithoutStoreInput
  }

  export type storeCreateOrConnectWithoutSubbrandInput = {
    where: storeWhereUniqueInput
    create: XOR<storeCreateWithoutSubbrandInput, storeUncheckedCreateWithoutSubbrandInput>
  }

  export type storeCreateManySubbrandInputEnvelope = {
    data: storeCreateManySubbrandInput | storeCreateManySubbrandInput[]
    skipDuplicates?: boolean
  }

  export type categoryCreateWithoutSubbrandInput = {
    name: string
    type?: string | null
    pos_uuid?: string | null
    deleted_at?: Date | string | null
    brand: brandCreateNestedOneWithoutCategoriesInput
    products?: productCreateNestedManyWithoutCategoryInput
    optiongroups?: optiongroupCreateNestedManyWithoutCategoryInput
    items?: itemCreateNestedManyWithoutCategoryInput
  }

  export type categoryUncheckedCreateWithoutSubbrandInput = {
    id?: number
    brand_id: number
    name: string
    type?: string | null
    pos_uuid?: string | null
    deleted_at?: Date | string | null
    products?: productUncheckedCreateNestedManyWithoutCategoryInput
    optiongroups?: optiongroupUncheckedCreateNestedManyWithoutCategoryInput
    items?: itemUncheckedCreateNestedManyWithoutCategoryInput
  }

  export type categoryCreateOrConnectWithoutSubbrandInput = {
    where: categoryWhereUniqueInput
    create: XOR<categoryCreateWithoutSubbrandInput, categoryUncheckedCreateWithoutSubbrandInput>
  }

  export type categoryCreateManySubbrandInputEnvelope = {
    data: categoryCreateManySubbrandInput | categoryCreateManySubbrandInput[]
    skipDuplicates?: boolean
  }

  export type productCreateWithoutSubbrandInput = {
    name: string
    pos_uuid?: string | null
    deleted_at?: Date | string | null
    brand: brandCreateNestedOneWithoutProductsInput
    category?: categoryCreateNestedOneWithoutProductsInput
    productsales?: productsaleCreateNestedManyWithoutProductInput
  }

  export type productUncheckedCreateWithoutSubbrandInput = {
    id?: number
    brand_id: number
    category_id?: number | null
    name: string
    pos_uuid?: string | null
    deleted_at?: Date | string | null
    productsales?: productsaleUncheckedCreateNestedManyWithoutProductInput
  }

  export type productCreateOrConnectWithoutSubbrandInput = {
    where: productWhereUniqueInput
    create: XOR<productCreateWithoutSubbrandInput, productUncheckedCreateWithoutSubbrandInput>
  }

  export type productCreateManySubbrandInputEnvelope = {
    data: productCreateManySubbrandInput | productCreateManySubbrandInput[]
    skipDuplicates?: boolean
  }

  export type optiongroupCreateWithoutSubbrandInput = {
    name: string
    pos_uuid?: string | null
    deleted_at?: Date | string | null
    brand: brandCreateNestedOneWithoutOptiongroupsInput
    category?: categoryCreateNestedOneWithoutOptiongroupsInput
    itemproductsales?: itemproductsaleCreateNestedManyWithoutOptiongroupInput
    itemitemproductsales?: itemitemproductsaleCreateNestedManyWithoutOptiongroupInput
  }

  export type optiongroupUncheckedCreateWithoutSubbrandInput = {
    id?: number
    brand_id: number
    category_id?: number | null
    name: string
    pos_uuid?: string | null
    deleted_at?: Date | string | null
    itemproductsales?: itemproductsaleUncheckedCreateNestedManyWithoutOptiongroupInput
    itemitemproductsales?: itemitemproductsaleUncheckedCreateNestedManyWithoutOptiongroupInput
  }

  export type optiongroupCreateOrConnectWithoutSubbrandInput = {
    where: optiongroupWhereUniqueInput
    create: XOR<optiongroupCreateWithoutSubbrandInput, optiongroupUncheckedCreateWithoutSubbrandInput>
  }

  export type optiongroupCreateManySubbrandInputEnvelope = {
    data: optiongroupCreateManySubbrandInput | optiongroupCreateManySubbrandInput[]
    skipDuplicates?: boolean
  }

  export type itemCreateWithoutSubbrandInput = {
    name: string
    pos_uuid?: string | null
    deleted_at?: Date | string | null
    brand: brandCreateNestedOneWithoutItemsInput
    category?: categoryCreateNestedOneWithoutItemsInput
    itemproductsales?: itemproductsaleCreateNestedManyWithoutItemInput
    itemitemproductsales?: itemitemproductsaleCreateNestedManyWithoutItemInput
  }

  export type itemUncheckedCreateWithoutSubbrandInput = {
    id?: number
    brand_id: number
    category_id?: number | null
    name: string
    pos_uuid?: string | null
    deleted_at?: Date | string | null
    itemproductsales?: itemproductsaleUncheckedCreateNestedManyWithoutItemInput
    itemitemproductsales?: itemitemproductsaleUncheckedCreateNestedManyWithoutItemInput
  }

  export type itemCreateOrConnectWithoutSubbrandInput = {
    where: itemWhereUniqueInput
    create: XOR<itemCreateWithoutSubbrandInput, itemUncheckedCreateWithoutSubbrandInput>
  }

  export type itemCreateManySubbrandInputEnvelope = {
    data: itemCreateManySubbrandInput | itemCreateManySubbrandInput[]
    skipDuplicates?: boolean
  }

  export type customerCreateWithoutSubbrandInput = {
    customer_name?: string | null
    email?: string | null
    phone_number?: string | null
    cpf?: string | null
    birth_date?: Date | string | null
    gender?: string | null
    registration_origin?: string | null
    agree_terms?: boolean | null
    receive_promotions_email?: boolean | null
    receive_promotions_sms?: boolean | null
    created_at?: Date | string | null
    store?: storeCreateNestedOneWithoutCustomersInput
    sales?: saleCreateNestedManyWithoutCustomerInput
  }

  export type customerUncheckedCreateWithoutSubbrandInput = {
    id?: number
    customer_name?: string | null
    email?: string | null
    phone_number?: string | null
    cpf?: string | null
    birth_date?: Date | string | null
    gender?: string | null
    store_id?: number | null
    registration_origin?: string | null
    agree_terms?: boolean | null
    receive_promotions_email?: boolean | null
    receive_promotions_sms?: boolean | null
    created_at?: Date | string | null
    sales?: saleUncheckedCreateNestedManyWithoutCustomerInput
  }

  export type customerCreateOrConnectWithoutSubbrandInput = {
    where: customerWhereUniqueInput
    create: XOR<customerCreateWithoutSubbrandInput, customerUncheckedCreateWithoutSubbrandInput>
  }

  export type customerCreateManySubbrandInputEnvelope = {
    data: customerCreateManySubbrandInput | customerCreateManySubbrandInput[]
    skipDuplicates?: boolean
  }

  export type saleCreateWithoutSubbrandInput = {
    cod_sale1?: string | null
    cod_sale2?: string | null
    created_at: Date | string
    customer_name?: string | null
    sale_status_desc: string
    total_amount_items: Decimal | DecimalJsLike | number | string
    total_discount?: Decimal | DecimalJsLike | number | string | null
    total_increase?: Decimal | DecimalJsLike | number | string | null
    delivery_fee?: Decimal | DecimalJsLike | number | string | null
    service_tax_fee?: Decimal | DecimalJsLike | number | string | null
    total_amount: Decimal | DecimalJsLike | number | string
    value_paid?: Decimal | DecimalJsLike | number | string | null
    production_seconds?: number | null
    delivery_seconds?: number | null
    people_quantity?: number | null
    discount_reason?: string | null
    increase_reason?: string | null
    origin?: string | null
    store: storeCreateNestedOneWithoutSalesInput
    customer?: customerCreateNestedOneWithoutSalesInput
    channel: channelCreateNestedOneWithoutSalesInput
    productsales?: productsaleCreateNestedManyWithoutSaleInput
    deliverysales?: deliverysaleCreateNestedManyWithoutSaleInput
    deliveryaddress?: deliveryaddressCreateNestedManyWithoutSaleInput
    payments?: paymentCreateNestedManyWithoutSaleInput
    couponsales?: couponsaleCreateNestedManyWithoutSaleInput
  }

  export type saleUncheckedCreateWithoutSubbrandInput = {
    id?: number
    store_id: number
    customer_id?: number | null
    channel_id: number
    cod_sale1?: string | null
    cod_sale2?: string | null
    created_at: Date | string
    customer_name?: string | null
    sale_status_desc: string
    total_amount_items: Decimal | DecimalJsLike | number | string
    total_discount?: Decimal | DecimalJsLike | number | string | null
    total_increase?: Decimal | DecimalJsLike | number | string | null
    delivery_fee?: Decimal | DecimalJsLike | number | string | null
    service_tax_fee?: Decimal | DecimalJsLike | number | string | null
    total_amount: Decimal | DecimalJsLike | number | string
    value_paid?: Decimal | DecimalJsLike | number | string | null
    production_seconds?: number | null
    delivery_seconds?: number | null
    people_quantity?: number | null
    discount_reason?: string | null
    increase_reason?: string | null
    origin?: string | null
    productsales?: productsaleUncheckedCreateNestedManyWithoutSaleInput
    deliverysales?: deliverysaleUncheckedCreateNestedManyWithoutSaleInput
    deliveryaddress?: deliveryaddressUncheckedCreateNestedManyWithoutSaleInput
    payments?: paymentUncheckedCreateNestedManyWithoutSaleInput
    couponsales?: couponsaleUncheckedCreateNestedManyWithoutSaleInput
  }

  export type saleCreateOrConnectWithoutSubbrandInput = {
    where: saleWhereUniqueInput
    create: XOR<saleCreateWithoutSubbrandInput, saleUncheckedCreateWithoutSubbrandInput>
  }

  export type saleCreateManySubbrandInputEnvelope = {
    data: saleCreateManySubbrandInput | saleCreateManySubbrandInput[]
    skipDuplicates?: boolean
  }

  export type brandUpsertWithoutSubbrandsInput = {
    update: XOR<brandUpdateWithoutSubbrandsInput, brandUncheckedUpdateWithoutSubbrandsInput>
    create: XOR<brandCreateWithoutSubbrandsInput, brandUncheckedCreateWithoutSubbrandsInput>
    where?: brandWhereInput
  }

  export type brandUpdateToOneWithWhereWithoutSubbrandsInput = {
    where?: brandWhereInput
    data: XOR<brandUpdateWithoutSubbrandsInput, brandUncheckedUpdateWithoutSubbrandsInput>
  }

  export type brandUpdateWithoutSubbrandsInput = {
    name?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stores?: storeUpdateManyWithoutBrandNestedInput
    channels?: channelUpdateManyWithoutBrandNestedInput
    categories?: categoryUpdateManyWithoutBrandNestedInput
    products?: productUpdateManyWithoutBrandNestedInput
    optiongroups?: optiongroupUpdateManyWithoutBrandNestedInput
    items?: itemUpdateManyWithoutBrandNestedInput
    paymenttypes?: paymenttypeUpdateManyWithoutBrandNestedInput
    coupons?: couponUpdateManyWithoutBrandNestedInput
  }

  export type brandUncheckedUpdateWithoutSubbrandsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stores?: storeUncheckedUpdateManyWithoutBrandNestedInput
    channels?: channelUncheckedUpdateManyWithoutBrandNestedInput
    categories?: categoryUncheckedUpdateManyWithoutBrandNestedInput
    products?: productUncheckedUpdateManyWithoutBrandNestedInput
    optiongroups?: optiongroupUncheckedUpdateManyWithoutBrandNestedInput
    items?: itemUncheckedUpdateManyWithoutBrandNestedInput
    paymenttypes?: paymenttypeUncheckedUpdateManyWithoutBrandNestedInput
    coupons?: couponUncheckedUpdateManyWithoutBrandNestedInput
  }

  export type storeUpsertWithWhereUniqueWithoutSubbrandInput = {
    where: storeWhereUniqueInput
    update: XOR<storeUpdateWithoutSubbrandInput, storeUncheckedUpdateWithoutSubbrandInput>
    create: XOR<storeCreateWithoutSubbrandInput, storeUncheckedCreateWithoutSubbrandInput>
  }

  export type storeUpdateWithWhereUniqueWithoutSubbrandInput = {
    where: storeWhereUniqueInput
    data: XOR<storeUpdateWithoutSubbrandInput, storeUncheckedUpdateWithoutSubbrandInput>
  }

  export type storeUpdateManyWithWhereWithoutSubbrandInput = {
    where: storeScalarWhereInput
    data: XOR<storeUpdateManyMutationInput, storeUncheckedUpdateManyWithoutSubbrandInput>
  }

  export type categoryUpsertWithWhereUniqueWithoutSubbrandInput = {
    where: categoryWhereUniqueInput
    update: XOR<categoryUpdateWithoutSubbrandInput, categoryUncheckedUpdateWithoutSubbrandInput>
    create: XOR<categoryCreateWithoutSubbrandInput, categoryUncheckedCreateWithoutSubbrandInput>
  }

  export type categoryUpdateWithWhereUniqueWithoutSubbrandInput = {
    where: categoryWhereUniqueInput
    data: XOR<categoryUpdateWithoutSubbrandInput, categoryUncheckedUpdateWithoutSubbrandInput>
  }

  export type categoryUpdateManyWithWhereWithoutSubbrandInput = {
    where: categoryScalarWhereInput
    data: XOR<categoryUpdateManyMutationInput, categoryUncheckedUpdateManyWithoutSubbrandInput>
  }

  export type productUpsertWithWhereUniqueWithoutSubbrandInput = {
    where: productWhereUniqueInput
    update: XOR<productUpdateWithoutSubbrandInput, productUncheckedUpdateWithoutSubbrandInput>
    create: XOR<productCreateWithoutSubbrandInput, productUncheckedCreateWithoutSubbrandInput>
  }

  export type productUpdateWithWhereUniqueWithoutSubbrandInput = {
    where: productWhereUniqueInput
    data: XOR<productUpdateWithoutSubbrandInput, productUncheckedUpdateWithoutSubbrandInput>
  }

  export type productUpdateManyWithWhereWithoutSubbrandInput = {
    where: productScalarWhereInput
    data: XOR<productUpdateManyMutationInput, productUncheckedUpdateManyWithoutSubbrandInput>
  }

  export type optiongroupUpsertWithWhereUniqueWithoutSubbrandInput = {
    where: optiongroupWhereUniqueInput
    update: XOR<optiongroupUpdateWithoutSubbrandInput, optiongroupUncheckedUpdateWithoutSubbrandInput>
    create: XOR<optiongroupCreateWithoutSubbrandInput, optiongroupUncheckedCreateWithoutSubbrandInput>
  }

  export type optiongroupUpdateWithWhereUniqueWithoutSubbrandInput = {
    where: optiongroupWhereUniqueInput
    data: XOR<optiongroupUpdateWithoutSubbrandInput, optiongroupUncheckedUpdateWithoutSubbrandInput>
  }

  export type optiongroupUpdateManyWithWhereWithoutSubbrandInput = {
    where: optiongroupScalarWhereInput
    data: XOR<optiongroupUpdateManyMutationInput, optiongroupUncheckedUpdateManyWithoutSubbrandInput>
  }

  export type itemUpsertWithWhereUniqueWithoutSubbrandInput = {
    where: itemWhereUniqueInput
    update: XOR<itemUpdateWithoutSubbrandInput, itemUncheckedUpdateWithoutSubbrandInput>
    create: XOR<itemCreateWithoutSubbrandInput, itemUncheckedCreateWithoutSubbrandInput>
  }

  export type itemUpdateWithWhereUniqueWithoutSubbrandInput = {
    where: itemWhereUniqueInput
    data: XOR<itemUpdateWithoutSubbrandInput, itemUncheckedUpdateWithoutSubbrandInput>
  }

  export type itemUpdateManyWithWhereWithoutSubbrandInput = {
    where: itemScalarWhereInput
    data: XOR<itemUpdateManyMutationInput, itemUncheckedUpdateManyWithoutSubbrandInput>
  }

  export type customerUpsertWithWhereUniqueWithoutSubbrandInput = {
    where: customerWhereUniqueInput
    update: XOR<customerUpdateWithoutSubbrandInput, customerUncheckedUpdateWithoutSubbrandInput>
    create: XOR<customerCreateWithoutSubbrandInput, customerUncheckedCreateWithoutSubbrandInput>
  }

  export type customerUpdateWithWhereUniqueWithoutSubbrandInput = {
    where: customerWhereUniqueInput
    data: XOR<customerUpdateWithoutSubbrandInput, customerUncheckedUpdateWithoutSubbrandInput>
  }

  export type customerUpdateManyWithWhereWithoutSubbrandInput = {
    where: customerScalarWhereInput
    data: XOR<customerUpdateManyMutationInput, customerUncheckedUpdateManyWithoutSubbrandInput>
  }

  export type customerScalarWhereInput = {
    AND?: customerScalarWhereInput | customerScalarWhereInput[]
    OR?: customerScalarWhereInput[]
    NOT?: customerScalarWhereInput | customerScalarWhereInput[]
    id?: IntFilter<"customer"> | number
    customer_name?: StringNullableFilter<"customer"> | string | null
    email?: StringNullableFilter<"customer"> | string | null
    phone_number?: StringNullableFilter<"customer"> | string | null
    cpf?: StringNullableFilter<"customer"> | string | null
    birth_date?: DateTimeNullableFilter<"customer"> | Date | string | null
    gender?: StringNullableFilter<"customer"> | string | null
    store_id?: IntNullableFilter<"customer"> | number | null
    sub_brand_id?: IntNullableFilter<"customer"> | number | null
    registration_origin?: StringNullableFilter<"customer"> | string | null
    agree_terms?: BoolNullableFilter<"customer"> | boolean | null
    receive_promotions_email?: BoolNullableFilter<"customer"> | boolean | null
    receive_promotions_sms?: BoolNullableFilter<"customer"> | boolean | null
    created_at?: DateTimeNullableFilter<"customer"> | Date | string | null
  }

  export type saleUpsertWithWhereUniqueWithoutSubbrandInput = {
    where: saleWhereUniqueInput
    update: XOR<saleUpdateWithoutSubbrandInput, saleUncheckedUpdateWithoutSubbrandInput>
    create: XOR<saleCreateWithoutSubbrandInput, saleUncheckedCreateWithoutSubbrandInput>
  }

  export type saleUpdateWithWhereUniqueWithoutSubbrandInput = {
    where: saleWhereUniqueInput
    data: XOR<saleUpdateWithoutSubbrandInput, saleUncheckedUpdateWithoutSubbrandInput>
  }

  export type saleUpdateManyWithWhereWithoutSubbrandInput = {
    where: saleScalarWhereInput
    data: XOR<saleUpdateManyMutationInput, saleUncheckedUpdateManyWithoutSubbrandInput>
  }

  export type saleScalarWhereInput = {
    AND?: saleScalarWhereInput | saleScalarWhereInput[]
    OR?: saleScalarWhereInput[]
    NOT?: saleScalarWhereInput | saleScalarWhereInput[]
    id?: IntFilter<"sale"> | number
    store_id?: IntFilter<"sale"> | number
    sub_brand_id?: IntNullableFilter<"sale"> | number | null
    customer_id?: IntNullableFilter<"sale"> | number | null
    channel_id?: IntFilter<"sale"> | number
    cod_sale1?: StringNullableFilter<"sale"> | string | null
    cod_sale2?: StringNullableFilter<"sale"> | string | null
    created_at?: DateTimeFilter<"sale"> | Date | string
    customer_name?: StringNullableFilter<"sale"> | string | null
    sale_status_desc?: StringFilter<"sale"> | string
    total_amount_items?: DecimalFilter<"sale"> | Decimal | DecimalJsLike | number | string
    total_discount?: DecimalNullableFilter<"sale"> | Decimal | DecimalJsLike | number | string | null
    total_increase?: DecimalNullableFilter<"sale"> | Decimal | DecimalJsLike | number | string | null
    delivery_fee?: DecimalNullableFilter<"sale"> | Decimal | DecimalJsLike | number | string | null
    service_tax_fee?: DecimalNullableFilter<"sale"> | Decimal | DecimalJsLike | number | string | null
    total_amount?: DecimalFilter<"sale"> | Decimal | DecimalJsLike | number | string
    value_paid?: DecimalNullableFilter<"sale"> | Decimal | DecimalJsLike | number | string | null
    production_seconds?: IntNullableFilter<"sale"> | number | null
    delivery_seconds?: IntNullableFilter<"sale"> | number | null
    people_quantity?: IntNullableFilter<"sale"> | number | null
    discount_reason?: StringNullableFilter<"sale"> | string | null
    increase_reason?: StringNullableFilter<"sale"> | string | null
    origin?: StringNullableFilter<"sale"> | string | null
  }

  export type brandCreateWithoutStoresInput = {
    name: string
    created_at?: Date | string | null
    subbrands?: subbrandCreateNestedManyWithoutBrandInput
    channels?: channelCreateNestedManyWithoutBrandInput
    categories?: categoryCreateNestedManyWithoutBrandInput
    products?: productCreateNestedManyWithoutBrandInput
    optiongroups?: optiongroupCreateNestedManyWithoutBrandInput
    items?: itemCreateNestedManyWithoutBrandInput
    paymenttypes?: paymenttypeCreateNestedManyWithoutBrandInput
    coupons?: couponCreateNestedManyWithoutBrandInput
  }

  export type brandUncheckedCreateWithoutStoresInput = {
    id?: number
    name: string
    created_at?: Date | string | null
    subbrands?: subbrandUncheckedCreateNestedManyWithoutBrandInput
    channels?: channelUncheckedCreateNestedManyWithoutBrandInput
    categories?: categoryUncheckedCreateNestedManyWithoutBrandInput
    products?: productUncheckedCreateNestedManyWithoutBrandInput
    optiongroups?: optiongroupUncheckedCreateNestedManyWithoutBrandInput
    items?: itemUncheckedCreateNestedManyWithoutBrandInput
    paymenttypes?: paymenttypeUncheckedCreateNestedManyWithoutBrandInput
    coupons?: couponUncheckedCreateNestedManyWithoutBrandInput
  }

  export type brandCreateOrConnectWithoutStoresInput = {
    where: brandWhereUniqueInput
    create: XOR<brandCreateWithoutStoresInput, brandUncheckedCreateWithoutStoresInput>
  }

  export type subbrandCreateWithoutStoresInput = {
    name: string
    created_at?: Date | string | null
    brand: brandCreateNestedOneWithoutSubbrandsInput
    categories?: categoryCreateNestedManyWithoutSubbrandInput
    products?: productCreateNestedManyWithoutSubbrandInput
    optiongroups?: optiongroupCreateNestedManyWithoutSubbrandInput
    items?: itemCreateNestedManyWithoutSubbrandInput
    customers?: customerCreateNestedManyWithoutSubbrandInput
    sales?: saleCreateNestedManyWithoutSubbrandInput
  }

  export type subbrandUncheckedCreateWithoutStoresInput = {
    id?: number
    brand_id: number
    name: string
    created_at?: Date | string | null
    categories?: categoryUncheckedCreateNestedManyWithoutSubbrandInput
    products?: productUncheckedCreateNestedManyWithoutSubbrandInput
    optiongroups?: optiongroupUncheckedCreateNestedManyWithoutSubbrandInput
    items?: itemUncheckedCreateNestedManyWithoutSubbrandInput
    customers?: customerUncheckedCreateNestedManyWithoutSubbrandInput
    sales?: saleUncheckedCreateNestedManyWithoutSubbrandInput
  }

  export type subbrandCreateOrConnectWithoutStoresInput = {
    where: subbrandWhereUniqueInput
    create: XOR<subbrandCreateWithoutStoresInput, subbrandUncheckedCreateWithoutStoresInput>
  }

  export type customerCreateWithoutStoreInput = {
    customer_name?: string | null
    email?: string | null
    phone_number?: string | null
    cpf?: string | null
    birth_date?: Date | string | null
    gender?: string | null
    registration_origin?: string | null
    agree_terms?: boolean | null
    receive_promotions_email?: boolean | null
    receive_promotions_sms?: boolean | null
    created_at?: Date | string | null
    subbrand?: subbrandCreateNestedOneWithoutCustomersInput
    sales?: saleCreateNestedManyWithoutCustomerInput
  }

  export type customerUncheckedCreateWithoutStoreInput = {
    id?: number
    customer_name?: string | null
    email?: string | null
    phone_number?: string | null
    cpf?: string | null
    birth_date?: Date | string | null
    gender?: string | null
    sub_brand_id?: number | null
    registration_origin?: string | null
    agree_terms?: boolean | null
    receive_promotions_email?: boolean | null
    receive_promotions_sms?: boolean | null
    created_at?: Date | string | null
    sales?: saleUncheckedCreateNestedManyWithoutCustomerInput
  }

  export type customerCreateOrConnectWithoutStoreInput = {
    where: customerWhereUniqueInput
    create: XOR<customerCreateWithoutStoreInput, customerUncheckedCreateWithoutStoreInput>
  }

  export type customerCreateManyStoreInputEnvelope = {
    data: customerCreateManyStoreInput | customerCreateManyStoreInput[]
    skipDuplicates?: boolean
  }

  export type saleCreateWithoutStoreInput = {
    cod_sale1?: string | null
    cod_sale2?: string | null
    created_at: Date | string
    customer_name?: string | null
    sale_status_desc: string
    total_amount_items: Decimal | DecimalJsLike | number | string
    total_discount?: Decimal | DecimalJsLike | number | string | null
    total_increase?: Decimal | DecimalJsLike | number | string | null
    delivery_fee?: Decimal | DecimalJsLike | number | string | null
    service_tax_fee?: Decimal | DecimalJsLike | number | string | null
    total_amount: Decimal | DecimalJsLike | number | string
    value_paid?: Decimal | DecimalJsLike | number | string | null
    production_seconds?: number | null
    delivery_seconds?: number | null
    people_quantity?: number | null
    discount_reason?: string | null
    increase_reason?: string | null
    origin?: string | null
    subbrand?: subbrandCreateNestedOneWithoutSalesInput
    customer?: customerCreateNestedOneWithoutSalesInput
    channel: channelCreateNestedOneWithoutSalesInput
    productsales?: productsaleCreateNestedManyWithoutSaleInput
    deliverysales?: deliverysaleCreateNestedManyWithoutSaleInput
    deliveryaddress?: deliveryaddressCreateNestedManyWithoutSaleInput
    payments?: paymentCreateNestedManyWithoutSaleInput
    couponsales?: couponsaleCreateNestedManyWithoutSaleInput
  }

  export type saleUncheckedCreateWithoutStoreInput = {
    id?: number
    sub_brand_id?: number | null
    customer_id?: number | null
    channel_id: number
    cod_sale1?: string | null
    cod_sale2?: string | null
    created_at: Date | string
    customer_name?: string | null
    sale_status_desc: string
    total_amount_items: Decimal | DecimalJsLike | number | string
    total_discount?: Decimal | DecimalJsLike | number | string | null
    total_increase?: Decimal | DecimalJsLike | number | string | null
    delivery_fee?: Decimal | DecimalJsLike | number | string | null
    service_tax_fee?: Decimal | DecimalJsLike | number | string | null
    total_amount: Decimal | DecimalJsLike | number | string
    value_paid?: Decimal | DecimalJsLike | number | string | null
    production_seconds?: number | null
    delivery_seconds?: number | null
    people_quantity?: number | null
    discount_reason?: string | null
    increase_reason?: string | null
    origin?: string | null
    productsales?: productsaleUncheckedCreateNestedManyWithoutSaleInput
    deliverysales?: deliverysaleUncheckedCreateNestedManyWithoutSaleInput
    deliveryaddress?: deliveryaddressUncheckedCreateNestedManyWithoutSaleInput
    payments?: paymentUncheckedCreateNestedManyWithoutSaleInput
    couponsales?: couponsaleUncheckedCreateNestedManyWithoutSaleInput
  }

  export type saleCreateOrConnectWithoutStoreInput = {
    where: saleWhereUniqueInput
    create: XOR<saleCreateWithoutStoreInput, saleUncheckedCreateWithoutStoreInput>
  }

  export type saleCreateManyStoreInputEnvelope = {
    data: saleCreateManyStoreInput | saleCreateManyStoreInput[]
    skipDuplicates?: boolean
  }

  export type brandUpsertWithoutStoresInput = {
    update: XOR<brandUpdateWithoutStoresInput, brandUncheckedUpdateWithoutStoresInput>
    create: XOR<brandCreateWithoutStoresInput, brandUncheckedCreateWithoutStoresInput>
    where?: brandWhereInput
  }

  export type brandUpdateToOneWithWhereWithoutStoresInput = {
    where?: brandWhereInput
    data: XOR<brandUpdateWithoutStoresInput, brandUncheckedUpdateWithoutStoresInput>
  }

  export type brandUpdateWithoutStoresInput = {
    name?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subbrands?: subbrandUpdateManyWithoutBrandNestedInput
    channels?: channelUpdateManyWithoutBrandNestedInput
    categories?: categoryUpdateManyWithoutBrandNestedInput
    products?: productUpdateManyWithoutBrandNestedInput
    optiongroups?: optiongroupUpdateManyWithoutBrandNestedInput
    items?: itemUpdateManyWithoutBrandNestedInput
    paymenttypes?: paymenttypeUpdateManyWithoutBrandNestedInput
    coupons?: couponUpdateManyWithoutBrandNestedInput
  }

  export type brandUncheckedUpdateWithoutStoresInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subbrands?: subbrandUncheckedUpdateManyWithoutBrandNestedInput
    channels?: channelUncheckedUpdateManyWithoutBrandNestedInput
    categories?: categoryUncheckedUpdateManyWithoutBrandNestedInput
    products?: productUncheckedUpdateManyWithoutBrandNestedInput
    optiongroups?: optiongroupUncheckedUpdateManyWithoutBrandNestedInput
    items?: itemUncheckedUpdateManyWithoutBrandNestedInput
    paymenttypes?: paymenttypeUncheckedUpdateManyWithoutBrandNestedInput
    coupons?: couponUncheckedUpdateManyWithoutBrandNestedInput
  }

  export type subbrandUpsertWithoutStoresInput = {
    update: XOR<subbrandUpdateWithoutStoresInput, subbrandUncheckedUpdateWithoutStoresInput>
    create: XOR<subbrandCreateWithoutStoresInput, subbrandUncheckedCreateWithoutStoresInput>
    where?: subbrandWhereInput
  }

  export type subbrandUpdateToOneWithWhereWithoutStoresInput = {
    where?: subbrandWhereInput
    data: XOR<subbrandUpdateWithoutStoresInput, subbrandUncheckedUpdateWithoutStoresInput>
  }

  export type subbrandUpdateWithoutStoresInput = {
    name?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    brand?: brandUpdateOneRequiredWithoutSubbrandsNestedInput
    categories?: categoryUpdateManyWithoutSubbrandNestedInput
    products?: productUpdateManyWithoutSubbrandNestedInput
    optiongroups?: optiongroupUpdateManyWithoutSubbrandNestedInput
    items?: itemUpdateManyWithoutSubbrandNestedInput
    customers?: customerUpdateManyWithoutSubbrandNestedInput
    sales?: saleUpdateManyWithoutSubbrandNestedInput
  }

  export type subbrandUncheckedUpdateWithoutStoresInput = {
    id?: IntFieldUpdateOperationsInput | number
    brand_id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    categories?: categoryUncheckedUpdateManyWithoutSubbrandNestedInput
    products?: productUncheckedUpdateManyWithoutSubbrandNestedInput
    optiongroups?: optiongroupUncheckedUpdateManyWithoutSubbrandNestedInput
    items?: itemUncheckedUpdateManyWithoutSubbrandNestedInput
    customers?: customerUncheckedUpdateManyWithoutSubbrandNestedInput
    sales?: saleUncheckedUpdateManyWithoutSubbrandNestedInput
  }

  export type customerUpsertWithWhereUniqueWithoutStoreInput = {
    where: customerWhereUniqueInput
    update: XOR<customerUpdateWithoutStoreInput, customerUncheckedUpdateWithoutStoreInput>
    create: XOR<customerCreateWithoutStoreInput, customerUncheckedCreateWithoutStoreInput>
  }

  export type customerUpdateWithWhereUniqueWithoutStoreInput = {
    where: customerWhereUniqueInput
    data: XOR<customerUpdateWithoutStoreInput, customerUncheckedUpdateWithoutStoreInput>
  }

  export type customerUpdateManyWithWhereWithoutStoreInput = {
    where: customerScalarWhereInput
    data: XOR<customerUpdateManyMutationInput, customerUncheckedUpdateManyWithoutStoreInput>
  }

  export type saleUpsertWithWhereUniqueWithoutStoreInput = {
    where: saleWhereUniqueInput
    update: XOR<saleUpdateWithoutStoreInput, saleUncheckedUpdateWithoutStoreInput>
    create: XOR<saleCreateWithoutStoreInput, saleUncheckedCreateWithoutStoreInput>
  }

  export type saleUpdateWithWhereUniqueWithoutStoreInput = {
    where: saleWhereUniqueInput
    data: XOR<saleUpdateWithoutStoreInput, saleUncheckedUpdateWithoutStoreInput>
  }

  export type saleUpdateManyWithWhereWithoutStoreInput = {
    where: saleScalarWhereInput
    data: XOR<saleUpdateManyMutationInput, saleUncheckedUpdateManyWithoutStoreInput>
  }

  export type brandCreateWithoutChannelsInput = {
    name: string
    created_at?: Date | string | null
    subbrands?: subbrandCreateNestedManyWithoutBrandInput
    stores?: storeCreateNestedManyWithoutBrandInput
    categories?: categoryCreateNestedManyWithoutBrandInput
    products?: productCreateNestedManyWithoutBrandInput
    optiongroups?: optiongroupCreateNestedManyWithoutBrandInput
    items?: itemCreateNestedManyWithoutBrandInput
    paymenttypes?: paymenttypeCreateNestedManyWithoutBrandInput
    coupons?: couponCreateNestedManyWithoutBrandInput
  }

  export type brandUncheckedCreateWithoutChannelsInput = {
    id?: number
    name: string
    created_at?: Date | string | null
    subbrands?: subbrandUncheckedCreateNestedManyWithoutBrandInput
    stores?: storeUncheckedCreateNestedManyWithoutBrandInput
    categories?: categoryUncheckedCreateNestedManyWithoutBrandInput
    products?: productUncheckedCreateNestedManyWithoutBrandInput
    optiongroups?: optiongroupUncheckedCreateNestedManyWithoutBrandInput
    items?: itemUncheckedCreateNestedManyWithoutBrandInput
    paymenttypes?: paymenttypeUncheckedCreateNestedManyWithoutBrandInput
    coupons?: couponUncheckedCreateNestedManyWithoutBrandInput
  }

  export type brandCreateOrConnectWithoutChannelsInput = {
    where: brandWhereUniqueInput
    create: XOR<brandCreateWithoutChannelsInput, brandUncheckedCreateWithoutChannelsInput>
  }

  export type saleCreateWithoutChannelInput = {
    cod_sale1?: string | null
    cod_sale2?: string | null
    created_at: Date | string
    customer_name?: string | null
    sale_status_desc: string
    total_amount_items: Decimal | DecimalJsLike | number | string
    total_discount?: Decimal | DecimalJsLike | number | string | null
    total_increase?: Decimal | DecimalJsLike | number | string | null
    delivery_fee?: Decimal | DecimalJsLike | number | string | null
    service_tax_fee?: Decimal | DecimalJsLike | number | string | null
    total_amount: Decimal | DecimalJsLike | number | string
    value_paid?: Decimal | DecimalJsLike | number | string | null
    production_seconds?: number | null
    delivery_seconds?: number | null
    people_quantity?: number | null
    discount_reason?: string | null
    increase_reason?: string | null
    origin?: string | null
    store: storeCreateNestedOneWithoutSalesInput
    subbrand?: subbrandCreateNestedOneWithoutSalesInput
    customer?: customerCreateNestedOneWithoutSalesInput
    productsales?: productsaleCreateNestedManyWithoutSaleInput
    deliverysales?: deliverysaleCreateNestedManyWithoutSaleInput
    deliveryaddress?: deliveryaddressCreateNestedManyWithoutSaleInput
    payments?: paymentCreateNestedManyWithoutSaleInput
    couponsales?: couponsaleCreateNestedManyWithoutSaleInput
  }

  export type saleUncheckedCreateWithoutChannelInput = {
    id?: number
    store_id: number
    sub_brand_id?: number | null
    customer_id?: number | null
    cod_sale1?: string | null
    cod_sale2?: string | null
    created_at: Date | string
    customer_name?: string | null
    sale_status_desc: string
    total_amount_items: Decimal | DecimalJsLike | number | string
    total_discount?: Decimal | DecimalJsLike | number | string | null
    total_increase?: Decimal | DecimalJsLike | number | string | null
    delivery_fee?: Decimal | DecimalJsLike | number | string | null
    service_tax_fee?: Decimal | DecimalJsLike | number | string | null
    total_amount: Decimal | DecimalJsLike | number | string
    value_paid?: Decimal | DecimalJsLike | number | string | null
    production_seconds?: number | null
    delivery_seconds?: number | null
    people_quantity?: number | null
    discount_reason?: string | null
    increase_reason?: string | null
    origin?: string | null
    productsales?: productsaleUncheckedCreateNestedManyWithoutSaleInput
    deliverysales?: deliverysaleUncheckedCreateNestedManyWithoutSaleInput
    deliveryaddress?: deliveryaddressUncheckedCreateNestedManyWithoutSaleInput
    payments?: paymentUncheckedCreateNestedManyWithoutSaleInput
    couponsales?: couponsaleUncheckedCreateNestedManyWithoutSaleInput
  }

  export type saleCreateOrConnectWithoutChannelInput = {
    where: saleWhereUniqueInput
    create: XOR<saleCreateWithoutChannelInput, saleUncheckedCreateWithoutChannelInput>
  }

  export type saleCreateManyChannelInputEnvelope = {
    data: saleCreateManyChannelInput | saleCreateManyChannelInput[]
    skipDuplicates?: boolean
  }

  export type brandUpsertWithoutChannelsInput = {
    update: XOR<brandUpdateWithoutChannelsInput, brandUncheckedUpdateWithoutChannelsInput>
    create: XOR<brandCreateWithoutChannelsInput, brandUncheckedCreateWithoutChannelsInput>
    where?: brandWhereInput
  }

  export type brandUpdateToOneWithWhereWithoutChannelsInput = {
    where?: brandWhereInput
    data: XOR<brandUpdateWithoutChannelsInput, brandUncheckedUpdateWithoutChannelsInput>
  }

  export type brandUpdateWithoutChannelsInput = {
    name?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subbrands?: subbrandUpdateManyWithoutBrandNestedInput
    stores?: storeUpdateManyWithoutBrandNestedInput
    categories?: categoryUpdateManyWithoutBrandNestedInput
    products?: productUpdateManyWithoutBrandNestedInput
    optiongroups?: optiongroupUpdateManyWithoutBrandNestedInput
    items?: itemUpdateManyWithoutBrandNestedInput
    paymenttypes?: paymenttypeUpdateManyWithoutBrandNestedInput
    coupons?: couponUpdateManyWithoutBrandNestedInput
  }

  export type brandUncheckedUpdateWithoutChannelsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subbrands?: subbrandUncheckedUpdateManyWithoutBrandNestedInput
    stores?: storeUncheckedUpdateManyWithoutBrandNestedInput
    categories?: categoryUncheckedUpdateManyWithoutBrandNestedInput
    products?: productUncheckedUpdateManyWithoutBrandNestedInput
    optiongroups?: optiongroupUncheckedUpdateManyWithoutBrandNestedInput
    items?: itemUncheckedUpdateManyWithoutBrandNestedInput
    paymenttypes?: paymenttypeUncheckedUpdateManyWithoutBrandNestedInput
    coupons?: couponUncheckedUpdateManyWithoutBrandNestedInput
  }

  export type saleUpsertWithWhereUniqueWithoutChannelInput = {
    where: saleWhereUniqueInput
    update: XOR<saleUpdateWithoutChannelInput, saleUncheckedUpdateWithoutChannelInput>
    create: XOR<saleCreateWithoutChannelInput, saleUncheckedCreateWithoutChannelInput>
  }

  export type saleUpdateWithWhereUniqueWithoutChannelInput = {
    where: saleWhereUniqueInput
    data: XOR<saleUpdateWithoutChannelInput, saleUncheckedUpdateWithoutChannelInput>
  }

  export type saleUpdateManyWithWhereWithoutChannelInput = {
    where: saleScalarWhereInput
    data: XOR<saleUpdateManyMutationInput, saleUncheckedUpdateManyWithoutChannelInput>
  }

  export type brandCreateWithoutCategoriesInput = {
    name: string
    created_at?: Date | string | null
    subbrands?: subbrandCreateNestedManyWithoutBrandInput
    stores?: storeCreateNestedManyWithoutBrandInput
    channels?: channelCreateNestedManyWithoutBrandInput
    products?: productCreateNestedManyWithoutBrandInput
    optiongroups?: optiongroupCreateNestedManyWithoutBrandInput
    items?: itemCreateNestedManyWithoutBrandInput
    paymenttypes?: paymenttypeCreateNestedManyWithoutBrandInput
    coupons?: couponCreateNestedManyWithoutBrandInput
  }

  export type brandUncheckedCreateWithoutCategoriesInput = {
    id?: number
    name: string
    created_at?: Date | string | null
    subbrands?: subbrandUncheckedCreateNestedManyWithoutBrandInput
    stores?: storeUncheckedCreateNestedManyWithoutBrandInput
    channels?: channelUncheckedCreateNestedManyWithoutBrandInput
    products?: productUncheckedCreateNestedManyWithoutBrandInput
    optiongroups?: optiongroupUncheckedCreateNestedManyWithoutBrandInput
    items?: itemUncheckedCreateNestedManyWithoutBrandInput
    paymenttypes?: paymenttypeUncheckedCreateNestedManyWithoutBrandInput
    coupons?: couponUncheckedCreateNestedManyWithoutBrandInput
  }

  export type brandCreateOrConnectWithoutCategoriesInput = {
    where: brandWhereUniqueInput
    create: XOR<brandCreateWithoutCategoriesInput, brandUncheckedCreateWithoutCategoriesInput>
  }

  export type subbrandCreateWithoutCategoriesInput = {
    name: string
    created_at?: Date | string | null
    brand: brandCreateNestedOneWithoutSubbrandsInput
    stores?: storeCreateNestedManyWithoutSubbrandInput
    products?: productCreateNestedManyWithoutSubbrandInput
    optiongroups?: optiongroupCreateNestedManyWithoutSubbrandInput
    items?: itemCreateNestedManyWithoutSubbrandInput
    customers?: customerCreateNestedManyWithoutSubbrandInput
    sales?: saleCreateNestedManyWithoutSubbrandInput
  }

  export type subbrandUncheckedCreateWithoutCategoriesInput = {
    id?: number
    brand_id: number
    name: string
    created_at?: Date | string | null
    stores?: storeUncheckedCreateNestedManyWithoutSubbrandInput
    products?: productUncheckedCreateNestedManyWithoutSubbrandInput
    optiongroups?: optiongroupUncheckedCreateNestedManyWithoutSubbrandInput
    items?: itemUncheckedCreateNestedManyWithoutSubbrandInput
    customers?: customerUncheckedCreateNestedManyWithoutSubbrandInput
    sales?: saleUncheckedCreateNestedManyWithoutSubbrandInput
  }

  export type subbrandCreateOrConnectWithoutCategoriesInput = {
    where: subbrandWhereUniqueInput
    create: XOR<subbrandCreateWithoutCategoriesInput, subbrandUncheckedCreateWithoutCategoriesInput>
  }

  export type productCreateWithoutCategoryInput = {
    name: string
    pos_uuid?: string | null
    deleted_at?: Date | string | null
    brand: brandCreateNestedOneWithoutProductsInput
    subbrand?: subbrandCreateNestedOneWithoutProductsInput
    productsales?: productsaleCreateNestedManyWithoutProductInput
  }

  export type productUncheckedCreateWithoutCategoryInput = {
    id?: number
    brand_id: number
    sub_brand_id?: number | null
    name: string
    pos_uuid?: string | null
    deleted_at?: Date | string | null
    productsales?: productsaleUncheckedCreateNestedManyWithoutProductInput
  }

  export type productCreateOrConnectWithoutCategoryInput = {
    where: productWhereUniqueInput
    create: XOR<productCreateWithoutCategoryInput, productUncheckedCreateWithoutCategoryInput>
  }

  export type productCreateManyCategoryInputEnvelope = {
    data: productCreateManyCategoryInput | productCreateManyCategoryInput[]
    skipDuplicates?: boolean
  }

  export type optiongroupCreateWithoutCategoryInput = {
    name: string
    pos_uuid?: string | null
    deleted_at?: Date | string | null
    brand: brandCreateNestedOneWithoutOptiongroupsInput
    subbrand?: subbrandCreateNestedOneWithoutOptiongroupsInput
    itemproductsales?: itemproductsaleCreateNestedManyWithoutOptiongroupInput
    itemitemproductsales?: itemitemproductsaleCreateNestedManyWithoutOptiongroupInput
  }

  export type optiongroupUncheckedCreateWithoutCategoryInput = {
    id?: number
    brand_id: number
    sub_brand_id?: number | null
    name: string
    pos_uuid?: string | null
    deleted_at?: Date | string | null
    itemproductsales?: itemproductsaleUncheckedCreateNestedManyWithoutOptiongroupInput
    itemitemproductsales?: itemitemproductsaleUncheckedCreateNestedManyWithoutOptiongroupInput
  }

  export type optiongroupCreateOrConnectWithoutCategoryInput = {
    where: optiongroupWhereUniqueInput
    create: XOR<optiongroupCreateWithoutCategoryInput, optiongroupUncheckedCreateWithoutCategoryInput>
  }

  export type optiongroupCreateManyCategoryInputEnvelope = {
    data: optiongroupCreateManyCategoryInput | optiongroupCreateManyCategoryInput[]
    skipDuplicates?: boolean
  }

  export type itemCreateWithoutCategoryInput = {
    name: string
    pos_uuid?: string | null
    deleted_at?: Date | string | null
    brand: brandCreateNestedOneWithoutItemsInput
    subbrand?: subbrandCreateNestedOneWithoutItemsInput
    itemproductsales?: itemproductsaleCreateNestedManyWithoutItemInput
    itemitemproductsales?: itemitemproductsaleCreateNestedManyWithoutItemInput
  }

  export type itemUncheckedCreateWithoutCategoryInput = {
    id?: number
    brand_id: number
    sub_brand_id?: number | null
    name: string
    pos_uuid?: string | null
    deleted_at?: Date | string | null
    itemproductsales?: itemproductsaleUncheckedCreateNestedManyWithoutItemInput
    itemitemproductsales?: itemitemproductsaleUncheckedCreateNestedManyWithoutItemInput
  }

  export type itemCreateOrConnectWithoutCategoryInput = {
    where: itemWhereUniqueInput
    create: XOR<itemCreateWithoutCategoryInput, itemUncheckedCreateWithoutCategoryInput>
  }

  export type itemCreateManyCategoryInputEnvelope = {
    data: itemCreateManyCategoryInput | itemCreateManyCategoryInput[]
    skipDuplicates?: boolean
  }

  export type brandUpsertWithoutCategoriesInput = {
    update: XOR<brandUpdateWithoutCategoriesInput, brandUncheckedUpdateWithoutCategoriesInput>
    create: XOR<brandCreateWithoutCategoriesInput, brandUncheckedCreateWithoutCategoriesInput>
    where?: brandWhereInput
  }

  export type brandUpdateToOneWithWhereWithoutCategoriesInput = {
    where?: brandWhereInput
    data: XOR<brandUpdateWithoutCategoriesInput, brandUncheckedUpdateWithoutCategoriesInput>
  }

  export type brandUpdateWithoutCategoriesInput = {
    name?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subbrands?: subbrandUpdateManyWithoutBrandNestedInput
    stores?: storeUpdateManyWithoutBrandNestedInput
    channels?: channelUpdateManyWithoutBrandNestedInput
    products?: productUpdateManyWithoutBrandNestedInput
    optiongroups?: optiongroupUpdateManyWithoutBrandNestedInput
    items?: itemUpdateManyWithoutBrandNestedInput
    paymenttypes?: paymenttypeUpdateManyWithoutBrandNestedInput
    coupons?: couponUpdateManyWithoutBrandNestedInput
  }

  export type brandUncheckedUpdateWithoutCategoriesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subbrands?: subbrandUncheckedUpdateManyWithoutBrandNestedInput
    stores?: storeUncheckedUpdateManyWithoutBrandNestedInput
    channels?: channelUncheckedUpdateManyWithoutBrandNestedInput
    products?: productUncheckedUpdateManyWithoutBrandNestedInput
    optiongroups?: optiongroupUncheckedUpdateManyWithoutBrandNestedInput
    items?: itemUncheckedUpdateManyWithoutBrandNestedInput
    paymenttypes?: paymenttypeUncheckedUpdateManyWithoutBrandNestedInput
    coupons?: couponUncheckedUpdateManyWithoutBrandNestedInput
  }

  export type subbrandUpsertWithoutCategoriesInput = {
    update: XOR<subbrandUpdateWithoutCategoriesInput, subbrandUncheckedUpdateWithoutCategoriesInput>
    create: XOR<subbrandCreateWithoutCategoriesInput, subbrandUncheckedCreateWithoutCategoriesInput>
    where?: subbrandWhereInput
  }

  export type subbrandUpdateToOneWithWhereWithoutCategoriesInput = {
    where?: subbrandWhereInput
    data: XOR<subbrandUpdateWithoutCategoriesInput, subbrandUncheckedUpdateWithoutCategoriesInput>
  }

  export type subbrandUpdateWithoutCategoriesInput = {
    name?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    brand?: brandUpdateOneRequiredWithoutSubbrandsNestedInput
    stores?: storeUpdateManyWithoutSubbrandNestedInput
    products?: productUpdateManyWithoutSubbrandNestedInput
    optiongroups?: optiongroupUpdateManyWithoutSubbrandNestedInput
    items?: itemUpdateManyWithoutSubbrandNestedInput
    customers?: customerUpdateManyWithoutSubbrandNestedInput
    sales?: saleUpdateManyWithoutSubbrandNestedInput
  }

  export type subbrandUncheckedUpdateWithoutCategoriesInput = {
    id?: IntFieldUpdateOperationsInput | number
    brand_id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stores?: storeUncheckedUpdateManyWithoutSubbrandNestedInput
    products?: productUncheckedUpdateManyWithoutSubbrandNestedInput
    optiongroups?: optiongroupUncheckedUpdateManyWithoutSubbrandNestedInput
    items?: itemUncheckedUpdateManyWithoutSubbrandNestedInput
    customers?: customerUncheckedUpdateManyWithoutSubbrandNestedInput
    sales?: saleUncheckedUpdateManyWithoutSubbrandNestedInput
  }

  export type productUpsertWithWhereUniqueWithoutCategoryInput = {
    where: productWhereUniqueInput
    update: XOR<productUpdateWithoutCategoryInput, productUncheckedUpdateWithoutCategoryInput>
    create: XOR<productCreateWithoutCategoryInput, productUncheckedCreateWithoutCategoryInput>
  }

  export type productUpdateWithWhereUniqueWithoutCategoryInput = {
    where: productWhereUniqueInput
    data: XOR<productUpdateWithoutCategoryInput, productUncheckedUpdateWithoutCategoryInput>
  }

  export type productUpdateManyWithWhereWithoutCategoryInput = {
    where: productScalarWhereInput
    data: XOR<productUpdateManyMutationInput, productUncheckedUpdateManyWithoutCategoryInput>
  }

  export type optiongroupUpsertWithWhereUniqueWithoutCategoryInput = {
    where: optiongroupWhereUniqueInput
    update: XOR<optiongroupUpdateWithoutCategoryInput, optiongroupUncheckedUpdateWithoutCategoryInput>
    create: XOR<optiongroupCreateWithoutCategoryInput, optiongroupUncheckedCreateWithoutCategoryInput>
  }

  export type optiongroupUpdateWithWhereUniqueWithoutCategoryInput = {
    where: optiongroupWhereUniqueInput
    data: XOR<optiongroupUpdateWithoutCategoryInput, optiongroupUncheckedUpdateWithoutCategoryInput>
  }

  export type optiongroupUpdateManyWithWhereWithoutCategoryInput = {
    where: optiongroupScalarWhereInput
    data: XOR<optiongroupUpdateManyMutationInput, optiongroupUncheckedUpdateManyWithoutCategoryInput>
  }

  export type itemUpsertWithWhereUniqueWithoutCategoryInput = {
    where: itemWhereUniqueInput
    update: XOR<itemUpdateWithoutCategoryInput, itemUncheckedUpdateWithoutCategoryInput>
    create: XOR<itemCreateWithoutCategoryInput, itemUncheckedCreateWithoutCategoryInput>
  }

  export type itemUpdateWithWhereUniqueWithoutCategoryInput = {
    where: itemWhereUniqueInput
    data: XOR<itemUpdateWithoutCategoryInput, itemUncheckedUpdateWithoutCategoryInput>
  }

  export type itemUpdateManyWithWhereWithoutCategoryInput = {
    where: itemScalarWhereInput
    data: XOR<itemUpdateManyMutationInput, itemUncheckedUpdateManyWithoutCategoryInput>
  }

  export type brandCreateWithoutProductsInput = {
    name: string
    created_at?: Date | string | null
    subbrands?: subbrandCreateNestedManyWithoutBrandInput
    stores?: storeCreateNestedManyWithoutBrandInput
    channels?: channelCreateNestedManyWithoutBrandInput
    categories?: categoryCreateNestedManyWithoutBrandInput
    optiongroups?: optiongroupCreateNestedManyWithoutBrandInput
    items?: itemCreateNestedManyWithoutBrandInput
    paymenttypes?: paymenttypeCreateNestedManyWithoutBrandInput
    coupons?: couponCreateNestedManyWithoutBrandInput
  }

  export type brandUncheckedCreateWithoutProductsInput = {
    id?: number
    name: string
    created_at?: Date | string | null
    subbrands?: subbrandUncheckedCreateNestedManyWithoutBrandInput
    stores?: storeUncheckedCreateNestedManyWithoutBrandInput
    channels?: channelUncheckedCreateNestedManyWithoutBrandInput
    categories?: categoryUncheckedCreateNestedManyWithoutBrandInput
    optiongroups?: optiongroupUncheckedCreateNestedManyWithoutBrandInput
    items?: itemUncheckedCreateNestedManyWithoutBrandInput
    paymenttypes?: paymenttypeUncheckedCreateNestedManyWithoutBrandInput
    coupons?: couponUncheckedCreateNestedManyWithoutBrandInput
  }

  export type brandCreateOrConnectWithoutProductsInput = {
    where: brandWhereUniqueInput
    create: XOR<brandCreateWithoutProductsInput, brandUncheckedCreateWithoutProductsInput>
  }

  export type subbrandCreateWithoutProductsInput = {
    name: string
    created_at?: Date | string | null
    brand: brandCreateNestedOneWithoutSubbrandsInput
    stores?: storeCreateNestedManyWithoutSubbrandInput
    categories?: categoryCreateNestedManyWithoutSubbrandInput
    optiongroups?: optiongroupCreateNestedManyWithoutSubbrandInput
    items?: itemCreateNestedManyWithoutSubbrandInput
    customers?: customerCreateNestedManyWithoutSubbrandInput
    sales?: saleCreateNestedManyWithoutSubbrandInput
  }

  export type subbrandUncheckedCreateWithoutProductsInput = {
    id?: number
    brand_id: number
    name: string
    created_at?: Date | string | null
    stores?: storeUncheckedCreateNestedManyWithoutSubbrandInput
    categories?: categoryUncheckedCreateNestedManyWithoutSubbrandInput
    optiongroups?: optiongroupUncheckedCreateNestedManyWithoutSubbrandInput
    items?: itemUncheckedCreateNestedManyWithoutSubbrandInput
    customers?: customerUncheckedCreateNestedManyWithoutSubbrandInput
    sales?: saleUncheckedCreateNestedManyWithoutSubbrandInput
  }

  export type subbrandCreateOrConnectWithoutProductsInput = {
    where: subbrandWhereUniqueInput
    create: XOR<subbrandCreateWithoutProductsInput, subbrandUncheckedCreateWithoutProductsInput>
  }

  export type categoryCreateWithoutProductsInput = {
    name: string
    type?: string | null
    pos_uuid?: string | null
    deleted_at?: Date | string | null
    brand: brandCreateNestedOneWithoutCategoriesInput
    subbrand?: subbrandCreateNestedOneWithoutCategoriesInput
    optiongroups?: optiongroupCreateNestedManyWithoutCategoryInput
    items?: itemCreateNestedManyWithoutCategoryInput
  }

  export type categoryUncheckedCreateWithoutProductsInput = {
    id?: number
    brand_id: number
    sub_brand_id?: number | null
    name: string
    type?: string | null
    pos_uuid?: string | null
    deleted_at?: Date | string | null
    optiongroups?: optiongroupUncheckedCreateNestedManyWithoutCategoryInput
    items?: itemUncheckedCreateNestedManyWithoutCategoryInput
  }

  export type categoryCreateOrConnectWithoutProductsInput = {
    where: categoryWhereUniqueInput
    create: XOR<categoryCreateWithoutProductsInput, categoryUncheckedCreateWithoutProductsInput>
  }

  export type productsaleCreateWithoutProductInput = {
    quantity: number
    base_price: number
    total_price: number
    observations?: string | null
    sale: saleCreateNestedOneWithoutProductsalesInput
    itemproductsales?: itemproductsaleCreateNestedManyWithoutProductsaleInput
  }

  export type productsaleUncheckedCreateWithoutProductInput = {
    id?: number
    sale_id: number
    quantity: number
    base_price: number
    total_price: number
    observations?: string | null
    itemproductsales?: itemproductsaleUncheckedCreateNestedManyWithoutProductsaleInput
  }

  export type productsaleCreateOrConnectWithoutProductInput = {
    where: productsaleWhereUniqueInput
    create: XOR<productsaleCreateWithoutProductInput, productsaleUncheckedCreateWithoutProductInput>
  }

  export type productsaleCreateManyProductInputEnvelope = {
    data: productsaleCreateManyProductInput | productsaleCreateManyProductInput[]
    skipDuplicates?: boolean
  }

  export type brandUpsertWithoutProductsInput = {
    update: XOR<brandUpdateWithoutProductsInput, brandUncheckedUpdateWithoutProductsInput>
    create: XOR<brandCreateWithoutProductsInput, brandUncheckedCreateWithoutProductsInput>
    where?: brandWhereInput
  }

  export type brandUpdateToOneWithWhereWithoutProductsInput = {
    where?: brandWhereInput
    data: XOR<brandUpdateWithoutProductsInput, brandUncheckedUpdateWithoutProductsInput>
  }

  export type brandUpdateWithoutProductsInput = {
    name?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subbrands?: subbrandUpdateManyWithoutBrandNestedInput
    stores?: storeUpdateManyWithoutBrandNestedInput
    channels?: channelUpdateManyWithoutBrandNestedInput
    categories?: categoryUpdateManyWithoutBrandNestedInput
    optiongroups?: optiongroupUpdateManyWithoutBrandNestedInput
    items?: itemUpdateManyWithoutBrandNestedInput
    paymenttypes?: paymenttypeUpdateManyWithoutBrandNestedInput
    coupons?: couponUpdateManyWithoutBrandNestedInput
  }

  export type brandUncheckedUpdateWithoutProductsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subbrands?: subbrandUncheckedUpdateManyWithoutBrandNestedInput
    stores?: storeUncheckedUpdateManyWithoutBrandNestedInput
    channels?: channelUncheckedUpdateManyWithoutBrandNestedInput
    categories?: categoryUncheckedUpdateManyWithoutBrandNestedInput
    optiongroups?: optiongroupUncheckedUpdateManyWithoutBrandNestedInput
    items?: itemUncheckedUpdateManyWithoutBrandNestedInput
    paymenttypes?: paymenttypeUncheckedUpdateManyWithoutBrandNestedInput
    coupons?: couponUncheckedUpdateManyWithoutBrandNestedInput
  }

  export type subbrandUpsertWithoutProductsInput = {
    update: XOR<subbrandUpdateWithoutProductsInput, subbrandUncheckedUpdateWithoutProductsInput>
    create: XOR<subbrandCreateWithoutProductsInput, subbrandUncheckedCreateWithoutProductsInput>
    where?: subbrandWhereInput
  }

  export type subbrandUpdateToOneWithWhereWithoutProductsInput = {
    where?: subbrandWhereInput
    data: XOR<subbrandUpdateWithoutProductsInput, subbrandUncheckedUpdateWithoutProductsInput>
  }

  export type subbrandUpdateWithoutProductsInput = {
    name?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    brand?: brandUpdateOneRequiredWithoutSubbrandsNestedInput
    stores?: storeUpdateManyWithoutSubbrandNestedInput
    categories?: categoryUpdateManyWithoutSubbrandNestedInput
    optiongroups?: optiongroupUpdateManyWithoutSubbrandNestedInput
    items?: itemUpdateManyWithoutSubbrandNestedInput
    customers?: customerUpdateManyWithoutSubbrandNestedInput
    sales?: saleUpdateManyWithoutSubbrandNestedInput
  }

  export type subbrandUncheckedUpdateWithoutProductsInput = {
    id?: IntFieldUpdateOperationsInput | number
    brand_id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stores?: storeUncheckedUpdateManyWithoutSubbrandNestedInput
    categories?: categoryUncheckedUpdateManyWithoutSubbrandNestedInput
    optiongroups?: optiongroupUncheckedUpdateManyWithoutSubbrandNestedInput
    items?: itemUncheckedUpdateManyWithoutSubbrandNestedInput
    customers?: customerUncheckedUpdateManyWithoutSubbrandNestedInput
    sales?: saleUncheckedUpdateManyWithoutSubbrandNestedInput
  }

  export type categoryUpsertWithoutProductsInput = {
    update: XOR<categoryUpdateWithoutProductsInput, categoryUncheckedUpdateWithoutProductsInput>
    create: XOR<categoryCreateWithoutProductsInput, categoryUncheckedCreateWithoutProductsInput>
    where?: categoryWhereInput
  }

  export type categoryUpdateToOneWithWhereWithoutProductsInput = {
    where?: categoryWhereInput
    data: XOR<categoryUpdateWithoutProductsInput, categoryUncheckedUpdateWithoutProductsInput>
  }

  export type categoryUpdateWithoutProductsInput = {
    name?: StringFieldUpdateOperationsInput | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    pos_uuid?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    brand?: brandUpdateOneRequiredWithoutCategoriesNestedInput
    subbrand?: subbrandUpdateOneWithoutCategoriesNestedInput
    optiongroups?: optiongroupUpdateManyWithoutCategoryNestedInput
    items?: itemUpdateManyWithoutCategoryNestedInput
  }

  export type categoryUncheckedUpdateWithoutProductsInput = {
    id?: IntFieldUpdateOperationsInput | number
    brand_id?: IntFieldUpdateOperationsInput | number
    sub_brand_id?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    pos_uuid?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    optiongroups?: optiongroupUncheckedUpdateManyWithoutCategoryNestedInput
    items?: itemUncheckedUpdateManyWithoutCategoryNestedInput
  }

  export type productsaleUpsertWithWhereUniqueWithoutProductInput = {
    where: productsaleWhereUniqueInput
    update: XOR<productsaleUpdateWithoutProductInput, productsaleUncheckedUpdateWithoutProductInput>
    create: XOR<productsaleCreateWithoutProductInput, productsaleUncheckedCreateWithoutProductInput>
  }

  export type productsaleUpdateWithWhereUniqueWithoutProductInput = {
    where: productsaleWhereUniqueInput
    data: XOR<productsaleUpdateWithoutProductInput, productsaleUncheckedUpdateWithoutProductInput>
  }

  export type productsaleUpdateManyWithWhereWithoutProductInput = {
    where: productsaleScalarWhereInput
    data: XOR<productsaleUpdateManyMutationInput, productsaleUncheckedUpdateManyWithoutProductInput>
  }

  export type productsaleScalarWhereInput = {
    AND?: productsaleScalarWhereInput | productsaleScalarWhereInput[]
    OR?: productsaleScalarWhereInput[]
    NOT?: productsaleScalarWhereInput | productsaleScalarWhereInput[]
    id?: IntFilter<"productsale"> | number
    sale_id?: IntFilter<"productsale"> | number
    product_id?: IntFilter<"productsale"> | number
    quantity?: FloatFilter<"productsale"> | number
    base_price?: FloatFilter<"productsale"> | number
    total_price?: FloatFilter<"productsale"> | number
    observations?: StringNullableFilter<"productsale"> | string | null
  }

  export type brandCreateWithoutOptiongroupsInput = {
    name: string
    created_at?: Date | string | null
    subbrands?: subbrandCreateNestedManyWithoutBrandInput
    stores?: storeCreateNestedManyWithoutBrandInput
    channels?: channelCreateNestedManyWithoutBrandInput
    categories?: categoryCreateNestedManyWithoutBrandInput
    products?: productCreateNestedManyWithoutBrandInput
    items?: itemCreateNestedManyWithoutBrandInput
    paymenttypes?: paymenttypeCreateNestedManyWithoutBrandInput
    coupons?: couponCreateNestedManyWithoutBrandInput
  }

  export type brandUncheckedCreateWithoutOptiongroupsInput = {
    id?: number
    name: string
    created_at?: Date | string | null
    subbrands?: subbrandUncheckedCreateNestedManyWithoutBrandInput
    stores?: storeUncheckedCreateNestedManyWithoutBrandInput
    channels?: channelUncheckedCreateNestedManyWithoutBrandInput
    categories?: categoryUncheckedCreateNestedManyWithoutBrandInput
    products?: productUncheckedCreateNestedManyWithoutBrandInput
    items?: itemUncheckedCreateNestedManyWithoutBrandInput
    paymenttypes?: paymenttypeUncheckedCreateNestedManyWithoutBrandInput
    coupons?: couponUncheckedCreateNestedManyWithoutBrandInput
  }

  export type brandCreateOrConnectWithoutOptiongroupsInput = {
    where: brandWhereUniqueInput
    create: XOR<brandCreateWithoutOptiongroupsInput, brandUncheckedCreateWithoutOptiongroupsInput>
  }

  export type subbrandCreateWithoutOptiongroupsInput = {
    name: string
    created_at?: Date | string | null
    brand: brandCreateNestedOneWithoutSubbrandsInput
    stores?: storeCreateNestedManyWithoutSubbrandInput
    categories?: categoryCreateNestedManyWithoutSubbrandInput
    products?: productCreateNestedManyWithoutSubbrandInput
    items?: itemCreateNestedManyWithoutSubbrandInput
    customers?: customerCreateNestedManyWithoutSubbrandInput
    sales?: saleCreateNestedManyWithoutSubbrandInput
  }

  export type subbrandUncheckedCreateWithoutOptiongroupsInput = {
    id?: number
    brand_id: number
    name: string
    created_at?: Date | string | null
    stores?: storeUncheckedCreateNestedManyWithoutSubbrandInput
    categories?: categoryUncheckedCreateNestedManyWithoutSubbrandInput
    products?: productUncheckedCreateNestedManyWithoutSubbrandInput
    items?: itemUncheckedCreateNestedManyWithoutSubbrandInput
    customers?: customerUncheckedCreateNestedManyWithoutSubbrandInput
    sales?: saleUncheckedCreateNestedManyWithoutSubbrandInput
  }

  export type subbrandCreateOrConnectWithoutOptiongroupsInput = {
    where: subbrandWhereUniqueInput
    create: XOR<subbrandCreateWithoutOptiongroupsInput, subbrandUncheckedCreateWithoutOptiongroupsInput>
  }

  export type categoryCreateWithoutOptiongroupsInput = {
    name: string
    type?: string | null
    pos_uuid?: string | null
    deleted_at?: Date | string | null
    brand: brandCreateNestedOneWithoutCategoriesInput
    subbrand?: subbrandCreateNestedOneWithoutCategoriesInput
    products?: productCreateNestedManyWithoutCategoryInput
    items?: itemCreateNestedManyWithoutCategoryInput
  }

  export type categoryUncheckedCreateWithoutOptiongroupsInput = {
    id?: number
    brand_id: number
    sub_brand_id?: number | null
    name: string
    type?: string | null
    pos_uuid?: string | null
    deleted_at?: Date | string | null
    products?: productUncheckedCreateNestedManyWithoutCategoryInput
    items?: itemUncheckedCreateNestedManyWithoutCategoryInput
  }

  export type categoryCreateOrConnectWithoutOptiongroupsInput = {
    where: categoryWhereUniqueInput
    create: XOR<categoryCreateWithoutOptiongroupsInput, categoryUncheckedCreateWithoutOptiongroupsInput>
  }

  export type itemproductsaleCreateWithoutOptiongroupInput = {
    quantity: number
    additional_price: number
    price: number
    amount?: number | null
    observations?: string | null
    productsale: productsaleCreateNestedOneWithoutItemproductsalesInput
    item: itemCreateNestedOneWithoutItemproductsalesInput
    itemitemproductsales?: itemitemproductsaleCreateNestedManyWithoutItemproductsaleInput
  }

  export type itemproductsaleUncheckedCreateWithoutOptiongroupInput = {
    id?: number
    product_sale_id: number
    item_id: number
    quantity: number
    additional_price: number
    price: number
    amount?: number | null
    observations?: string | null
    itemitemproductsales?: itemitemproductsaleUncheckedCreateNestedManyWithoutItemproductsaleInput
  }

  export type itemproductsaleCreateOrConnectWithoutOptiongroupInput = {
    where: itemproductsaleWhereUniqueInput
    create: XOR<itemproductsaleCreateWithoutOptiongroupInput, itemproductsaleUncheckedCreateWithoutOptiongroupInput>
  }

  export type itemproductsaleCreateManyOptiongroupInputEnvelope = {
    data: itemproductsaleCreateManyOptiongroupInput | itemproductsaleCreateManyOptiongroupInput[]
    skipDuplicates?: boolean
  }

  export type itemitemproductsaleCreateWithoutOptiongroupInput = {
    quantity: number
    additional_price: number
    price: number
    amount?: number | null
    itemproductsale: itemproductsaleCreateNestedOneWithoutItemitemproductsalesInput
    item: itemCreateNestedOneWithoutItemitemproductsalesInput
  }

  export type itemitemproductsaleUncheckedCreateWithoutOptiongroupInput = {
    id?: number
    item_product_sale_id: number
    item_id: number
    quantity: number
    additional_price: number
    price: number
    amount?: number | null
  }

  export type itemitemproductsaleCreateOrConnectWithoutOptiongroupInput = {
    where: itemitemproductsaleWhereUniqueInput
    create: XOR<itemitemproductsaleCreateWithoutOptiongroupInput, itemitemproductsaleUncheckedCreateWithoutOptiongroupInput>
  }

  export type itemitemproductsaleCreateManyOptiongroupInputEnvelope = {
    data: itemitemproductsaleCreateManyOptiongroupInput | itemitemproductsaleCreateManyOptiongroupInput[]
    skipDuplicates?: boolean
  }

  export type brandUpsertWithoutOptiongroupsInput = {
    update: XOR<brandUpdateWithoutOptiongroupsInput, brandUncheckedUpdateWithoutOptiongroupsInput>
    create: XOR<brandCreateWithoutOptiongroupsInput, brandUncheckedCreateWithoutOptiongroupsInput>
    where?: brandWhereInput
  }

  export type brandUpdateToOneWithWhereWithoutOptiongroupsInput = {
    where?: brandWhereInput
    data: XOR<brandUpdateWithoutOptiongroupsInput, brandUncheckedUpdateWithoutOptiongroupsInput>
  }

  export type brandUpdateWithoutOptiongroupsInput = {
    name?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subbrands?: subbrandUpdateManyWithoutBrandNestedInput
    stores?: storeUpdateManyWithoutBrandNestedInput
    channels?: channelUpdateManyWithoutBrandNestedInput
    categories?: categoryUpdateManyWithoutBrandNestedInput
    products?: productUpdateManyWithoutBrandNestedInput
    items?: itemUpdateManyWithoutBrandNestedInput
    paymenttypes?: paymenttypeUpdateManyWithoutBrandNestedInput
    coupons?: couponUpdateManyWithoutBrandNestedInput
  }

  export type brandUncheckedUpdateWithoutOptiongroupsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subbrands?: subbrandUncheckedUpdateManyWithoutBrandNestedInput
    stores?: storeUncheckedUpdateManyWithoutBrandNestedInput
    channels?: channelUncheckedUpdateManyWithoutBrandNestedInput
    categories?: categoryUncheckedUpdateManyWithoutBrandNestedInput
    products?: productUncheckedUpdateManyWithoutBrandNestedInput
    items?: itemUncheckedUpdateManyWithoutBrandNestedInput
    paymenttypes?: paymenttypeUncheckedUpdateManyWithoutBrandNestedInput
    coupons?: couponUncheckedUpdateManyWithoutBrandNestedInput
  }

  export type subbrandUpsertWithoutOptiongroupsInput = {
    update: XOR<subbrandUpdateWithoutOptiongroupsInput, subbrandUncheckedUpdateWithoutOptiongroupsInput>
    create: XOR<subbrandCreateWithoutOptiongroupsInput, subbrandUncheckedCreateWithoutOptiongroupsInput>
    where?: subbrandWhereInput
  }

  export type subbrandUpdateToOneWithWhereWithoutOptiongroupsInput = {
    where?: subbrandWhereInput
    data: XOR<subbrandUpdateWithoutOptiongroupsInput, subbrandUncheckedUpdateWithoutOptiongroupsInput>
  }

  export type subbrandUpdateWithoutOptiongroupsInput = {
    name?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    brand?: brandUpdateOneRequiredWithoutSubbrandsNestedInput
    stores?: storeUpdateManyWithoutSubbrandNestedInput
    categories?: categoryUpdateManyWithoutSubbrandNestedInput
    products?: productUpdateManyWithoutSubbrandNestedInput
    items?: itemUpdateManyWithoutSubbrandNestedInput
    customers?: customerUpdateManyWithoutSubbrandNestedInput
    sales?: saleUpdateManyWithoutSubbrandNestedInput
  }

  export type subbrandUncheckedUpdateWithoutOptiongroupsInput = {
    id?: IntFieldUpdateOperationsInput | number
    brand_id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stores?: storeUncheckedUpdateManyWithoutSubbrandNestedInput
    categories?: categoryUncheckedUpdateManyWithoutSubbrandNestedInput
    products?: productUncheckedUpdateManyWithoutSubbrandNestedInput
    items?: itemUncheckedUpdateManyWithoutSubbrandNestedInput
    customers?: customerUncheckedUpdateManyWithoutSubbrandNestedInput
    sales?: saleUncheckedUpdateManyWithoutSubbrandNestedInput
  }

  export type categoryUpsertWithoutOptiongroupsInput = {
    update: XOR<categoryUpdateWithoutOptiongroupsInput, categoryUncheckedUpdateWithoutOptiongroupsInput>
    create: XOR<categoryCreateWithoutOptiongroupsInput, categoryUncheckedCreateWithoutOptiongroupsInput>
    where?: categoryWhereInput
  }

  export type categoryUpdateToOneWithWhereWithoutOptiongroupsInput = {
    where?: categoryWhereInput
    data: XOR<categoryUpdateWithoutOptiongroupsInput, categoryUncheckedUpdateWithoutOptiongroupsInput>
  }

  export type categoryUpdateWithoutOptiongroupsInput = {
    name?: StringFieldUpdateOperationsInput | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    pos_uuid?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    brand?: brandUpdateOneRequiredWithoutCategoriesNestedInput
    subbrand?: subbrandUpdateOneWithoutCategoriesNestedInput
    products?: productUpdateManyWithoutCategoryNestedInput
    items?: itemUpdateManyWithoutCategoryNestedInput
  }

  export type categoryUncheckedUpdateWithoutOptiongroupsInput = {
    id?: IntFieldUpdateOperationsInput | number
    brand_id?: IntFieldUpdateOperationsInput | number
    sub_brand_id?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    pos_uuid?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    products?: productUncheckedUpdateManyWithoutCategoryNestedInput
    items?: itemUncheckedUpdateManyWithoutCategoryNestedInput
  }

  export type itemproductsaleUpsertWithWhereUniqueWithoutOptiongroupInput = {
    where: itemproductsaleWhereUniqueInput
    update: XOR<itemproductsaleUpdateWithoutOptiongroupInput, itemproductsaleUncheckedUpdateWithoutOptiongroupInput>
    create: XOR<itemproductsaleCreateWithoutOptiongroupInput, itemproductsaleUncheckedCreateWithoutOptiongroupInput>
  }

  export type itemproductsaleUpdateWithWhereUniqueWithoutOptiongroupInput = {
    where: itemproductsaleWhereUniqueInput
    data: XOR<itemproductsaleUpdateWithoutOptiongroupInput, itemproductsaleUncheckedUpdateWithoutOptiongroupInput>
  }

  export type itemproductsaleUpdateManyWithWhereWithoutOptiongroupInput = {
    where: itemproductsaleScalarWhereInput
    data: XOR<itemproductsaleUpdateManyMutationInput, itemproductsaleUncheckedUpdateManyWithoutOptiongroupInput>
  }

  export type itemproductsaleScalarWhereInput = {
    AND?: itemproductsaleScalarWhereInput | itemproductsaleScalarWhereInput[]
    OR?: itemproductsaleScalarWhereInput[]
    NOT?: itemproductsaleScalarWhereInput | itemproductsaleScalarWhereInput[]
    id?: IntFilter<"itemproductsale"> | number
    product_sale_id?: IntFilter<"itemproductsale"> | number
    item_id?: IntFilter<"itemproductsale"> | number
    option_group_id?: IntNullableFilter<"itemproductsale"> | number | null
    quantity?: FloatFilter<"itemproductsale"> | number
    additional_price?: FloatFilter<"itemproductsale"> | number
    price?: FloatFilter<"itemproductsale"> | number
    amount?: FloatNullableFilter<"itemproductsale"> | number | null
    observations?: StringNullableFilter<"itemproductsale"> | string | null
  }

  export type itemitemproductsaleUpsertWithWhereUniqueWithoutOptiongroupInput = {
    where: itemitemproductsaleWhereUniqueInput
    update: XOR<itemitemproductsaleUpdateWithoutOptiongroupInput, itemitemproductsaleUncheckedUpdateWithoutOptiongroupInput>
    create: XOR<itemitemproductsaleCreateWithoutOptiongroupInput, itemitemproductsaleUncheckedCreateWithoutOptiongroupInput>
  }

  export type itemitemproductsaleUpdateWithWhereUniqueWithoutOptiongroupInput = {
    where: itemitemproductsaleWhereUniqueInput
    data: XOR<itemitemproductsaleUpdateWithoutOptiongroupInput, itemitemproductsaleUncheckedUpdateWithoutOptiongroupInput>
  }

  export type itemitemproductsaleUpdateManyWithWhereWithoutOptiongroupInput = {
    where: itemitemproductsaleScalarWhereInput
    data: XOR<itemitemproductsaleUpdateManyMutationInput, itemitemproductsaleUncheckedUpdateManyWithoutOptiongroupInput>
  }

  export type itemitemproductsaleScalarWhereInput = {
    AND?: itemitemproductsaleScalarWhereInput | itemitemproductsaleScalarWhereInput[]
    OR?: itemitemproductsaleScalarWhereInput[]
    NOT?: itemitemproductsaleScalarWhereInput | itemitemproductsaleScalarWhereInput[]
    id?: IntFilter<"itemitemproductsale"> | number
    item_product_sale_id?: IntFilter<"itemitemproductsale"> | number
    item_id?: IntFilter<"itemitemproductsale"> | number
    option_group_id?: IntNullableFilter<"itemitemproductsale"> | number | null
    quantity?: FloatFilter<"itemitemproductsale"> | number
    additional_price?: FloatFilter<"itemitemproductsale"> | number
    price?: FloatFilter<"itemitemproductsale"> | number
    amount?: FloatNullableFilter<"itemitemproductsale"> | number | null
  }

  export type brandCreateWithoutItemsInput = {
    name: string
    created_at?: Date | string | null
    subbrands?: subbrandCreateNestedManyWithoutBrandInput
    stores?: storeCreateNestedManyWithoutBrandInput
    channels?: channelCreateNestedManyWithoutBrandInput
    categories?: categoryCreateNestedManyWithoutBrandInput
    products?: productCreateNestedManyWithoutBrandInput
    optiongroups?: optiongroupCreateNestedManyWithoutBrandInput
    paymenttypes?: paymenttypeCreateNestedManyWithoutBrandInput
    coupons?: couponCreateNestedManyWithoutBrandInput
  }

  export type brandUncheckedCreateWithoutItemsInput = {
    id?: number
    name: string
    created_at?: Date | string | null
    subbrands?: subbrandUncheckedCreateNestedManyWithoutBrandInput
    stores?: storeUncheckedCreateNestedManyWithoutBrandInput
    channels?: channelUncheckedCreateNestedManyWithoutBrandInput
    categories?: categoryUncheckedCreateNestedManyWithoutBrandInput
    products?: productUncheckedCreateNestedManyWithoutBrandInput
    optiongroups?: optiongroupUncheckedCreateNestedManyWithoutBrandInput
    paymenttypes?: paymenttypeUncheckedCreateNestedManyWithoutBrandInput
    coupons?: couponUncheckedCreateNestedManyWithoutBrandInput
  }

  export type brandCreateOrConnectWithoutItemsInput = {
    where: brandWhereUniqueInput
    create: XOR<brandCreateWithoutItemsInput, brandUncheckedCreateWithoutItemsInput>
  }

  export type subbrandCreateWithoutItemsInput = {
    name: string
    created_at?: Date | string | null
    brand: brandCreateNestedOneWithoutSubbrandsInput
    stores?: storeCreateNestedManyWithoutSubbrandInput
    categories?: categoryCreateNestedManyWithoutSubbrandInput
    products?: productCreateNestedManyWithoutSubbrandInput
    optiongroups?: optiongroupCreateNestedManyWithoutSubbrandInput
    customers?: customerCreateNestedManyWithoutSubbrandInput
    sales?: saleCreateNestedManyWithoutSubbrandInput
  }

  export type subbrandUncheckedCreateWithoutItemsInput = {
    id?: number
    brand_id: number
    name: string
    created_at?: Date | string | null
    stores?: storeUncheckedCreateNestedManyWithoutSubbrandInput
    categories?: categoryUncheckedCreateNestedManyWithoutSubbrandInput
    products?: productUncheckedCreateNestedManyWithoutSubbrandInput
    optiongroups?: optiongroupUncheckedCreateNestedManyWithoutSubbrandInput
    customers?: customerUncheckedCreateNestedManyWithoutSubbrandInput
    sales?: saleUncheckedCreateNestedManyWithoutSubbrandInput
  }

  export type subbrandCreateOrConnectWithoutItemsInput = {
    where: subbrandWhereUniqueInput
    create: XOR<subbrandCreateWithoutItemsInput, subbrandUncheckedCreateWithoutItemsInput>
  }

  export type categoryCreateWithoutItemsInput = {
    name: string
    type?: string | null
    pos_uuid?: string | null
    deleted_at?: Date | string | null
    brand: brandCreateNestedOneWithoutCategoriesInput
    subbrand?: subbrandCreateNestedOneWithoutCategoriesInput
    products?: productCreateNestedManyWithoutCategoryInput
    optiongroups?: optiongroupCreateNestedManyWithoutCategoryInput
  }

  export type categoryUncheckedCreateWithoutItemsInput = {
    id?: number
    brand_id: number
    sub_brand_id?: number | null
    name: string
    type?: string | null
    pos_uuid?: string | null
    deleted_at?: Date | string | null
    products?: productUncheckedCreateNestedManyWithoutCategoryInput
    optiongroups?: optiongroupUncheckedCreateNestedManyWithoutCategoryInput
  }

  export type categoryCreateOrConnectWithoutItemsInput = {
    where: categoryWhereUniqueInput
    create: XOR<categoryCreateWithoutItemsInput, categoryUncheckedCreateWithoutItemsInput>
  }

  export type itemproductsaleCreateWithoutItemInput = {
    quantity: number
    additional_price: number
    price: number
    amount?: number | null
    observations?: string | null
    productsale: productsaleCreateNestedOneWithoutItemproductsalesInput
    optiongroup?: optiongroupCreateNestedOneWithoutItemproductsalesInput
    itemitemproductsales?: itemitemproductsaleCreateNestedManyWithoutItemproductsaleInput
  }

  export type itemproductsaleUncheckedCreateWithoutItemInput = {
    id?: number
    product_sale_id: number
    option_group_id?: number | null
    quantity: number
    additional_price: number
    price: number
    amount?: number | null
    observations?: string | null
    itemitemproductsales?: itemitemproductsaleUncheckedCreateNestedManyWithoutItemproductsaleInput
  }

  export type itemproductsaleCreateOrConnectWithoutItemInput = {
    where: itemproductsaleWhereUniqueInput
    create: XOR<itemproductsaleCreateWithoutItemInput, itemproductsaleUncheckedCreateWithoutItemInput>
  }

  export type itemproductsaleCreateManyItemInputEnvelope = {
    data: itemproductsaleCreateManyItemInput | itemproductsaleCreateManyItemInput[]
    skipDuplicates?: boolean
  }

  export type itemitemproductsaleCreateWithoutItemInput = {
    quantity: number
    additional_price: number
    price: number
    amount?: number | null
    itemproductsale: itemproductsaleCreateNestedOneWithoutItemitemproductsalesInput
    optiongroup?: optiongroupCreateNestedOneWithoutItemitemproductsalesInput
  }

  export type itemitemproductsaleUncheckedCreateWithoutItemInput = {
    id?: number
    item_product_sale_id: number
    option_group_id?: number | null
    quantity: number
    additional_price: number
    price: number
    amount?: number | null
  }

  export type itemitemproductsaleCreateOrConnectWithoutItemInput = {
    where: itemitemproductsaleWhereUniqueInput
    create: XOR<itemitemproductsaleCreateWithoutItemInput, itemitemproductsaleUncheckedCreateWithoutItemInput>
  }

  export type itemitemproductsaleCreateManyItemInputEnvelope = {
    data: itemitemproductsaleCreateManyItemInput | itemitemproductsaleCreateManyItemInput[]
    skipDuplicates?: boolean
  }

  export type brandUpsertWithoutItemsInput = {
    update: XOR<brandUpdateWithoutItemsInput, brandUncheckedUpdateWithoutItemsInput>
    create: XOR<brandCreateWithoutItemsInput, brandUncheckedCreateWithoutItemsInput>
    where?: brandWhereInput
  }

  export type brandUpdateToOneWithWhereWithoutItemsInput = {
    where?: brandWhereInput
    data: XOR<brandUpdateWithoutItemsInput, brandUncheckedUpdateWithoutItemsInput>
  }

  export type brandUpdateWithoutItemsInput = {
    name?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subbrands?: subbrandUpdateManyWithoutBrandNestedInput
    stores?: storeUpdateManyWithoutBrandNestedInput
    channels?: channelUpdateManyWithoutBrandNestedInput
    categories?: categoryUpdateManyWithoutBrandNestedInput
    products?: productUpdateManyWithoutBrandNestedInput
    optiongroups?: optiongroupUpdateManyWithoutBrandNestedInput
    paymenttypes?: paymenttypeUpdateManyWithoutBrandNestedInput
    coupons?: couponUpdateManyWithoutBrandNestedInput
  }

  export type brandUncheckedUpdateWithoutItemsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subbrands?: subbrandUncheckedUpdateManyWithoutBrandNestedInput
    stores?: storeUncheckedUpdateManyWithoutBrandNestedInput
    channels?: channelUncheckedUpdateManyWithoutBrandNestedInput
    categories?: categoryUncheckedUpdateManyWithoutBrandNestedInput
    products?: productUncheckedUpdateManyWithoutBrandNestedInput
    optiongroups?: optiongroupUncheckedUpdateManyWithoutBrandNestedInput
    paymenttypes?: paymenttypeUncheckedUpdateManyWithoutBrandNestedInput
    coupons?: couponUncheckedUpdateManyWithoutBrandNestedInput
  }

  export type subbrandUpsertWithoutItemsInput = {
    update: XOR<subbrandUpdateWithoutItemsInput, subbrandUncheckedUpdateWithoutItemsInput>
    create: XOR<subbrandCreateWithoutItemsInput, subbrandUncheckedCreateWithoutItemsInput>
    where?: subbrandWhereInput
  }

  export type subbrandUpdateToOneWithWhereWithoutItemsInput = {
    where?: subbrandWhereInput
    data: XOR<subbrandUpdateWithoutItemsInput, subbrandUncheckedUpdateWithoutItemsInput>
  }

  export type subbrandUpdateWithoutItemsInput = {
    name?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    brand?: brandUpdateOneRequiredWithoutSubbrandsNestedInput
    stores?: storeUpdateManyWithoutSubbrandNestedInput
    categories?: categoryUpdateManyWithoutSubbrandNestedInput
    products?: productUpdateManyWithoutSubbrandNestedInput
    optiongroups?: optiongroupUpdateManyWithoutSubbrandNestedInput
    customers?: customerUpdateManyWithoutSubbrandNestedInput
    sales?: saleUpdateManyWithoutSubbrandNestedInput
  }

  export type subbrandUncheckedUpdateWithoutItemsInput = {
    id?: IntFieldUpdateOperationsInput | number
    brand_id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stores?: storeUncheckedUpdateManyWithoutSubbrandNestedInput
    categories?: categoryUncheckedUpdateManyWithoutSubbrandNestedInput
    products?: productUncheckedUpdateManyWithoutSubbrandNestedInput
    optiongroups?: optiongroupUncheckedUpdateManyWithoutSubbrandNestedInput
    customers?: customerUncheckedUpdateManyWithoutSubbrandNestedInput
    sales?: saleUncheckedUpdateManyWithoutSubbrandNestedInput
  }

  export type categoryUpsertWithoutItemsInput = {
    update: XOR<categoryUpdateWithoutItemsInput, categoryUncheckedUpdateWithoutItemsInput>
    create: XOR<categoryCreateWithoutItemsInput, categoryUncheckedCreateWithoutItemsInput>
    where?: categoryWhereInput
  }

  export type categoryUpdateToOneWithWhereWithoutItemsInput = {
    where?: categoryWhereInput
    data: XOR<categoryUpdateWithoutItemsInput, categoryUncheckedUpdateWithoutItemsInput>
  }

  export type categoryUpdateWithoutItemsInput = {
    name?: StringFieldUpdateOperationsInput | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    pos_uuid?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    brand?: brandUpdateOneRequiredWithoutCategoriesNestedInput
    subbrand?: subbrandUpdateOneWithoutCategoriesNestedInput
    products?: productUpdateManyWithoutCategoryNestedInput
    optiongroups?: optiongroupUpdateManyWithoutCategoryNestedInput
  }

  export type categoryUncheckedUpdateWithoutItemsInput = {
    id?: IntFieldUpdateOperationsInput | number
    brand_id?: IntFieldUpdateOperationsInput | number
    sub_brand_id?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    pos_uuid?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    products?: productUncheckedUpdateManyWithoutCategoryNestedInput
    optiongroups?: optiongroupUncheckedUpdateManyWithoutCategoryNestedInput
  }

  export type itemproductsaleUpsertWithWhereUniqueWithoutItemInput = {
    where: itemproductsaleWhereUniqueInput
    update: XOR<itemproductsaleUpdateWithoutItemInput, itemproductsaleUncheckedUpdateWithoutItemInput>
    create: XOR<itemproductsaleCreateWithoutItemInput, itemproductsaleUncheckedCreateWithoutItemInput>
  }

  export type itemproductsaleUpdateWithWhereUniqueWithoutItemInput = {
    where: itemproductsaleWhereUniqueInput
    data: XOR<itemproductsaleUpdateWithoutItemInput, itemproductsaleUncheckedUpdateWithoutItemInput>
  }

  export type itemproductsaleUpdateManyWithWhereWithoutItemInput = {
    where: itemproductsaleScalarWhereInput
    data: XOR<itemproductsaleUpdateManyMutationInput, itemproductsaleUncheckedUpdateManyWithoutItemInput>
  }

  export type itemitemproductsaleUpsertWithWhereUniqueWithoutItemInput = {
    where: itemitemproductsaleWhereUniqueInput
    update: XOR<itemitemproductsaleUpdateWithoutItemInput, itemitemproductsaleUncheckedUpdateWithoutItemInput>
    create: XOR<itemitemproductsaleCreateWithoutItemInput, itemitemproductsaleUncheckedCreateWithoutItemInput>
  }

  export type itemitemproductsaleUpdateWithWhereUniqueWithoutItemInput = {
    where: itemitemproductsaleWhereUniqueInput
    data: XOR<itemitemproductsaleUpdateWithoutItemInput, itemitemproductsaleUncheckedUpdateWithoutItemInput>
  }

  export type itemitemproductsaleUpdateManyWithWhereWithoutItemInput = {
    where: itemitemproductsaleScalarWhereInput
    data: XOR<itemitemproductsaleUpdateManyMutationInput, itemitemproductsaleUncheckedUpdateManyWithoutItemInput>
  }

  export type storeCreateWithoutCustomersInput = {
    name: string
    city?: string | null
    state?: string | null
    district?: string | null
    address_street?: string | null
    address_number?: number | null
    zipcode?: string | null
    latitude?: Decimal | DecimalJsLike | number | string | null
    longitude?: Decimal | DecimalJsLike | number | string | null
    is_active?: boolean | null
    is_own?: boolean | null
    is_holding?: boolean | null
    creation_date?: Date | string | null
    created_at?: Date | string | null
    brand: brandCreateNestedOneWithoutStoresInput
    subbrand?: subbrandCreateNestedOneWithoutStoresInput
    sales?: saleCreateNestedManyWithoutStoreInput
  }

  export type storeUncheckedCreateWithoutCustomersInput = {
    id?: number
    brand_id: number
    sub_brand_id?: number | null
    name: string
    city?: string | null
    state?: string | null
    district?: string | null
    address_street?: string | null
    address_number?: number | null
    zipcode?: string | null
    latitude?: Decimal | DecimalJsLike | number | string | null
    longitude?: Decimal | DecimalJsLike | number | string | null
    is_active?: boolean | null
    is_own?: boolean | null
    is_holding?: boolean | null
    creation_date?: Date | string | null
    created_at?: Date | string | null
    sales?: saleUncheckedCreateNestedManyWithoutStoreInput
  }

  export type storeCreateOrConnectWithoutCustomersInput = {
    where: storeWhereUniqueInput
    create: XOR<storeCreateWithoutCustomersInput, storeUncheckedCreateWithoutCustomersInput>
  }

  export type subbrandCreateWithoutCustomersInput = {
    name: string
    created_at?: Date | string | null
    brand: brandCreateNestedOneWithoutSubbrandsInput
    stores?: storeCreateNestedManyWithoutSubbrandInput
    categories?: categoryCreateNestedManyWithoutSubbrandInput
    products?: productCreateNestedManyWithoutSubbrandInput
    optiongroups?: optiongroupCreateNestedManyWithoutSubbrandInput
    items?: itemCreateNestedManyWithoutSubbrandInput
    sales?: saleCreateNestedManyWithoutSubbrandInput
  }

  export type subbrandUncheckedCreateWithoutCustomersInput = {
    id?: number
    brand_id: number
    name: string
    created_at?: Date | string | null
    stores?: storeUncheckedCreateNestedManyWithoutSubbrandInput
    categories?: categoryUncheckedCreateNestedManyWithoutSubbrandInput
    products?: productUncheckedCreateNestedManyWithoutSubbrandInput
    optiongroups?: optiongroupUncheckedCreateNestedManyWithoutSubbrandInput
    items?: itemUncheckedCreateNestedManyWithoutSubbrandInput
    sales?: saleUncheckedCreateNestedManyWithoutSubbrandInput
  }

  export type subbrandCreateOrConnectWithoutCustomersInput = {
    where: subbrandWhereUniqueInput
    create: XOR<subbrandCreateWithoutCustomersInput, subbrandUncheckedCreateWithoutCustomersInput>
  }

  export type saleCreateWithoutCustomerInput = {
    cod_sale1?: string | null
    cod_sale2?: string | null
    created_at: Date | string
    customer_name?: string | null
    sale_status_desc: string
    total_amount_items: Decimal | DecimalJsLike | number | string
    total_discount?: Decimal | DecimalJsLike | number | string | null
    total_increase?: Decimal | DecimalJsLike | number | string | null
    delivery_fee?: Decimal | DecimalJsLike | number | string | null
    service_tax_fee?: Decimal | DecimalJsLike | number | string | null
    total_amount: Decimal | DecimalJsLike | number | string
    value_paid?: Decimal | DecimalJsLike | number | string | null
    production_seconds?: number | null
    delivery_seconds?: number | null
    people_quantity?: number | null
    discount_reason?: string | null
    increase_reason?: string | null
    origin?: string | null
    store: storeCreateNestedOneWithoutSalesInput
    subbrand?: subbrandCreateNestedOneWithoutSalesInput
    channel: channelCreateNestedOneWithoutSalesInput
    productsales?: productsaleCreateNestedManyWithoutSaleInput
    deliverysales?: deliverysaleCreateNestedManyWithoutSaleInput
    deliveryaddress?: deliveryaddressCreateNestedManyWithoutSaleInput
    payments?: paymentCreateNestedManyWithoutSaleInput
    couponsales?: couponsaleCreateNestedManyWithoutSaleInput
  }

  export type saleUncheckedCreateWithoutCustomerInput = {
    id?: number
    store_id: number
    sub_brand_id?: number | null
    channel_id: number
    cod_sale1?: string | null
    cod_sale2?: string | null
    created_at: Date | string
    customer_name?: string | null
    sale_status_desc: string
    total_amount_items: Decimal | DecimalJsLike | number | string
    total_discount?: Decimal | DecimalJsLike | number | string | null
    total_increase?: Decimal | DecimalJsLike | number | string | null
    delivery_fee?: Decimal | DecimalJsLike | number | string | null
    service_tax_fee?: Decimal | DecimalJsLike | number | string | null
    total_amount: Decimal | DecimalJsLike | number | string
    value_paid?: Decimal | DecimalJsLike | number | string | null
    production_seconds?: number | null
    delivery_seconds?: number | null
    people_quantity?: number | null
    discount_reason?: string | null
    increase_reason?: string | null
    origin?: string | null
    productsales?: productsaleUncheckedCreateNestedManyWithoutSaleInput
    deliverysales?: deliverysaleUncheckedCreateNestedManyWithoutSaleInput
    deliveryaddress?: deliveryaddressUncheckedCreateNestedManyWithoutSaleInput
    payments?: paymentUncheckedCreateNestedManyWithoutSaleInput
    couponsales?: couponsaleUncheckedCreateNestedManyWithoutSaleInput
  }

  export type saleCreateOrConnectWithoutCustomerInput = {
    where: saleWhereUniqueInput
    create: XOR<saleCreateWithoutCustomerInput, saleUncheckedCreateWithoutCustomerInput>
  }

  export type saleCreateManyCustomerInputEnvelope = {
    data: saleCreateManyCustomerInput | saleCreateManyCustomerInput[]
    skipDuplicates?: boolean
  }

  export type storeUpsertWithoutCustomersInput = {
    update: XOR<storeUpdateWithoutCustomersInput, storeUncheckedUpdateWithoutCustomersInput>
    create: XOR<storeCreateWithoutCustomersInput, storeUncheckedCreateWithoutCustomersInput>
    where?: storeWhereInput
  }

  export type storeUpdateToOneWithWhereWithoutCustomersInput = {
    where?: storeWhereInput
    data: XOR<storeUpdateWithoutCustomersInput, storeUncheckedUpdateWithoutCustomersInput>
  }

  export type storeUpdateWithoutCustomersInput = {
    name?: StringFieldUpdateOperationsInput | string
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    district?: NullableStringFieldUpdateOperationsInput | string | null
    address_street?: NullableStringFieldUpdateOperationsInput | string | null
    address_number?: NullableIntFieldUpdateOperationsInput | number | null
    zipcode?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    longitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_own?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_holding?: NullableBoolFieldUpdateOperationsInput | boolean | null
    creation_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    brand?: brandUpdateOneRequiredWithoutStoresNestedInput
    subbrand?: subbrandUpdateOneWithoutStoresNestedInput
    sales?: saleUpdateManyWithoutStoreNestedInput
  }

  export type storeUncheckedUpdateWithoutCustomersInput = {
    id?: IntFieldUpdateOperationsInput | number
    brand_id?: IntFieldUpdateOperationsInput | number
    sub_brand_id?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    district?: NullableStringFieldUpdateOperationsInput | string | null
    address_street?: NullableStringFieldUpdateOperationsInput | string | null
    address_number?: NullableIntFieldUpdateOperationsInput | number | null
    zipcode?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    longitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_own?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_holding?: NullableBoolFieldUpdateOperationsInput | boolean | null
    creation_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sales?: saleUncheckedUpdateManyWithoutStoreNestedInput
  }

  export type subbrandUpsertWithoutCustomersInput = {
    update: XOR<subbrandUpdateWithoutCustomersInput, subbrandUncheckedUpdateWithoutCustomersInput>
    create: XOR<subbrandCreateWithoutCustomersInput, subbrandUncheckedCreateWithoutCustomersInput>
    where?: subbrandWhereInput
  }

  export type subbrandUpdateToOneWithWhereWithoutCustomersInput = {
    where?: subbrandWhereInput
    data: XOR<subbrandUpdateWithoutCustomersInput, subbrandUncheckedUpdateWithoutCustomersInput>
  }

  export type subbrandUpdateWithoutCustomersInput = {
    name?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    brand?: brandUpdateOneRequiredWithoutSubbrandsNestedInput
    stores?: storeUpdateManyWithoutSubbrandNestedInput
    categories?: categoryUpdateManyWithoutSubbrandNestedInput
    products?: productUpdateManyWithoutSubbrandNestedInput
    optiongroups?: optiongroupUpdateManyWithoutSubbrandNestedInput
    items?: itemUpdateManyWithoutSubbrandNestedInput
    sales?: saleUpdateManyWithoutSubbrandNestedInput
  }

  export type subbrandUncheckedUpdateWithoutCustomersInput = {
    id?: IntFieldUpdateOperationsInput | number
    brand_id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stores?: storeUncheckedUpdateManyWithoutSubbrandNestedInput
    categories?: categoryUncheckedUpdateManyWithoutSubbrandNestedInput
    products?: productUncheckedUpdateManyWithoutSubbrandNestedInput
    optiongroups?: optiongroupUncheckedUpdateManyWithoutSubbrandNestedInput
    items?: itemUncheckedUpdateManyWithoutSubbrandNestedInput
    sales?: saleUncheckedUpdateManyWithoutSubbrandNestedInput
  }

  export type saleUpsertWithWhereUniqueWithoutCustomerInput = {
    where: saleWhereUniqueInput
    update: XOR<saleUpdateWithoutCustomerInput, saleUncheckedUpdateWithoutCustomerInput>
    create: XOR<saleCreateWithoutCustomerInput, saleUncheckedCreateWithoutCustomerInput>
  }

  export type saleUpdateWithWhereUniqueWithoutCustomerInput = {
    where: saleWhereUniqueInput
    data: XOR<saleUpdateWithoutCustomerInput, saleUncheckedUpdateWithoutCustomerInput>
  }

  export type saleUpdateManyWithWhereWithoutCustomerInput = {
    where: saleScalarWhereInput
    data: XOR<saleUpdateManyMutationInput, saleUncheckedUpdateManyWithoutCustomerInput>
  }

  export type storeCreateWithoutSalesInput = {
    name: string
    city?: string | null
    state?: string | null
    district?: string | null
    address_street?: string | null
    address_number?: number | null
    zipcode?: string | null
    latitude?: Decimal | DecimalJsLike | number | string | null
    longitude?: Decimal | DecimalJsLike | number | string | null
    is_active?: boolean | null
    is_own?: boolean | null
    is_holding?: boolean | null
    creation_date?: Date | string | null
    created_at?: Date | string | null
    brand: brandCreateNestedOneWithoutStoresInput
    subbrand?: subbrandCreateNestedOneWithoutStoresInput
    customers?: customerCreateNestedManyWithoutStoreInput
  }

  export type storeUncheckedCreateWithoutSalesInput = {
    id?: number
    brand_id: number
    sub_brand_id?: number | null
    name: string
    city?: string | null
    state?: string | null
    district?: string | null
    address_street?: string | null
    address_number?: number | null
    zipcode?: string | null
    latitude?: Decimal | DecimalJsLike | number | string | null
    longitude?: Decimal | DecimalJsLike | number | string | null
    is_active?: boolean | null
    is_own?: boolean | null
    is_holding?: boolean | null
    creation_date?: Date | string | null
    created_at?: Date | string | null
    customers?: customerUncheckedCreateNestedManyWithoutStoreInput
  }

  export type storeCreateOrConnectWithoutSalesInput = {
    where: storeWhereUniqueInput
    create: XOR<storeCreateWithoutSalesInput, storeUncheckedCreateWithoutSalesInput>
  }

  export type subbrandCreateWithoutSalesInput = {
    name: string
    created_at?: Date | string | null
    brand: brandCreateNestedOneWithoutSubbrandsInput
    stores?: storeCreateNestedManyWithoutSubbrandInput
    categories?: categoryCreateNestedManyWithoutSubbrandInput
    products?: productCreateNestedManyWithoutSubbrandInput
    optiongroups?: optiongroupCreateNestedManyWithoutSubbrandInput
    items?: itemCreateNestedManyWithoutSubbrandInput
    customers?: customerCreateNestedManyWithoutSubbrandInput
  }

  export type subbrandUncheckedCreateWithoutSalesInput = {
    id?: number
    brand_id: number
    name: string
    created_at?: Date | string | null
    stores?: storeUncheckedCreateNestedManyWithoutSubbrandInput
    categories?: categoryUncheckedCreateNestedManyWithoutSubbrandInput
    products?: productUncheckedCreateNestedManyWithoutSubbrandInput
    optiongroups?: optiongroupUncheckedCreateNestedManyWithoutSubbrandInput
    items?: itemUncheckedCreateNestedManyWithoutSubbrandInput
    customers?: customerUncheckedCreateNestedManyWithoutSubbrandInput
  }

  export type subbrandCreateOrConnectWithoutSalesInput = {
    where: subbrandWhereUniqueInput
    create: XOR<subbrandCreateWithoutSalesInput, subbrandUncheckedCreateWithoutSalesInput>
  }

  export type customerCreateWithoutSalesInput = {
    customer_name?: string | null
    email?: string | null
    phone_number?: string | null
    cpf?: string | null
    birth_date?: Date | string | null
    gender?: string | null
    registration_origin?: string | null
    agree_terms?: boolean | null
    receive_promotions_email?: boolean | null
    receive_promotions_sms?: boolean | null
    created_at?: Date | string | null
    store?: storeCreateNestedOneWithoutCustomersInput
    subbrand?: subbrandCreateNestedOneWithoutCustomersInput
  }

  export type customerUncheckedCreateWithoutSalesInput = {
    id?: number
    customer_name?: string | null
    email?: string | null
    phone_number?: string | null
    cpf?: string | null
    birth_date?: Date | string | null
    gender?: string | null
    store_id?: number | null
    sub_brand_id?: number | null
    registration_origin?: string | null
    agree_terms?: boolean | null
    receive_promotions_email?: boolean | null
    receive_promotions_sms?: boolean | null
    created_at?: Date | string | null
  }

  export type customerCreateOrConnectWithoutSalesInput = {
    where: customerWhereUniqueInput
    create: XOR<customerCreateWithoutSalesInput, customerUncheckedCreateWithoutSalesInput>
  }

  export type channelCreateWithoutSalesInput = {
    name: string
    description?: string | null
    type?: string | null
    created_at?: Date | string | null
    brand: brandCreateNestedOneWithoutChannelsInput
  }

  export type channelUncheckedCreateWithoutSalesInput = {
    id?: number
    brand_id: number
    name: string
    description?: string | null
    type?: string | null
    created_at?: Date | string | null
  }

  export type channelCreateOrConnectWithoutSalesInput = {
    where: channelWhereUniqueInput
    create: XOR<channelCreateWithoutSalesInput, channelUncheckedCreateWithoutSalesInput>
  }

  export type productsaleCreateWithoutSaleInput = {
    quantity: number
    base_price: number
    total_price: number
    observations?: string | null
    product: productCreateNestedOneWithoutProductsalesInput
    itemproductsales?: itemproductsaleCreateNestedManyWithoutProductsaleInput
  }

  export type productsaleUncheckedCreateWithoutSaleInput = {
    id?: number
    product_id: number
    quantity: number
    base_price: number
    total_price: number
    observations?: string | null
    itemproductsales?: itemproductsaleUncheckedCreateNestedManyWithoutProductsaleInput
  }

  export type productsaleCreateOrConnectWithoutSaleInput = {
    where: productsaleWhereUniqueInput
    create: XOR<productsaleCreateWithoutSaleInput, productsaleUncheckedCreateWithoutSaleInput>
  }

  export type productsaleCreateManySaleInputEnvelope = {
    data: productsaleCreateManySaleInput | productsaleCreateManySaleInput[]
    skipDuplicates?: boolean
  }

  export type deliverysaleCreateWithoutSaleInput = {
    courier_id?: string | null
    courier_name?: string | null
    courier_phone?: string | null
    courier_type?: string | null
    delivered_by?: string | null
    delivery_type?: string | null
    status?: string | null
    delivery_fee?: number | null
    courier_fee?: number | null
    timing?: string | null
    mode?: string | null
    deliveryaddresses?: deliveryaddressCreateNestedManyWithoutDeliverysaleInput
  }

  export type deliverysaleUncheckedCreateWithoutSaleInput = {
    id?: number
    courier_id?: string | null
    courier_name?: string | null
    courier_phone?: string | null
    courier_type?: string | null
    delivered_by?: string | null
    delivery_type?: string | null
    status?: string | null
    delivery_fee?: number | null
    courier_fee?: number | null
    timing?: string | null
    mode?: string | null
    deliveryaddresses?: deliveryaddressUncheckedCreateNestedManyWithoutDeliverysaleInput
  }

  export type deliverysaleCreateOrConnectWithoutSaleInput = {
    where: deliverysaleWhereUniqueInput
    create: XOR<deliverysaleCreateWithoutSaleInput, deliverysaleUncheckedCreateWithoutSaleInput>
  }

  export type deliverysaleCreateManySaleInputEnvelope = {
    data: deliverysaleCreateManySaleInput | deliverysaleCreateManySaleInput[]
    skipDuplicates?: boolean
  }

  export type deliveryaddressCreateWithoutSaleInput = {
    street?: string | null
    number?: string | null
    complement?: string | null
    formatted_address?: string | null
    neighborhood?: string | null
    city?: string | null
    state?: string | null
    country?: string | null
    postal_code?: string | null
    reference?: string | null
    latitude?: number | null
    longitude?: number | null
    deliverysale?: deliverysaleCreateNestedOneWithoutDeliveryaddressesInput
  }

  export type deliveryaddressUncheckedCreateWithoutSaleInput = {
    id?: number
    delivery_sale_id?: number | null
    street?: string | null
    number?: string | null
    complement?: string | null
    formatted_address?: string | null
    neighborhood?: string | null
    city?: string | null
    state?: string | null
    country?: string | null
    postal_code?: string | null
    reference?: string | null
    latitude?: number | null
    longitude?: number | null
  }

  export type deliveryaddressCreateOrConnectWithoutSaleInput = {
    where: deliveryaddressWhereUniqueInput
    create: XOR<deliveryaddressCreateWithoutSaleInput, deliveryaddressUncheckedCreateWithoutSaleInput>
  }

  export type deliveryaddressCreateManySaleInputEnvelope = {
    data: deliveryaddressCreateManySaleInput | deliveryaddressCreateManySaleInput[]
    skipDuplicates?: boolean
  }

  export type paymentCreateWithoutSaleInput = {
    value: Decimal | DecimalJsLike | number | string
    is_online?: boolean | null
    description?: string | null
    currency?: string | null
    paymenttype?: paymenttypeCreateNestedOneWithoutPaymentsInput
  }

  export type paymentUncheckedCreateWithoutSaleInput = {
    id?: number
    payment_type_id?: number | null
    value: Decimal | DecimalJsLike | number | string
    is_online?: boolean | null
    description?: string | null
    currency?: string | null
  }

  export type paymentCreateOrConnectWithoutSaleInput = {
    where: paymentWhereUniqueInput
    create: XOR<paymentCreateWithoutSaleInput, paymentUncheckedCreateWithoutSaleInput>
  }

  export type paymentCreateManySaleInputEnvelope = {
    data: paymentCreateManySaleInput | paymentCreateManySaleInput[]
    skipDuplicates?: boolean
  }

  export type couponsaleCreateWithoutSaleInput = {
    value?: number | null
    target?: string | null
    sponsorship?: string | null
    coupon?: couponCreateNestedOneWithoutCouponsalesInput
  }

  export type couponsaleUncheckedCreateWithoutSaleInput = {
    id?: number
    coupon_id?: number | null
    value?: number | null
    target?: string | null
    sponsorship?: string | null
  }

  export type couponsaleCreateOrConnectWithoutSaleInput = {
    where: couponsaleWhereUniqueInput
    create: XOR<couponsaleCreateWithoutSaleInput, couponsaleUncheckedCreateWithoutSaleInput>
  }

  export type couponsaleCreateManySaleInputEnvelope = {
    data: couponsaleCreateManySaleInput | couponsaleCreateManySaleInput[]
    skipDuplicates?: boolean
  }

  export type storeUpsertWithoutSalesInput = {
    update: XOR<storeUpdateWithoutSalesInput, storeUncheckedUpdateWithoutSalesInput>
    create: XOR<storeCreateWithoutSalesInput, storeUncheckedCreateWithoutSalesInput>
    where?: storeWhereInput
  }

  export type storeUpdateToOneWithWhereWithoutSalesInput = {
    where?: storeWhereInput
    data: XOR<storeUpdateWithoutSalesInput, storeUncheckedUpdateWithoutSalesInput>
  }

  export type storeUpdateWithoutSalesInput = {
    name?: StringFieldUpdateOperationsInput | string
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    district?: NullableStringFieldUpdateOperationsInput | string | null
    address_street?: NullableStringFieldUpdateOperationsInput | string | null
    address_number?: NullableIntFieldUpdateOperationsInput | number | null
    zipcode?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    longitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_own?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_holding?: NullableBoolFieldUpdateOperationsInput | boolean | null
    creation_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    brand?: brandUpdateOneRequiredWithoutStoresNestedInput
    subbrand?: subbrandUpdateOneWithoutStoresNestedInput
    customers?: customerUpdateManyWithoutStoreNestedInput
  }

  export type storeUncheckedUpdateWithoutSalesInput = {
    id?: IntFieldUpdateOperationsInput | number
    brand_id?: IntFieldUpdateOperationsInput | number
    sub_brand_id?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    district?: NullableStringFieldUpdateOperationsInput | string | null
    address_street?: NullableStringFieldUpdateOperationsInput | string | null
    address_number?: NullableIntFieldUpdateOperationsInput | number | null
    zipcode?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    longitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_own?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_holding?: NullableBoolFieldUpdateOperationsInput | boolean | null
    creation_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    customers?: customerUncheckedUpdateManyWithoutStoreNestedInput
  }

  export type subbrandUpsertWithoutSalesInput = {
    update: XOR<subbrandUpdateWithoutSalesInput, subbrandUncheckedUpdateWithoutSalesInput>
    create: XOR<subbrandCreateWithoutSalesInput, subbrandUncheckedCreateWithoutSalesInput>
    where?: subbrandWhereInput
  }

  export type subbrandUpdateToOneWithWhereWithoutSalesInput = {
    where?: subbrandWhereInput
    data: XOR<subbrandUpdateWithoutSalesInput, subbrandUncheckedUpdateWithoutSalesInput>
  }

  export type subbrandUpdateWithoutSalesInput = {
    name?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    brand?: brandUpdateOneRequiredWithoutSubbrandsNestedInput
    stores?: storeUpdateManyWithoutSubbrandNestedInput
    categories?: categoryUpdateManyWithoutSubbrandNestedInput
    products?: productUpdateManyWithoutSubbrandNestedInput
    optiongroups?: optiongroupUpdateManyWithoutSubbrandNestedInput
    items?: itemUpdateManyWithoutSubbrandNestedInput
    customers?: customerUpdateManyWithoutSubbrandNestedInput
  }

  export type subbrandUncheckedUpdateWithoutSalesInput = {
    id?: IntFieldUpdateOperationsInput | number
    brand_id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stores?: storeUncheckedUpdateManyWithoutSubbrandNestedInput
    categories?: categoryUncheckedUpdateManyWithoutSubbrandNestedInput
    products?: productUncheckedUpdateManyWithoutSubbrandNestedInput
    optiongroups?: optiongroupUncheckedUpdateManyWithoutSubbrandNestedInput
    items?: itemUncheckedUpdateManyWithoutSubbrandNestedInput
    customers?: customerUncheckedUpdateManyWithoutSubbrandNestedInput
  }

  export type customerUpsertWithoutSalesInput = {
    update: XOR<customerUpdateWithoutSalesInput, customerUncheckedUpdateWithoutSalesInput>
    create: XOR<customerCreateWithoutSalesInput, customerUncheckedCreateWithoutSalesInput>
    where?: customerWhereInput
  }

  export type customerUpdateToOneWithWhereWithoutSalesInput = {
    where?: customerWhereInput
    data: XOR<customerUpdateWithoutSalesInput, customerUncheckedUpdateWithoutSalesInput>
  }

  export type customerUpdateWithoutSalesInput = {
    customer_name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    cpf?: NullableStringFieldUpdateOperationsInput | string | null
    birth_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    registration_origin?: NullableStringFieldUpdateOperationsInput | string | null
    agree_terms?: NullableBoolFieldUpdateOperationsInput | boolean | null
    receive_promotions_email?: NullableBoolFieldUpdateOperationsInput | boolean | null
    receive_promotions_sms?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    store?: storeUpdateOneWithoutCustomersNestedInput
    subbrand?: subbrandUpdateOneWithoutCustomersNestedInput
  }

  export type customerUncheckedUpdateWithoutSalesInput = {
    id?: IntFieldUpdateOperationsInput | number
    customer_name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    cpf?: NullableStringFieldUpdateOperationsInput | string | null
    birth_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    store_id?: NullableIntFieldUpdateOperationsInput | number | null
    sub_brand_id?: NullableIntFieldUpdateOperationsInput | number | null
    registration_origin?: NullableStringFieldUpdateOperationsInput | string | null
    agree_terms?: NullableBoolFieldUpdateOperationsInput | boolean | null
    receive_promotions_email?: NullableBoolFieldUpdateOperationsInput | boolean | null
    receive_promotions_sms?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type channelUpsertWithoutSalesInput = {
    update: XOR<channelUpdateWithoutSalesInput, channelUncheckedUpdateWithoutSalesInput>
    create: XOR<channelCreateWithoutSalesInput, channelUncheckedCreateWithoutSalesInput>
    where?: channelWhereInput
  }

  export type channelUpdateToOneWithWhereWithoutSalesInput = {
    where?: channelWhereInput
    data: XOR<channelUpdateWithoutSalesInput, channelUncheckedUpdateWithoutSalesInput>
  }

  export type channelUpdateWithoutSalesInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    brand?: brandUpdateOneRequiredWithoutChannelsNestedInput
  }

  export type channelUncheckedUpdateWithoutSalesInput = {
    id?: IntFieldUpdateOperationsInput | number
    brand_id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type productsaleUpsertWithWhereUniqueWithoutSaleInput = {
    where: productsaleWhereUniqueInput
    update: XOR<productsaleUpdateWithoutSaleInput, productsaleUncheckedUpdateWithoutSaleInput>
    create: XOR<productsaleCreateWithoutSaleInput, productsaleUncheckedCreateWithoutSaleInput>
  }

  export type productsaleUpdateWithWhereUniqueWithoutSaleInput = {
    where: productsaleWhereUniqueInput
    data: XOR<productsaleUpdateWithoutSaleInput, productsaleUncheckedUpdateWithoutSaleInput>
  }

  export type productsaleUpdateManyWithWhereWithoutSaleInput = {
    where: productsaleScalarWhereInput
    data: XOR<productsaleUpdateManyMutationInput, productsaleUncheckedUpdateManyWithoutSaleInput>
  }

  export type deliverysaleUpsertWithWhereUniqueWithoutSaleInput = {
    where: deliverysaleWhereUniqueInput
    update: XOR<deliverysaleUpdateWithoutSaleInput, deliverysaleUncheckedUpdateWithoutSaleInput>
    create: XOR<deliverysaleCreateWithoutSaleInput, deliverysaleUncheckedCreateWithoutSaleInput>
  }

  export type deliverysaleUpdateWithWhereUniqueWithoutSaleInput = {
    where: deliverysaleWhereUniqueInput
    data: XOR<deliverysaleUpdateWithoutSaleInput, deliverysaleUncheckedUpdateWithoutSaleInput>
  }

  export type deliverysaleUpdateManyWithWhereWithoutSaleInput = {
    where: deliverysaleScalarWhereInput
    data: XOR<deliverysaleUpdateManyMutationInput, deliverysaleUncheckedUpdateManyWithoutSaleInput>
  }

  export type deliverysaleScalarWhereInput = {
    AND?: deliverysaleScalarWhereInput | deliverysaleScalarWhereInput[]
    OR?: deliverysaleScalarWhereInput[]
    NOT?: deliverysaleScalarWhereInput | deliverysaleScalarWhereInput[]
    id?: IntFilter<"deliverysale"> | number
    sale_id?: IntFilter<"deliverysale"> | number
    courier_id?: StringNullableFilter<"deliverysale"> | string | null
    courier_name?: StringNullableFilter<"deliverysale"> | string | null
    courier_phone?: StringNullableFilter<"deliverysale"> | string | null
    courier_type?: StringNullableFilter<"deliverysale"> | string | null
    delivered_by?: StringNullableFilter<"deliverysale"> | string | null
    delivery_type?: StringNullableFilter<"deliverysale"> | string | null
    status?: StringNullableFilter<"deliverysale"> | string | null
    delivery_fee?: FloatNullableFilter<"deliverysale"> | number | null
    courier_fee?: FloatNullableFilter<"deliverysale"> | number | null
    timing?: StringNullableFilter<"deliverysale"> | string | null
    mode?: StringNullableFilter<"deliverysale"> | string | null
  }

  export type deliveryaddressUpsertWithWhereUniqueWithoutSaleInput = {
    where: deliveryaddressWhereUniqueInput
    update: XOR<deliveryaddressUpdateWithoutSaleInput, deliveryaddressUncheckedUpdateWithoutSaleInput>
    create: XOR<deliveryaddressCreateWithoutSaleInput, deliveryaddressUncheckedCreateWithoutSaleInput>
  }

  export type deliveryaddressUpdateWithWhereUniqueWithoutSaleInput = {
    where: deliveryaddressWhereUniqueInput
    data: XOR<deliveryaddressUpdateWithoutSaleInput, deliveryaddressUncheckedUpdateWithoutSaleInput>
  }

  export type deliveryaddressUpdateManyWithWhereWithoutSaleInput = {
    where: deliveryaddressScalarWhereInput
    data: XOR<deliveryaddressUpdateManyMutationInput, deliveryaddressUncheckedUpdateManyWithoutSaleInput>
  }

  export type deliveryaddressScalarWhereInput = {
    AND?: deliveryaddressScalarWhereInput | deliveryaddressScalarWhereInput[]
    OR?: deliveryaddressScalarWhereInput[]
    NOT?: deliveryaddressScalarWhereInput | deliveryaddressScalarWhereInput[]
    id?: IntFilter<"deliveryaddress"> | number
    sale_id?: IntFilter<"deliveryaddress"> | number
    delivery_sale_id?: IntNullableFilter<"deliveryaddress"> | number | null
    street?: StringNullableFilter<"deliveryaddress"> | string | null
    number?: StringNullableFilter<"deliveryaddress"> | string | null
    complement?: StringNullableFilter<"deliveryaddress"> | string | null
    formatted_address?: StringNullableFilter<"deliveryaddress"> | string | null
    neighborhood?: StringNullableFilter<"deliveryaddress"> | string | null
    city?: StringNullableFilter<"deliveryaddress"> | string | null
    state?: StringNullableFilter<"deliveryaddress"> | string | null
    country?: StringNullableFilter<"deliveryaddress"> | string | null
    postal_code?: StringNullableFilter<"deliveryaddress"> | string | null
    reference?: StringNullableFilter<"deliveryaddress"> | string | null
    latitude?: FloatNullableFilter<"deliveryaddress"> | number | null
    longitude?: FloatNullableFilter<"deliveryaddress"> | number | null
  }

  export type paymentUpsertWithWhereUniqueWithoutSaleInput = {
    where: paymentWhereUniqueInput
    update: XOR<paymentUpdateWithoutSaleInput, paymentUncheckedUpdateWithoutSaleInput>
    create: XOR<paymentCreateWithoutSaleInput, paymentUncheckedCreateWithoutSaleInput>
  }

  export type paymentUpdateWithWhereUniqueWithoutSaleInput = {
    where: paymentWhereUniqueInput
    data: XOR<paymentUpdateWithoutSaleInput, paymentUncheckedUpdateWithoutSaleInput>
  }

  export type paymentUpdateManyWithWhereWithoutSaleInput = {
    where: paymentScalarWhereInput
    data: XOR<paymentUpdateManyMutationInput, paymentUncheckedUpdateManyWithoutSaleInput>
  }

  export type paymentScalarWhereInput = {
    AND?: paymentScalarWhereInput | paymentScalarWhereInput[]
    OR?: paymentScalarWhereInput[]
    NOT?: paymentScalarWhereInput | paymentScalarWhereInput[]
    id?: IntFilter<"payment"> | number
    sale_id?: IntFilter<"payment"> | number
    payment_type_id?: IntNullableFilter<"payment"> | number | null
    value?: DecimalFilter<"payment"> | Decimal | DecimalJsLike | number | string
    is_online?: BoolNullableFilter<"payment"> | boolean | null
    description?: StringNullableFilter<"payment"> | string | null
    currency?: StringNullableFilter<"payment"> | string | null
  }

  export type couponsaleUpsertWithWhereUniqueWithoutSaleInput = {
    where: couponsaleWhereUniqueInput
    update: XOR<couponsaleUpdateWithoutSaleInput, couponsaleUncheckedUpdateWithoutSaleInput>
    create: XOR<couponsaleCreateWithoutSaleInput, couponsaleUncheckedCreateWithoutSaleInput>
  }

  export type couponsaleUpdateWithWhereUniqueWithoutSaleInput = {
    where: couponsaleWhereUniqueInput
    data: XOR<couponsaleUpdateWithoutSaleInput, couponsaleUncheckedUpdateWithoutSaleInput>
  }

  export type couponsaleUpdateManyWithWhereWithoutSaleInput = {
    where: couponsaleScalarWhereInput
    data: XOR<couponsaleUpdateManyMutationInput, couponsaleUncheckedUpdateManyWithoutSaleInput>
  }

  export type couponsaleScalarWhereInput = {
    AND?: couponsaleScalarWhereInput | couponsaleScalarWhereInput[]
    OR?: couponsaleScalarWhereInput[]
    NOT?: couponsaleScalarWhereInput | couponsaleScalarWhereInput[]
    id?: IntFilter<"couponsale"> | number
    sale_id?: IntNullableFilter<"couponsale"> | number | null
    coupon_id?: IntNullableFilter<"couponsale"> | number | null
    value?: FloatNullableFilter<"couponsale"> | number | null
    target?: StringNullableFilter<"couponsale"> | string | null
    sponsorship?: StringNullableFilter<"couponsale"> | string | null
  }

  export type saleCreateWithoutProductsalesInput = {
    cod_sale1?: string | null
    cod_sale2?: string | null
    created_at: Date | string
    customer_name?: string | null
    sale_status_desc: string
    total_amount_items: Decimal | DecimalJsLike | number | string
    total_discount?: Decimal | DecimalJsLike | number | string | null
    total_increase?: Decimal | DecimalJsLike | number | string | null
    delivery_fee?: Decimal | DecimalJsLike | number | string | null
    service_tax_fee?: Decimal | DecimalJsLike | number | string | null
    total_amount: Decimal | DecimalJsLike | number | string
    value_paid?: Decimal | DecimalJsLike | number | string | null
    production_seconds?: number | null
    delivery_seconds?: number | null
    people_quantity?: number | null
    discount_reason?: string | null
    increase_reason?: string | null
    origin?: string | null
    store: storeCreateNestedOneWithoutSalesInput
    subbrand?: subbrandCreateNestedOneWithoutSalesInput
    customer?: customerCreateNestedOneWithoutSalesInput
    channel: channelCreateNestedOneWithoutSalesInput
    deliverysales?: deliverysaleCreateNestedManyWithoutSaleInput
    deliveryaddress?: deliveryaddressCreateNestedManyWithoutSaleInput
    payments?: paymentCreateNestedManyWithoutSaleInput
    couponsales?: couponsaleCreateNestedManyWithoutSaleInput
  }

  export type saleUncheckedCreateWithoutProductsalesInput = {
    id?: number
    store_id: number
    sub_brand_id?: number | null
    customer_id?: number | null
    channel_id: number
    cod_sale1?: string | null
    cod_sale2?: string | null
    created_at: Date | string
    customer_name?: string | null
    sale_status_desc: string
    total_amount_items: Decimal | DecimalJsLike | number | string
    total_discount?: Decimal | DecimalJsLike | number | string | null
    total_increase?: Decimal | DecimalJsLike | number | string | null
    delivery_fee?: Decimal | DecimalJsLike | number | string | null
    service_tax_fee?: Decimal | DecimalJsLike | number | string | null
    total_amount: Decimal | DecimalJsLike | number | string
    value_paid?: Decimal | DecimalJsLike | number | string | null
    production_seconds?: number | null
    delivery_seconds?: number | null
    people_quantity?: number | null
    discount_reason?: string | null
    increase_reason?: string | null
    origin?: string | null
    deliverysales?: deliverysaleUncheckedCreateNestedManyWithoutSaleInput
    deliveryaddress?: deliveryaddressUncheckedCreateNestedManyWithoutSaleInput
    payments?: paymentUncheckedCreateNestedManyWithoutSaleInput
    couponsales?: couponsaleUncheckedCreateNestedManyWithoutSaleInput
  }

  export type saleCreateOrConnectWithoutProductsalesInput = {
    where: saleWhereUniqueInput
    create: XOR<saleCreateWithoutProductsalesInput, saleUncheckedCreateWithoutProductsalesInput>
  }

  export type productCreateWithoutProductsalesInput = {
    name: string
    pos_uuid?: string | null
    deleted_at?: Date | string | null
    brand: brandCreateNestedOneWithoutProductsInput
    subbrand?: subbrandCreateNestedOneWithoutProductsInput
    category?: categoryCreateNestedOneWithoutProductsInput
  }

  export type productUncheckedCreateWithoutProductsalesInput = {
    id?: number
    brand_id: number
    sub_brand_id?: number | null
    category_id?: number | null
    name: string
    pos_uuid?: string | null
    deleted_at?: Date | string | null
  }

  export type productCreateOrConnectWithoutProductsalesInput = {
    where: productWhereUniqueInput
    create: XOR<productCreateWithoutProductsalesInput, productUncheckedCreateWithoutProductsalesInput>
  }

  export type itemproductsaleCreateWithoutProductsaleInput = {
    quantity: number
    additional_price: number
    price: number
    amount?: number | null
    observations?: string | null
    item: itemCreateNestedOneWithoutItemproductsalesInput
    optiongroup?: optiongroupCreateNestedOneWithoutItemproductsalesInput
    itemitemproductsales?: itemitemproductsaleCreateNestedManyWithoutItemproductsaleInput
  }

  export type itemproductsaleUncheckedCreateWithoutProductsaleInput = {
    id?: number
    item_id: number
    option_group_id?: number | null
    quantity: number
    additional_price: number
    price: number
    amount?: number | null
    observations?: string | null
    itemitemproductsales?: itemitemproductsaleUncheckedCreateNestedManyWithoutItemproductsaleInput
  }

  export type itemproductsaleCreateOrConnectWithoutProductsaleInput = {
    where: itemproductsaleWhereUniqueInput
    create: XOR<itemproductsaleCreateWithoutProductsaleInput, itemproductsaleUncheckedCreateWithoutProductsaleInput>
  }

  export type itemproductsaleCreateManyProductsaleInputEnvelope = {
    data: itemproductsaleCreateManyProductsaleInput | itemproductsaleCreateManyProductsaleInput[]
    skipDuplicates?: boolean
  }

  export type saleUpsertWithoutProductsalesInput = {
    update: XOR<saleUpdateWithoutProductsalesInput, saleUncheckedUpdateWithoutProductsalesInput>
    create: XOR<saleCreateWithoutProductsalesInput, saleUncheckedCreateWithoutProductsalesInput>
    where?: saleWhereInput
  }

  export type saleUpdateToOneWithWhereWithoutProductsalesInput = {
    where?: saleWhereInput
    data: XOR<saleUpdateWithoutProductsalesInput, saleUncheckedUpdateWithoutProductsalesInput>
  }

  export type saleUpdateWithoutProductsalesInput = {
    cod_sale1?: NullableStringFieldUpdateOperationsInput | string | null
    cod_sale2?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    customer_name?: NullableStringFieldUpdateOperationsInput | string | null
    sale_status_desc?: StringFieldUpdateOperationsInput | string
    total_amount_items?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total_discount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    total_increase?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    delivery_fee?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    service_tax_fee?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    total_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    value_paid?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    production_seconds?: NullableIntFieldUpdateOperationsInput | number | null
    delivery_seconds?: NullableIntFieldUpdateOperationsInput | number | null
    people_quantity?: NullableIntFieldUpdateOperationsInput | number | null
    discount_reason?: NullableStringFieldUpdateOperationsInput | string | null
    increase_reason?: NullableStringFieldUpdateOperationsInput | string | null
    origin?: NullableStringFieldUpdateOperationsInput | string | null
    store?: storeUpdateOneRequiredWithoutSalesNestedInput
    subbrand?: subbrandUpdateOneWithoutSalesNestedInput
    customer?: customerUpdateOneWithoutSalesNestedInput
    channel?: channelUpdateOneRequiredWithoutSalesNestedInput
    deliverysales?: deliverysaleUpdateManyWithoutSaleNestedInput
    deliveryaddress?: deliveryaddressUpdateManyWithoutSaleNestedInput
    payments?: paymentUpdateManyWithoutSaleNestedInput
    couponsales?: couponsaleUpdateManyWithoutSaleNestedInput
  }

  export type saleUncheckedUpdateWithoutProductsalesInput = {
    id?: IntFieldUpdateOperationsInput | number
    store_id?: IntFieldUpdateOperationsInput | number
    sub_brand_id?: NullableIntFieldUpdateOperationsInput | number | null
    customer_id?: NullableIntFieldUpdateOperationsInput | number | null
    channel_id?: IntFieldUpdateOperationsInput | number
    cod_sale1?: NullableStringFieldUpdateOperationsInput | string | null
    cod_sale2?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    customer_name?: NullableStringFieldUpdateOperationsInput | string | null
    sale_status_desc?: StringFieldUpdateOperationsInput | string
    total_amount_items?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total_discount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    total_increase?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    delivery_fee?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    service_tax_fee?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    total_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    value_paid?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    production_seconds?: NullableIntFieldUpdateOperationsInput | number | null
    delivery_seconds?: NullableIntFieldUpdateOperationsInput | number | null
    people_quantity?: NullableIntFieldUpdateOperationsInput | number | null
    discount_reason?: NullableStringFieldUpdateOperationsInput | string | null
    increase_reason?: NullableStringFieldUpdateOperationsInput | string | null
    origin?: NullableStringFieldUpdateOperationsInput | string | null
    deliverysales?: deliverysaleUncheckedUpdateManyWithoutSaleNestedInput
    deliveryaddress?: deliveryaddressUncheckedUpdateManyWithoutSaleNestedInput
    payments?: paymentUncheckedUpdateManyWithoutSaleNestedInput
    couponsales?: couponsaleUncheckedUpdateManyWithoutSaleNestedInput
  }

  export type productUpsertWithoutProductsalesInput = {
    update: XOR<productUpdateWithoutProductsalesInput, productUncheckedUpdateWithoutProductsalesInput>
    create: XOR<productCreateWithoutProductsalesInput, productUncheckedCreateWithoutProductsalesInput>
    where?: productWhereInput
  }

  export type productUpdateToOneWithWhereWithoutProductsalesInput = {
    where?: productWhereInput
    data: XOR<productUpdateWithoutProductsalesInput, productUncheckedUpdateWithoutProductsalesInput>
  }

  export type productUpdateWithoutProductsalesInput = {
    name?: StringFieldUpdateOperationsInput | string
    pos_uuid?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    brand?: brandUpdateOneRequiredWithoutProductsNestedInput
    subbrand?: subbrandUpdateOneWithoutProductsNestedInput
    category?: categoryUpdateOneWithoutProductsNestedInput
  }

  export type productUncheckedUpdateWithoutProductsalesInput = {
    id?: IntFieldUpdateOperationsInput | number
    brand_id?: IntFieldUpdateOperationsInput | number
    sub_brand_id?: NullableIntFieldUpdateOperationsInput | number | null
    category_id?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    pos_uuid?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type itemproductsaleUpsertWithWhereUniqueWithoutProductsaleInput = {
    where: itemproductsaleWhereUniqueInput
    update: XOR<itemproductsaleUpdateWithoutProductsaleInput, itemproductsaleUncheckedUpdateWithoutProductsaleInput>
    create: XOR<itemproductsaleCreateWithoutProductsaleInput, itemproductsaleUncheckedCreateWithoutProductsaleInput>
  }

  export type itemproductsaleUpdateWithWhereUniqueWithoutProductsaleInput = {
    where: itemproductsaleWhereUniqueInput
    data: XOR<itemproductsaleUpdateWithoutProductsaleInput, itemproductsaleUncheckedUpdateWithoutProductsaleInput>
  }

  export type itemproductsaleUpdateManyWithWhereWithoutProductsaleInput = {
    where: itemproductsaleScalarWhereInput
    data: XOR<itemproductsaleUpdateManyMutationInput, itemproductsaleUncheckedUpdateManyWithoutProductsaleInput>
  }

  export type productsaleCreateWithoutItemproductsalesInput = {
    quantity: number
    base_price: number
    total_price: number
    observations?: string | null
    sale: saleCreateNestedOneWithoutProductsalesInput
    product: productCreateNestedOneWithoutProductsalesInput
  }

  export type productsaleUncheckedCreateWithoutItemproductsalesInput = {
    id?: number
    sale_id: number
    product_id: number
    quantity: number
    base_price: number
    total_price: number
    observations?: string | null
  }

  export type productsaleCreateOrConnectWithoutItemproductsalesInput = {
    where: productsaleWhereUniqueInput
    create: XOR<productsaleCreateWithoutItemproductsalesInput, productsaleUncheckedCreateWithoutItemproductsalesInput>
  }

  export type itemCreateWithoutItemproductsalesInput = {
    name: string
    pos_uuid?: string | null
    deleted_at?: Date | string | null
    brand: brandCreateNestedOneWithoutItemsInput
    subbrand?: subbrandCreateNestedOneWithoutItemsInput
    category?: categoryCreateNestedOneWithoutItemsInput
    itemitemproductsales?: itemitemproductsaleCreateNestedManyWithoutItemInput
  }

  export type itemUncheckedCreateWithoutItemproductsalesInput = {
    id?: number
    brand_id: number
    sub_brand_id?: number | null
    category_id?: number | null
    name: string
    pos_uuid?: string | null
    deleted_at?: Date | string | null
    itemitemproductsales?: itemitemproductsaleUncheckedCreateNestedManyWithoutItemInput
  }

  export type itemCreateOrConnectWithoutItemproductsalesInput = {
    where: itemWhereUniqueInput
    create: XOR<itemCreateWithoutItemproductsalesInput, itemUncheckedCreateWithoutItemproductsalesInput>
  }

  export type optiongroupCreateWithoutItemproductsalesInput = {
    name: string
    pos_uuid?: string | null
    deleted_at?: Date | string | null
    brand: brandCreateNestedOneWithoutOptiongroupsInput
    subbrand?: subbrandCreateNestedOneWithoutOptiongroupsInput
    category?: categoryCreateNestedOneWithoutOptiongroupsInput
    itemitemproductsales?: itemitemproductsaleCreateNestedManyWithoutOptiongroupInput
  }

  export type optiongroupUncheckedCreateWithoutItemproductsalesInput = {
    id?: number
    brand_id: number
    sub_brand_id?: number | null
    category_id?: number | null
    name: string
    pos_uuid?: string | null
    deleted_at?: Date | string | null
    itemitemproductsales?: itemitemproductsaleUncheckedCreateNestedManyWithoutOptiongroupInput
  }

  export type optiongroupCreateOrConnectWithoutItemproductsalesInput = {
    where: optiongroupWhereUniqueInput
    create: XOR<optiongroupCreateWithoutItemproductsalesInput, optiongroupUncheckedCreateWithoutItemproductsalesInput>
  }

  export type itemitemproductsaleCreateWithoutItemproductsaleInput = {
    quantity: number
    additional_price: number
    price: number
    amount?: number | null
    item: itemCreateNestedOneWithoutItemitemproductsalesInput
    optiongroup?: optiongroupCreateNestedOneWithoutItemitemproductsalesInput
  }

  export type itemitemproductsaleUncheckedCreateWithoutItemproductsaleInput = {
    id?: number
    item_id: number
    option_group_id?: number | null
    quantity: number
    additional_price: number
    price: number
    amount?: number | null
  }

  export type itemitemproductsaleCreateOrConnectWithoutItemproductsaleInput = {
    where: itemitemproductsaleWhereUniqueInput
    create: XOR<itemitemproductsaleCreateWithoutItemproductsaleInput, itemitemproductsaleUncheckedCreateWithoutItemproductsaleInput>
  }

  export type itemitemproductsaleCreateManyItemproductsaleInputEnvelope = {
    data: itemitemproductsaleCreateManyItemproductsaleInput | itemitemproductsaleCreateManyItemproductsaleInput[]
    skipDuplicates?: boolean
  }

  export type productsaleUpsertWithoutItemproductsalesInput = {
    update: XOR<productsaleUpdateWithoutItemproductsalesInput, productsaleUncheckedUpdateWithoutItemproductsalesInput>
    create: XOR<productsaleCreateWithoutItemproductsalesInput, productsaleUncheckedCreateWithoutItemproductsalesInput>
    where?: productsaleWhereInput
  }

  export type productsaleUpdateToOneWithWhereWithoutItemproductsalesInput = {
    where?: productsaleWhereInput
    data: XOR<productsaleUpdateWithoutItemproductsalesInput, productsaleUncheckedUpdateWithoutItemproductsalesInput>
  }

  export type productsaleUpdateWithoutItemproductsalesInput = {
    quantity?: FloatFieldUpdateOperationsInput | number
    base_price?: FloatFieldUpdateOperationsInput | number
    total_price?: FloatFieldUpdateOperationsInput | number
    observations?: NullableStringFieldUpdateOperationsInput | string | null
    sale?: saleUpdateOneRequiredWithoutProductsalesNestedInput
    product?: productUpdateOneRequiredWithoutProductsalesNestedInput
  }

  export type productsaleUncheckedUpdateWithoutItemproductsalesInput = {
    id?: IntFieldUpdateOperationsInput | number
    sale_id?: IntFieldUpdateOperationsInput | number
    product_id?: IntFieldUpdateOperationsInput | number
    quantity?: FloatFieldUpdateOperationsInput | number
    base_price?: FloatFieldUpdateOperationsInput | number
    total_price?: FloatFieldUpdateOperationsInput | number
    observations?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type itemUpsertWithoutItemproductsalesInput = {
    update: XOR<itemUpdateWithoutItemproductsalesInput, itemUncheckedUpdateWithoutItemproductsalesInput>
    create: XOR<itemCreateWithoutItemproductsalesInput, itemUncheckedCreateWithoutItemproductsalesInput>
    where?: itemWhereInput
  }

  export type itemUpdateToOneWithWhereWithoutItemproductsalesInput = {
    where?: itemWhereInput
    data: XOR<itemUpdateWithoutItemproductsalesInput, itemUncheckedUpdateWithoutItemproductsalesInput>
  }

  export type itemUpdateWithoutItemproductsalesInput = {
    name?: StringFieldUpdateOperationsInput | string
    pos_uuid?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    brand?: brandUpdateOneRequiredWithoutItemsNestedInput
    subbrand?: subbrandUpdateOneWithoutItemsNestedInput
    category?: categoryUpdateOneWithoutItemsNestedInput
    itemitemproductsales?: itemitemproductsaleUpdateManyWithoutItemNestedInput
  }

  export type itemUncheckedUpdateWithoutItemproductsalesInput = {
    id?: IntFieldUpdateOperationsInput | number
    brand_id?: IntFieldUpdateOperationsInput | number
    sub_brand_id?: NullableIntFieldUpdateOperationsInput | number | null
    category_id?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    pos_uuid?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    itemitemproductsales?: itemitemproductsaleUncheckedUpdateManyWithoutItemNestedInput
  }

  export type optiongroupUpsertWithoutItemproductsalesInput = {
    update: XOR<optiongroupUpdateWithoutItemproductsalesInput, optiongroupUncheckedUpdateWithoutItemproductsalesInput>
    create: XOR<optiongroupCreateWithoutItemproductsalesInput, optiongroupUncheckedCreateWithoutItemproductsalesInput>
    where?: optiongroupWhereInput
  }

  export type optiongroupUpdateToOneWithWhereWithoutItemproductsalesInput = {
    where?: optiongroupWhereInput
    data: XOR<optiongroupUpdateWithoutItemproductsalesInput, optiongroupUncheckedUpdateWithoutItemproductsalesInput>
  }

  export type optiongroupUpdateWithoutItemproductsalesInput = {
    name?: StringFieldUpdateOperationsInput | string
    pos_uuid?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    brand?: brandUpdateOneRequiredWithoutOptiongroupsNestedInput
    subbrand?: subbrandUpdateOneWithoutOptiongroupsNestedInput
    category?: categoryUpdateOneWithoutOptiongroupsNestedInput
    itemitemproductsales?: itemitemproductsaleUpdateManyWithoutOptiongroupNestedInput
  }

  export type optiongroupUncheckedUpdateWithoutItemproductsalesInput = {
    id?: IntFieldUpdateOperationsInput | number
    brand_id?: IntFieldUpdateOperationsInput | number
    sub_brand_id?: NullableIntFieldUpdateOperationsInput | number | null
    category_id?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    pos_uuid?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    itemitemproductsales?: itemitemproductsaleUncheckedUpdateManyWithoutOptiongroupNestedInput
  }

  export type itemitemproductsaleUpsertWithWhereUniqueWithoutItemproductsaleInput = {
    where: itemitemproductsaleWhereUniqueInput
    update: XOR<itemitemproductsaleUpdateWithoutItemproductsaleInput, itemitemproductsaleUncheckedUpdateWithoutItemproductsaleInput>
    create: XOR<itemitemproductsaleCreateWithoutItemproductsaleInput, itemitemproductsaleUncheckedCreateWithoutItemproductsaleInput>
  }

  export type itemitemproductsaleUpdateWithWhereUniqueWithoutItemproductsaleInput = {
    where: itemitemproductsaleWhereUniqueInput
    data: XOR<itemitemproductsaleUpdateWithoutItemproductsaleInput, itemitemproductsaleUncheckedUpdateWithoutItemproductsaleInput>
  }

  export type itemitemproductsaleUpdateManyWithWhereWithoutItemproductsaleInput = {
    where: itemitemproductsaleScalarWhereInput
    data: XOR<itemitemproductsaleUpdateManyMutationInput, itemitemproductsaleUncheckedUpdateManyWithoutItemproductsaleInput>
  }

  export type itemproductsaleCreateWithoutItemitemproductsalesInput = {
    quantity: number
    additional_price: number
    price: number
    amount?: number | null
    observations?: string | null
    productsale: productsaleCreateNestedOneWithoutItemproductsalesInput
    item: itemCreateNestedOneWithoutItemproductsalesInput
    optiongroup?: optiongroupCreateNestedOneWithoutItemproductsalesInput
  }

  export type itemproductsaleUncheckedCreateWithoutItemitemproductsalesInput = {
    id?: number
    product_sale_id: number
    item_id: number
    option_group_id?: number | null
    quantity: number
    additional_price: number
    price: number
    amount?: number | null
    observations?: string | null
  }

  export type itemproductsaleCreateOrConnectWithoutItemitemproductsalesInput = {
    where: itemproductsaleWhereUniqueInput
    create: XOR<itemproductsaleCreateWithoutItemitemproductsalesInput, itemproductsaleUncheckedCreateWithoutItemitemproductsalesInput>
  }

  export type itemCreateWithoutItemitemproductsalesInput = {
    name: string
    pos_uuid?: string | null
    deleted_at?: Date | string | null
    brand: brandCreateNestedOneWithoutItemsInput
    subbrand?: subbrandCreateNestedOneWithoutItemsInput
    category?: categoryCreateNestedOneWithoutItemsInput
    itemproductsales?: itemproductsaleCreateNestedManyWithoutItemInput
  }

  export type itemUncheckedCreateWithoutItemitemproductsalesInput = {
    id?: number
    brand_id: number
    sub_brand_id?: number | null
    category_id?: number | null
    name: string
    pos_uuid?: string | null
    deleted_at?: Date | string | null
    itemproductsales?: itemproductsaleUncheckedCreateNestedManyWithoutItemInput
  }

  export type itemCreateOrConnectWithoutItemitemproductsalesInput = {
    where: itemWhereUniqueInput
    create: XOR<itemCreateWithoutItemitemproductsalesInput, itemUncheckedCreateWithoutItemitemproductsalesInput>
  }

  export type optiongroupCreateWithoutItemitemproductsalesInput = {
    name: string
    pos_uuid?: string | null
    deleted_at?: Date | string | null
    brand: brandCreateNestedOneWithoutOptiongroupsInput
    subbrand?: subbrandCreateNestedOneWithoutOptiongroupsInput
    category?: categoryCreateNestedOneWithoutOptiongroupsInput
    itemproductsales?: itemproductsaleCreateNestedManyWithoutOptiongroupInput
  }

  export type optiongroupUncheckedCreateWithoutItemitemproductsalesInput = {
    id?: number
    brand_id: number
    sub_brand_id?: number | null
    category_id?: number | null
    name: string
    pos_uuid?: string | null
    deleted_at?: Date | string | null
    itemproductsales?: itemproductsaleUncheckedCreateNestedManyWithoutOptiongroupInput
  }

  export type optiongroupCreateOrConnectWithoutItemitemproductsalesInput = {
    where: optiongroupWhereUniqueInput
    create: XOR<optiongroupCreateWithoutItemitemproductsalesInput, optiongroupUncheckedCreateWithoutItemitemproductsalesInput>
  }

  export type itemproductsaleUpsertWithoutItemitemproductsalesInput = {
    update: XOR<itemproductsaleUpdateWithoutItemitemproductsalesInput, itemproductsaleUncheckedUpdateWithoutItemitemproductsalesInput>
    create: XOR<itemproductsaleCreateWithoutItemitemproductsalesInput, itemproductsaleUncheckedCreateWithoutItemitemproductsalesInput>
    where?: itemproductsaleWhereInput
  }

  export type itemproductsaleUpdateToOneWithWhereWithoutItemitemproductsalesInput = {
    where?: itemproductsaleWhereInput
    data: XOR<itemproductsaleUpdateWithoutItemitemproductsalesInput, itemproductsaleUncheckedUpdateWithoutItemitemproductsalesInput>
  }

  export type itemproductsaleUpdateWithoutItemitemproductsalesInput = {
    quantity?: FloatFieldUpdateOperationsInput | number
    additional_price?: FloatFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    observations?: NullableStringFieldUpdateOperationsInput | string | null
    productsale?: productsaleUpdateOneRequiredWithoutItemproductsalesNestedInput
    item?: itemUpdateOneRequiredWithoutItemproductsalesNestedInput
    optiongroup?: optiongroupUpdateOneWithoutItemproductsalesNestedInput
  }

  export type itemproductsaleUncheckedUpdateWithoutItemitemproductsalesInput = {
    id?: IntFieldUpdateOperationsInput | number
    product_sale_id?: IntFieldUpdateOperationsInput | number
    item_id?: IntFieldUpdateOperationsInput | number
    option_group_id?: NullableIntFieldUpdateOperationsInput | number | null
    quantity?: FloatFieldUpdateOperationsInput | number
    additional_price?: FloatFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    observations?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type itemUpsertWithoutItemitemproductsalesInput = {
    update: XOR<itemUpdateWithoutItemitemproductsalesInput, itemUncheckedUpdateWithoutItemitemproductsalesInput>
    create: XOR<itemCreateWithoutItemitemproductsalesInput, itemUncheckedCreateWithoutItemitemproductsalesInput>
    where?: itemWhereInput
  }

  export type itemUpdateToOneWithWhereWithoutItemitemproductsalesInput = {
    where?: itemWhereInput
    data: XOR<itemUpdateWithoutItemitemproductsalesInput, itemUncheckedUpdateWithoutItemitemproductsalesInput>
  }

  export type itemUpdateWithoutItemitemproductsalesInput = {
    name?: StringFieldUpdateOperationsInput | string
    pos_uuid?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    brand?: brandUpdateOneRequiredWithoutItemsNestedInput
    subbrand?: subbrandUpdateOneWithoutItemsNestedInput
    category?: categoryUpdateOneWithoutItemsNestedInput
    itemproductsales?: itemproductsaleUpdateManyWithoutItemNestedInput
  }

  export type itemUncheckedUpdateWithoutItemitemproductsalesInput = {
    id?: IntFieldUpdateOperationsInput | number
    brand_id?: IntFieldUpdateOperationsInput | number
    sub_brand_id?: NullableIntFieldUpdateOperationsInput | number | null
    category_id?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    pos_uuid?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    itemproductsales?: itemproductsaleUncheckedUpdateManyWithoutItemNestedInput
  }

  export type optiongroupUpsertWithoutItemitemproductsalesInput = {
    update: XOR<optiongroupUpdateWithoutItemitemproductsalesInput, optiongroupUncheckedUpdateWithoutItemitemproductsalesInput>
    create: XOR<optiongroupCreateWithoutItemitemproductsalesInput, optiongroupUncheckedCreateWithoutItemitemproductsalesInput>
    where?: optiongroupWhereInput
  }

  export type optiongroupUpdateToOneWithWhereWithoutItemitemproductsalesInput = {
    where?: optiongroupWhereInput
    data: XOR<optiongroupUpdateWithoutItemitemproductsalesInput, optiongroupUncheckedUpdateWithoutItemitemproductsalesInput>
  }

  export type optiongroupUpdateWithoutItemitemproductsalesInput = {
    name?: StringFieldUpdateOperationsInput | string
    pos_uuid?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    brand?: brandUpdateOneRequiredWithoutOptiongroupsNestedInput
    subbrand?: subbrandUpdateOneWithoutOptiongroupsNestedInput
    category?: categoryUpdateOneWithoutOptiongroupsNestedInput
    itemproductsales?: itemproductsaleUpdateManyWithoutOptiongroupNestedInput
  }

  export type optiongroupUncheckedUpdateWithoutItemitemproductsalesInput = {
    id?: IntFieldUpdateOperationsInput | number
    brand_id?: IntFieldUpdateOperationsInput | number
    sub_brand_id?: NullableIntFieldUpdateOperationsInput | number | null
    category_id?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    pos_uuid?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    itemproductsales?: itemproductsaleUncheckedUpdateManyWithoutOptiongroupNestedInput
  }

  export type saleCreateWithoutDeliverysalesInput = {
    cod_sale1?: string | null
    cod_sale2?: string | null
    created_at: Date | string
    customer_name?: string | null
    sale_status_desc: string
    total_amount_items: Decimal | DecimalJsLike | number | string
    total_discount?: Decimal | DecimalJsLike | number | string | null
    total_increase?: Decimal | DecimalJsLike | number | string | null
    delivery_fee?: Decimal | DecimalJsLike | number | string | null
    service_tax_fee?: Decimal | DecimalJsLike | number | string | null
    total_amount: Decimal | DecimalJsLike | number | string
    value_paid?: Decimal | DecimalJsLike | number | string | null
    production_seconds?: number | null
    delivery_seconds?: number | null
    people_quantity?: number | null
    discount_reason?: string | null
    increase_reason?: string | null
    origin?: string | null
    store: storeCreateNestedOneWithoutSalesInput
    subbrand?: subbrandCreateNestedOneWithoutSalesInput
    customer?: customerCreateNestedOneWithoutSalesInput
    channel: channelCreateNestedOneWithoutSalesInput
    productsales?: productsaleCreateNestedManyWithoutSaleInput
    deliveryaddress?: deliveryaddressCreateNestedManyWithoutSaleInput
    payments?: paymentCreateNestedManyWithoutSaleInput
    couponsales?: couponsaleCreateNestedManyWithoutSaleInput
  }

  export type saleUncheckedCreateWithoutDeliverysalesInput = {
    id?: number
    store_id: number
    sub_brand_id?: number | null
    customer_id?: number | null
    channel_id: number
    cod_sale1?: string | null
    cod_sale2?: string | null
    created_at: Date | string
    customer_name?: string | null
    sale_status_desc: string
    total_amount_items: Decimal | DecimalJsLike | number | string
    total_discount?: Decimal | DecimalJsLike | number | string | null
    total_increase?: Decimal | DecimalJsLike | number | string | null
    delivery_fee?: Decimal | DecimalJsLike | number | string | null
    service_tax_fee?: Decimal | DecimalJsLike | number | string | null
    total_amount: Decimal | DecimalJsLike | number | string
    value_paid?: Decimal | DecimalJsLike | number | string | null
    production_seconds?: number | null
    delivery_seconds?: number | null
    people_quantity?: number | null
    discount_reason?: string | null
    increase_reason?: string | null
    origin?: string | null
    productsales?: productsaleUncheckedCreateNestedManyWithoutSaleInput
    deliveryaddress?: deliveryaddressUncheckedCreateNestedManyWithoutSaleInput
    payments?: paymentUncheckedCreateNestedManyWithoutSaleInput
    couponsales?: couponsaleUncheckedCreateNestedManyWithoutSaleInput
  }

  export type saleCreateOrConnectWithoutDeliverysalesInput = {
    where: saleWhereUniqueInput
    create: XOR<saleCreateWithoutDeliverysalesInput, saleUncheckedCreateWithoutDeliverysalesInput>
  }

  export type deliveryaddressCreateWithoutDeliverysaleInput = {
    street?: string | null
    number?: string | null
    complement?: string | null
    formatted_address?: string | null
    neighborhood?: string | null
    city?: string | null
    state?: string | null
    country?: string | null
    postal_code?: string | null
    reference?: string | null
    latitude?: number | null
    longitude?: number | null
    sale: saleCreateNestedOneWithoutDeliveryaddressInput
  }

  export type deliveryaddressUncheckedCreateWithoutDeliverysaleInput = {
    id?: number
    sale_id: number
    street?: string | null
    number?: string | null
    complement?: string | null
    formatted_address?: string | null
    neighborhood?: string | null
    city?: string | null
    state?: string | null
    country?: string | null
    postal_code?: string | null
    reference?: string | null
    latitude?: number | null
    longitude?: number | null
  }

  export type deliveryaddressCreateOrConnectWithoutDeliverysaleInput = {
    where: deliveryaddressWhereUniqueInput
    create: XOR<deliveryaddressCreateWithoutDeliverysaleInput, deliveryaddressUncheckedCreateWithoutDeliverysaleInput>
  }

  export type deliveryaddressCreateManyDeliverysaleInputEnvelope = {
    data: deliveryaddressCreateManyDeliverysaleInput | deliveryaddressCreateManyDeliverysaleInput[]
    skipDuplicates?: boolean
  }

  export type saleUpsertWithoutDeliverysalesInput = {
    update: XOR<saleUpdateWithoutDeliverysalesInput, saleUncheckedUpdateWithoutDeliverysalesInput>
    create: XOR<saleCreateWithoutDeliverysalesInput, saleUncheckedCreateWithoutDeliverysalesInput>
    where?: saleWhereInput
  }

  export type saleUpdateToOneWithWhereWithoutDeliverysalesInput = {
    where?: saleWhereInput
    data: XOR<saleUpdateWithoutDeliverysalesInput, saleUncheckedUpdateWithoutDeliverysalesInput>
  }

  export type saleUpdateWithoutDeliverysalesInput = {
    cod_sale1?: NullableStringFieldUpdateOperationsInput | string | null
    cod_sale2?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    customer_name?: NullableStringFieldUpdateOperationsInput | string | null
    sale_status_desc?: StringFieldUpdateOperationsInput | string
    total_amount_items?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total_discount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    total_increase?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    delivery_fee?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    service_tax_fee?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    total_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    value_paid?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    production_seconds?: NullableIntFieldUpdateOperationsInput | number | null
    delivery_seconds?: NullableIntFieldUpdateOperationsInput | number | null
    people_quantity?: NullableIntFieldUpdateOperationsInput | number | null
    discount_reason?: NullableStringFieldUpdateOperationsInput | string | null
    increase_reason?: NullableStringFieldUpdateOperationsInput | string | null
    origin?: NullableStringFieldUpdateOperationsInput | string | null
    store?: storeUpdateOneRequiredWithoutSalesNestedInput
    subbrand?: subbrandUpdateOneWithoutSalesNestedInput
    customer?: customerUpdateOneWithoutSalesNestedInput
    channel?: channelUpdateOneRequiredWithoutSalesNestedInput
    productsales?: productsaleUpdateManyWithoutSaleNestedInput
    deliveryaddress?: deliveryaddressUpdateManyWithoutSaleNestedInput
    payments?: paymentUpdateManyWithoutSaleNestedInput
    couponsales?: couponsaleUpdateManyWithoutSaleNestedInput
  }

  export type saleUncheckedUpdateWithoutDeliverysalesInput = {
    id?: IntFieldUpdateOperationsInput | number
    store_id?: IntFieldUpdateOperationsInput | number
    sub_brand_id?: NullableIntFieldUpdateOperationsInput | number | null
    customer_id?: NullableIntFieldUpdateOperationsInput | number | null
    channel_id?: IntFieldUpdateOperationsInput | number
    cod_sale1?: NullableStringFieldUpdateOperationsInput | string | null
    cod_sale2?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    customer_name?: NullableStringFieldUpdateOperationsInput | string | null
    sale_status_desc?: StringFieldUpdateOperationsInput | string
    total_amount_items?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total_discount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    total_increase?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    delivery_fee?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    service_tax_fee?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    total_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    value_paid?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    production_seconds?: NullableIntFieldUpdateOperationsInput | number | null
    delivery_seconds?: NullableIntFieldUpdateOperationsInput | number | null
    people_quantity?: NullableIntFieldUpdateOperationsInput | number | null
    discount_reason?: NullableStringFieldUpdateOperationsInput | string | null
    increase_reason?: NullableStringFieldUpdateOperationsInput | string | null
    origin?: NullableStringFieldUpdateOperationsInput | string | null
    productsales?: productsaleUncheckedUpdateManyWithoutSaleNestedInput
    deliveryaddress?: deliveryaddressUncheckedUpdateManyWithoutSaleNestedInput
    payments?: paymentUncheckedUpdateManyWithoutSaleNestedInput
    couponsales?: couponsaleUncheckedUpdateManyWithoutSaleNestedInput
  }

  export type deliveryaddressUpsertWithWhereUniqueWithoutDeliverysaleInput = {
    where: deliveryaddressWhereUniqueInput
    update: XOR<deliveryaddressUpdateWithoutDeliverysaleInput, deliveryaddressUncheckedUpdateWithoutDeliverysaleInput>
    create: XOR<deliveryaddressCreateWithoutDeliverysaleInput, deliveryaddressUncheckedCreateWithoutDeliverysaleInput>
  }

  export type deliveryaddressUpdateWithWhereUniqueWithoutDeliverysaleInput = {
    where: deliveryaddressWhereUniqueInput
    data: XOR<deliveryaddressUpdateWithoutDeliverysaleInput, deliveryaddressUncheckedUpdateWithoutDeliverysaleInput>
  }

  export type deliveryaddressUpdateManyWithWhereWithoutDeliverysaleInput = {
    where: deliveryaddressScalarWhereInput
    data: XOR<deliveryaddressUpdateManyMutationInput, deliveryaddressUncheckedUpdateManyWithoutDeliverysaleInput>
  }

  export type saleCreateWithoutDeliveryaddressInput = {
    cod_sale1?: string | null
    cod_sale2?: string | null
    created_at: Date | string
    customer_name?: string | null
    sale_status_desc: string
    total_amount_items: Decimal | DecimalJsLike | number | string
    total_discount?: Decimal | DecimalJsLike | number | string | null
    total_increase?: Decimal | DecimalJsLike | number | string | null
    delivery_fee?: Decimal | DecimalJsLike | number | string | null
    service_tax_fee?: Decimal | DecimalJsLike | number | string | null
    total_amount: Decimal | DecimalJsLike | number | string
    value_paid?: Decimal | DecimalJsLike | number | string | null
    production_seconds?: number | null
    delivery_seconds?: number | null
    people_quantity?: number | null
    discount_reason?: string | null
    increase_reason?: string | null
    origin?: string | null
    store: storeCreateNestedOneWithoutSalesInput
    subbrand?: subbrandCreateNestedOneWithoutSalesInput
    customer?: customerCreateNestedOneWithoutSalesInput
    channel: channelCreateNestedOneWithoutSalesInput
    productsales?: productsaleCreateNestedManyWithoutSaleInput
    deliverysales?: deliverysaleCreateNestedManyWithoutSaleInput
    payments?: paymentCreateNestedManyWithoutSaleInput
    couponsales?: couponsaleCreateNestedManyWithoutSaleInput
  }

  export type saleUncheckedCreateWithoutDeliveryaddressInput = {
    id?: number
    store_id: number
    sub_brand_id?: number | null
    customer_id?: number | null
    channel_id: number
    cod_sale1?: string | null
    cod_sale2?: string | null
    created_at: Date | string
    customer_name?: string | null
    sale_status_desc: string
    total_amount_items: Decimal | DecimalJsLike | number | string
    total_discount?: Decimal | DecimalJsLike | number | string | null
    total_increase?: Decimal | DecimalJsLike | number | string | null
    delivery_fee?: Decimal | DecimalJsLike | number | string | null
    service_tax_fee?: Decimal | DecimalJsLike | number | string | null
    total_amount: Decimal | DecimalJsLike | number | string
    value_paid?: Decimal | DecimalJsLike | number | string | null
    production_seconds?: number | null
    delivery_seconds?: number | null
    people_quantity?: number | null
    discount_reason?: string | null
    increase_reason?: string | null
    origin?: string | null
    productsales?: productsaleUncheckedCreateNestedManyWithoutSaleInput
    deliverysales?: deliverysaleUncheckedCreateNestedManyWithoutSaleInput
    payments?: paymentUncheckedCreateNestedManyWithoutSaleInput
    couponsales?: couponsaleUncheckedCreateNestedManyWithoutSaleInput
  }

  export type saleCreateOrConnectWithoutDeliveryaddressInput = {
    where: saleWhereUniqueInput
    create: XOR<saleCreateWithoutDeliveryaddressInput, saleUncheckedCreateWithoutDeliveryaddressInput>
  }

  export type deliverysaleCreateWithoutDeliveryaddressesInput = {
    courier_id?: string | null
    courier_name?: string | null
    courier_phone?: string | null
    courier_type?: string | null
    delivered_by?: string | null
    delivery_type?: string | null
    status?: string | null
    delivery_fee?: number | null
    courier_fee?: number | null
    timing?: string | null
    mode?: string | null
    sale: saleCreateNestedOneWithoutDeliverysalesInput
  }

  export type deliverysaleUncheckedCreateWithoutDeliveryaddressesInput = {
    id?: number
    sale_id: number
    courier_id?: string | null
    courier_name?: string | null
    courier_phone?: string | null
    courier_type?: string | null
    delivered_by?: string | null
    delivery_type?: string | null
    status?: string | null
    delivery_fee?: number | null
    courier_fee?: number | null
    timing?: string | null
    mode?: string | null
  }

  export type deliverysaleCreateOrConnectWithoutDeliveryaddressesInput = {
    where: deliverysaleWhereUniqueInput
    create: XOR<deliverysaleCreateWithoutDeliveryaddressesInput, deliverysaleUncheckedCreateWithoutDeliveryaddressesInput>
  }

  export type saleUpsertWithoutDeliveryaddressInput = {
    update: XOR<saleUpdateWithoutDeliveryaddressInput, saleUncheckedUpdateWithoutDeliveryaddressInput>
    create: XOR<saleCreateWithoutDeliveryaddressInput, saleUncheckedCreateWithoutDeliveryaddressInput>
    where?: saleWhereInput
  }

  export type saleUpdateToOneWithWhereWithoutDeliveryaddressInput = {
    where?: saleWhereInput
    data: XOR<saleUpdateWithoutDeliveryaddressInput, saleUncheckedUpdateWithoutDeliveryaddressInput>
  }

  export type saleUpdateWithoutDeliveryaddressInput = {
    cod_sale1?: NullableStringFieldUpdateOperationsInput | string | null
    cod_sale2?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    customer_name?: NullableStringFieldUpdateOperationsInput | string | null
    sale_status_desc?: StringFieldUpdateOperationsInput | string
    total_amount_items?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total_discount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    total_increase?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    delivery_fee?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    service_tax_fee?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    total_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    value_paid?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    production_seconds?: NullableIntFieldUpdateOperationsInput | number | null
    delivery_seconds?: NullableIntFieldUpdateOperationsInput | number | null
    people_quantity?: NullableIntFieldUpdateOperationsInput | number | null
    discount_reason?: NullableStringFieldUpdateOperationsInput | string | null
    increase_reason?: NullableStringFieldUpdateOperationsInput | string | null
    origin?: NullableStringFieldUpdateOperationsInput | string | null
    store?: storeUpdateOneRequiredWithoutSalesNestedInput
    subbrand?: subbrandUpdateOneWithoutSalesNestedInput
    customer?: customerUpdateOneWithoutSalesNestedInput
    channel?: channelUpdateOneRequiredWithoutSalesNestedInput
    productsales?: productsaleUpdateManyWithoutSaleNestedInput
    deliverysales?: deliverysaleUpdateManyWithoutSaleNestedInput
    payments?: paymentUpdateManyWithoutSaleNestedInput
    couponsales?: couponsaleUpdateManyWithoutSaleNestedInput
  }

  export type saleUncheckedUpdateWithoutDeliveryaddressInput = {
    id?: IntFieldUpdateOperationsInput | number
    store_id?: IntFieldUpdateOperationsInput | number
    sub_brand_id?: NullableIntFieldUpdateOperationsInput | number | null
    customer_id?: NullableIntFieldUpdateOperationsInput | number | null
    channel_id?: IntFieldUpdateOperationsInput | number
    cod_sale1?: NullableStringFieldUpdateOperationsInput | string | null
    cod_sale2?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    customer_name?: NullableStringFieldUpdateOperationsInput | string | null
    sale_status_desc?: StringFieldUpdateOperationsInput | string
    total_amount_items?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total_discount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    total_increase?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    delivery_fee?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    service_tax_fee?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    total_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    value_paid?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    production_seconds?: NullableIntFieldUpdateOperationsInput | number | null
    delivery_seconds?: NullableIntFieldUpdateOperationsInput | number | null
    people_quantity?: NullableIntFieldUpdateOperationsInput | number | null
    discount_reason?: NullableStringFieldUpdateOperationsInput | string | null
    increase_reason?: NullableStringFieldUpdateOperationsInput | string | null
    origin?: NullableStringFieldUpdateOperationsInput | string | null
    productsales?: productsaleUncheckedUpdateManyWithoutSaleNestedInput
    deliverysales?: deliverysaleUncheckedUpdateManyWithoutSaleNestedInput
    payments?: paymentUncheckedUpdateManyWithoutSaleNestedInput
    couponsales?: couponsaleUncheckedUpdateManyWithoutSaleNestedInput
  }

  export type deliverysaleUpsertWithoutDeliveryaddressesInput = {
    update: XOR<deliverysaleUpdateWithoutDeliveryaddressesInput, deliverysaleUncheckedUpdateWithoutDeliveryaddressesInput>
    create: XOR<deliverysaleCreateWithoutDeliveryaddressesInput, deliverysaleUncheckedCreateWithoutDeliveryaddressesInput>
    where?: deliverysaleWhereInput
  }

  export type deliverysaleUpdateToOneWithWhereWithoutDeliveryaddressesInput = {
    where?: deliverysaleWhereInput
    data: XOR<deliverysaleUpdateWithoutDeliveryaddressesInput, deliverysaleUncheckedUpdateWithoutDeliveryaddressesInput>
  }

  export type deliverysaleUpdateWithoutDeliveryaddressesInput = {
    courier_id?: NullableStringFieldUpdateOperationsInput | string | null
    courier_name?: NullableStringFieldUpdateOperationsInput | string | null
    courier_phone?: NullableStringFieldUpdateOperationsInput | string | null
    courier_type?: NullableStringFieldUpdateOperationsInput | string | null
    delivered_by?: NullableStringFieldUpdateOperationsInput | string | null
    delivery_type?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    delivery_fee?: NullableFloatFieldUpdateOperationsInput | number | null
    courier_fee?: NullableFloatFieldUpdateOperationsInput | number | null
    timing?: NullableStringFieldUpdateOperationsInput | string | null
    mode?: NullableStringFieldUpdateOperationsInput | string | null
    sale?: saleUpdateOneRequiredWithoutDeliverysalesNestedInput
  }

  export type deliverysaleUncheckedUpdateWithoutDeliveryaddressesInput = {
    id?: IntFieldUpdateOperationsInput | number
    sale_id?: IntFieldUpdateOperationsInput | number
    courier_id?: NullableStringFieldUpdateOperationsInput | string | null
    courier_name?: NullableStringFieldUpdateOperationsInput | string | null
    courier_phone?: NullableStringFieldUpdateOperationsInput | string | null
    courier_type?: NullableStringFieldUpdateOperationsInput | string | null
    delivered_by?: NullableStringFieldUpdateOperationsInput | string | null
    delivery_type?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    delivery_fee?: NullableFloatFieldUpdateOperationsInput | number | null
    courier_fee?: NullableFloatFieldUpdateOperationsInput | number | null
    timing?: NullableStringFieldUpdateOperationsInput | string | null
    mode?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type brandCreateWithoutPaymenttypesInput = {
    name: string
    created_at?: Date | string | null
    subbrands?: subbrandCreateNestedManyWithoutBrandInput
    stores?: storeCreateNestedManyWithoutBrandInput
    channels?: channelCreateNestedManyWithoutBrandInput
    categories?: categoryCreateNestedManyWithoutBrandInput
    products?: productCreateNestedManyWithoutBrandInput
    optiongroups?: optiongroupCreateNestedManyWithoutBrandInput
    items?: itemCreateNestedManyWithoutBrandInput
    coupons?: couponCreateNestedManyWithoutBrandInput
  }

  export type brandUncheckedCreateWithoutPaymenttypesInput = {
    id?: number
    name: string
    created_at?: Date | string | null
    subbrands?: subbrandUncheckedCreateNestedManyWithoutBrandInput
    stores?: storeUncheckedCreateNestedManyWithoutBrandInput
    channels?: channelUncheckedCreateNestedManyWithoutBrandInput
    categories?: categoryUncheckedCreateNestedManyWithoutBrandInput
    products?: productUncheckedCreateNestedManyWithoutBrandInput
    optiongroups?: optiongroupUncheckedCreateNestedManyWithoutBrandInput
    items?: itemUncheckedCreateNestedManyWithoutBrandInput
    coupons?: couponUncheckedCreateNestedManyWithoutBrandInput
  }

  export type brandCreateOrConnectWithoutPaymenttypesInput = {
    where: brandWhereUniqueInput
    create: XOR<brandCreateWithoutPaymenttypesInput, brandUncheckedCreateWithoutPaymenttypesInput>
  }

  export type paymentCreateWithoutPaymenttypeInput = {
    value: Decimal | DecimalJsLike | number | string
    is_online?: boolean | null
    description?: string | null
    currency?: string | null
    sale: saleCreateNestedOneWithoutPaymentsInput
  }

  export type paymentUncheckedCreateWithoutPaymenttypeInput = {
    id?: number
    sale_id: number
    value: Decimal | DecimalJsLike | number | string
    is_online?: boolean | null
    description?: string | null
    currency?: string | null
  }

  export type paymentCreateOrConnectWithoutPaymenttypeInput = {
    where: paymentWhereUniqueInput
    create: XOR<paymentCreateWithoutPaymenttypeInput, paymentUncheckedCreateWithoutPaymenttypeInput>
  }

  export type paymentCreateManyPaymenttypeInputEnvelope = {
    data: paymentCreateManyPaymenttypeInput | paymentCreateManyPaymenttypeInput[]
    skipDuplicates?: boolean
  }

  export type brandUpsertWithoutPaymenttypesInput = {
    update: XOR<brandUpdateWithoutPaymenttypesInput, brandUncheckedUpdateWithoutPaymenttypesInput>
    create: XOR<brandCreateWithoutPaymenttypesInput, brandUncheckedCreateWithoutPaymenttypesInput>
    where?: brandWhereInput
  }

  export type brandUpdateToOneWithWhereWithoutPaymenttypesInput = {
    where?: brandWhereInput
    data: XOR<brandUpdateWithoutPaymenttypesInput, brandUncheckedUpdateWithoutPaymenttypesInput>
  }

  export type brandUpdateWithoutPaymenttypesInput = {
    name?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subbrands?: subbrandUpdateManyWithoutBrandNestedInput
    stores?: storeUpdateManyWithoutBrandNestedInput
    channels?: channelUpdateManyWithoutBrandNestedInput
    categories?: categoryUpdateManyWithoutBrandNestedInput
    products?: productUpdateManyWithoutBrandNestedInput
    optiongroups?: optiongroupUpdateManyWithoutBrandNestedInput
    items?: itemUpdateManyWithoutBrandNestedInput
    coupons?: couponUpdateManyWithoutBrandNestedInput
  }

  export type brandUncheckedUpdateWithoutPaymenttypesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subbrands?: subbrandUncheckedUpdateManyWithoutBrandNestedInput
    stores?: storeUncheckedUpdateManyWithoutBrandNestedInput
    channels?: channelUncheckedUpdateManyWithoutBrandNestedInput
    categories?: categoryUncheckedUpdateManyWithoutBrandNestedInput
    products?: productUncheckedUpdateManyWithoutBrandNestedInput
    optiongroups?: optiongroupUncheckedUpdateManyWithoutBrandNestedInput
    items?: itemUncheckedUpdateManyWithoutBrandNestedInput
    coupons?: couponUncheckedUpdateManyWithoutBrandNestedInput
  }

  export type paymentUpsertWithWhereUniqueWithoutPaymenttypeInput = {
    where: paymentWhereUniqueInput
    update: XOR<paymentUpdateWithoutPaymenttypeInput, paymentUncheckedUpdateWithoutPaymenttypeInput>
    create: XOR<paymentCreateWithoutPaymenttypeInput, paymentUncheckedCreateWithoutPaymenttypeInput>
  }

  export type paymentUpdateWithWhereUniqueWithoutPaymenttypeInput = {
    where: paymentWhereUniqueInput
    data: XOR<paymentUpdateWithoutPaymenttypeInput, paymentUncheckedUpdateWithoutPaymenttypeInput>
  }

  export type paymentUpdateManyWithWhereWithoutPaymenttypeInput = {
    where: paymentScalarWhereInput
    data: XOR<paymentUpdateManyMutationInput, paymentUncheckedUpdateManyWithoutPaymenttypeInput>
  }

  export type saleCreateWithoutPaymentsInput = {
    cod_sale1?: string | null
    cod_sale2?: string | null
    created_at: Date | string
    customer_name?: string | null
    sale_status_desc: string
    total_amount_items: Decimal | DecimalJsLike | number | string
    total_discount?: Decimal | DecimalJsLike | number | string | null
    total_increase?: Decimal | DecimalJsLike | number | string | null
    delivery_fee?: Decimal | DecimalJsLike | number | string | null
    service_tax_fee?: Decimal | DecimalJsLike | number | string | null
    total_amount: Decimal | DecimalJsLike | number | string
    value_paid?: Decimal | DecimalJsLike | number | string | null
    production_seconds?: number | null
    delivery_seconds?: number | null
    people_quantity?: number | null
    discount_reason?: string | null
    increase_reason?: string | null
    origin?: string | null
    store: storeCreateNestedOneWithoutSalesInput
    subbrand?: subbrandCreateNestedOneWithoutSalesInput
    customer?: customerCreateNestedOneWithoutSalesInput
    channel: channelCreateNestedOneWithoutSalesInput
    productsales?: productsaleCreateNestedManyWithoutSaleInput
    deliverysales?: deliverysaleCreateNestedManyWithoutSaleInput
    deliveryaddress?: deliveryaddressCreateNestedManyWithoutSaleInput
    couponsales?: couponsaleCreateNestedManyWithoutSaleInput
  }

  export type saleUncheckedCreateWithoutPaymentsInput = {
    id?: number
    store_id: number
    sub_brand_id?: number | null
    customer_id?: number | null
    channel_id: number
    cod_sale1?: string | null
    cod_sale2?: string | null
    created_at: Date | string
    customer_name?: string | null
    sale_status_desc: string
    total_amount_items: Decimal | DecimalJsLike | number | string
    total_discount?: Decimal | DecimalJsLike | number | string | null
    total_increase?: Decimal | DecimalJsLike | number | string | null
    delivery_fee?: Decimal | DecimalJsLike | number | string | null
    service_tax_fee?: Decimal | DecimalJsLike | number | string | null
    total_amount: Decimal | DecimalJsLike | number | string
    value_paid?: Decimal | DecimalJsLike | number | string | null
    production_seconds?: number | null
    delivery_seconds?: number | null
    people_quantity?: number | null
    discount_reason?: string | null
    increase_reason?: string | null
    origin?: string | null
    productsales?: productsaleUncheckedCreateNestedManyWithoutSaleInput
    deliverysales?: deliverysaleUncheckedCreateNestedManyWithoutSaleInput
    deliveryaddress?: deliveryaddressUncheckedCreateNestedManyWithoutSaleInput
    couponsales?: couponsaleUncheckedCreateNestedManyWithoutSaleInput
  }

  export type saleCreateOrConnectWithoutPaymentsInput = {
    where: saleWhereUniqueInput
    create: XOR<saleCreateWithoutPaymentsInput, saleUncheckedCreateWithoutPaymentsInput>
  }

  export type paymenttypeCreateWithoutPaymentsInput = {
    description: string
    brand?: brandCreateNestedOneWithoutPaymenttypesInput
  }

  export type paymenttypeUncheckedCreateWithoutPaymentsInput = {
    id?: number
    brand_id?: number | null
    description: string
  }

  export type paymenttypeCreateOrConnectWithoutPaymentsInput = {
    where: paymenttypeWhereUniqueInput
    create: XOR<paymenttypeCreateWithoutPaymentsInput, paymenttypeUncheckedCreateWithoutPaymentsInput>
  }

  export type saleUpsertWithoutPaymentsInput = {
    update: XOR<saleUpdateWithoutPaymentsInput, saleUncheckedUpdateWithoutPaymentsInput>
    create: XOR<saleCreateWithoutPaymentsInput, saleUncheckedCreateWithoutPaymentsInput>
    where?: saleWhereInput
  }

  export type saleUpdateToOneWithWhereWithoutPaymentsInput = {
    where?: saleWhereInput
    data: XOR<saleUpdateWithoutPaymentsInput, saleUncheckedUpdateWithoutPaymentsInput>
  }

  export type saleUpdateWithoutPaymentsInput = {
    cod_sale1?: NullableStringFieldUpdateOperationsInput | string | null
    cod_sale2?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    customer_name?: NullableStringFieldUpdateOperationsInput | string | null
    sale_status_desc?: StringFieldUpdateOperationsInput | string
    total_amount_items?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total_discount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    total_increase?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    delivery_fee?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    service_tax_fee?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    total_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    value_paid?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    production_seconds?: NullableIntFieldUpdateOperationsInput | number | null
    delivery_seconds?: NullableIntFieldUpdateOperationsInput | number | null
    people_quantity?: NullableIntFieldUpdateOperationsInput | number | null
    discount_reason?: NullableStringFieldUpdateOperationsInput | string | null
    increase_reason?: NullableStringFieldUpdateOperationsInput | string | null
    origin?: NullableStringFieldUpdateOperationsInput | string | null
    store?: storeUpdateOneRequiredWithoutSalesNestedInput
    subbrand?: subbrandUpdateOneWithoutSalesNestedInput
    customer?: customerUpdateOneWithoutSalesNestedInput
    channel?: channelUpdateOneRequiredWithoutSalesNestedInput
    productsales?: productsaleUpdateManyWithoutSaleNestedInput
    deliverysales?: deliverysaleUpdateManyWithoutSaleNestedInput
    deliveryaddress?: deliveryaddressUpdateManyWithoutSaleNestedInput
    couponsales?: couponsaleUpdateManyWithoutSaleNestedInput
  }

  export type saleUncheckedUpdateWithoutPaymentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    store_id?: IntFieldUpdateOperationsInput | number
    sub_brand_id?: NullableIntFieldUpdateOperationsInput | number | null
    customer_id?: NullableIntFieldUpdateOperationsInput | number | null
    channel_id?: IntFieldUpdateOperationsInput | number
    cod_sale1?: NullableStringFieldUpdateOperationsInput | string | null
    cod_sale2?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    customer_name?: NullableStringFieldUpdateOperationsInput | string | null
    sale_status_desc?: StringFieldUpdateOperationsInput | string
    total_amount_items?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total_discount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    total_increase?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    delivery_fee?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    service_tax_fee?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    total_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    value_paid?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    production_seconds?: NullableIntFieldUpdateOperationsInput | number | null
    delivery_seconds?: NullableIntFieldUpdateOperationsInput | number | null
    people_quantity?: NullableIntFieldUpdateOperationsInput | number | null
    discount_reason?: NullableStringFieldUpdateOperationsInput | string | null
    increase_reason?: NullableStringFieldUpdateOperationsInput | string | null
    origin?: NullableStringFieldUpdateOperationsInput | string | null
    productsales?: productsaleUncheckedUpdateManyWithoutSaleNestedInput
    deliverysales?: deliverysaleUncheckedUpdateManyWithoutSaleNestedInput
    deliveryaddress?: deliveryaddressUncheckedUpdateManyWithoutSaleNestedInput
    couponsales?: couponsaleUncheckedUpdateManyWithoutSaleNestedInput
  }

  export type paymenttypeUpsertWithoutPaymentsInput = {
    update: XOR<paymenttypeUpdateWithoutPaymentsInput, paymenttypeUncheckedUpdateWithoutPaymentsInput>
    create: XOR<paymenttypeCreateWithoutPaymentsInput, paymenttypeUncheckedCreateWithoutPaymentsInput>
    where?: paymenttypeWhereInput
  }

  export type paymenttypeUpdateToOneWithWhereWithoutPaymentsInput = {
    where?: paymenttypeWhereInput
    data: XOR<paymenttypeUpdateWithoutPaymentsInput, paymenttypeUncheckedUpdateWithoutPaymentsInput>
  }

  export type paymenttypeUpdateWithoutPaymentsInput = {
    description?: StringFieldUpdateOperationsInput | string
    brand?: brandUpdateOneWithoutPaymenttypesNestedInput
  }

  export type paymenttypeUncheckedUpdateWithoutPaymentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    brand_id?: NullableIntFieldUpdateOperationsInput | number | null
    description?: StringFieldUpdateOperationsInput | string
  }

  export type brandCreateWithoutCouponsInput = {
    name: string
    created_at?: Date | string | null
    subbrands?: subbrandCreateNestedManyWithoutBrandInput
    stores?: storeCreateNestedManyWithoutBrandInput
    channels?: channelCreateNestedManyWithoutBrandInput
    categories?: categoryCreateNestedManyWithoutBrandInput
    products?: productCreateNestedManyWithoutBrandInput
    optiongroups?: optiongroupCreateNestedManyWithoutBrandInput
    items?: itemCreateNestedManyWithoutBrandInput
    paymenttypes?: paymenttypeCreateNestedManyWithoutBrandInput
  }

  export type brandUncheckedCreateWithoutCouponsInput = {
    id?: number
    name: string
    created_at?: Date | string | null
    subbrands?: subbrandUncheckedCreateNestedManyWithoutBrandInput
    stores?: storeUncheckedCreateNestedManyWithoutBrandInput
    channels?: channelUncheckedCreateNestedManyWithoutBrandInput
    categories?: categoryUncheckedCreateNestedManyWithoutBrandInput
    products?: productUncheckedCreateNestedManyWithoutBrandInput
    optiongroups?: optiongroupUncheckedCreateNestedManyWithoutBrandInput
    items?: itemUncheckedCreateNestedManyWithoutBrandInput
    paymenttypes?: paymenttypeUncheckedCreateNestedManyWithoutBrandInput
  }

  export type brandCreateOrConnectWithoutCouponsInput = {
    where: brandWhereUniqueInput
    create: XOR<brandCreateWithoutCouponsInput, brandUncheckedCreateWithoutCouponsInput>
  }

  export type couponsaleCreateWithoutCouponInput = {
    value?: number | null
    target?: string | null
    sponsorship?: string | null
    sale?: saleCreateNestedOneWithoutCouponsalesInput
  }

  export type couponsaleUncheckedCreateWithoutCouponInput = {
    id?: number
    sale_id?: number | null
    value?: number | null
    target?: string | null
    sponsorship?: string | null
  }

  export type couponsaleCreateOrConnectWithoutCouponInput = {
    where: couponsaleWhereUniqueInput
    create: XOR<couponsaleCreateWithoutCouponInput, couponsaleUncheckedCreateWithoutCouponInput>
  }

  export type couponsaleCreateManyCouponInputEnvelope = {
    data: couponsaleCreateManyCouponInput | couponsaleCreateManyCouponInput[]
    skipDuplicates?: boolean
  }

  export type brandUpsertWithoutCouponsInput = {
    update: XOR<brandUpdateWithoutCouponsInput, brandUncheckedUpdateWithoutCouponsInput>
    create: XOR<brandCreateWithoutCouponsInput, brandUncheckedCreateWithoutCouponsInput>
    where?: brandWhereInput
  }

  export type brandUpdateToOneWithWhereWithoutCouponsInput = {
    where?: brandWhereInput
    data: XOR<brandUpdateWithoutCouponsInput, brandUncheckedUpdateWithoutCouponsInput>
  }

  export type brandUpdateWithoutCouponsInput = {
    name?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subbrands?: subbrandUpdateManyWithoutBrandNestedInput
    stores?: storeUpdateManyWithoutBrandNestedInput
    channels?: channelUpdateManyWithoutBrandNestedInput
    categories?: categoryUpdateManyWithoutBrandNestedInput
    products?: productUpdateManyWithoutBrandNestedInput
    optiongroups?: optiongroupUpdateManyWithoutBrandNestedInput
    items?: itemUpdateManyWithoutBrandNestedInput
    paymenttypes?: paymenttypeUpdateManyWithoutBrandNestedInput
  }

  export type brandUncheckedUpdateWithoutCouponsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subbrands?: subbrandUncheckedUpdateManyWithoutBrandNestedInput
    stores?: storeUncheckedUpdateManyWithoutBrandNestedInput
    channels?: channelUncheckedUpdateManyWithoutBrandNestedInput
    categories?: categoryUncheckedUpdateManyWithoutBrandNestedInput
    products?: productUncheckedUpdateManyWithoutBrandNestedInput
    optiongroups?: optiongroupUncheckedUpdateManyWithoutBrandNestedInput
    items?: itemUncheckedUpdateManyWithoutBrandNestedInput
    paymenttypes?: paymenttypeUncheckedUpdateManyWithoutBrandNestedInput
  }

  export type couponsaleUpsertWithWhereUniqueWithoutCouponInput = {
    where: couponsaleWhereUniqueInput
    update: XOR<couponsaleUpdateWithoutCouponInput, couponsaleUncheckedUpdateWithoutCouponInput>
    create: XOR<couponsaleCreateWithoutCouponInput, couponsaleUncheckedCreateWithoutCouponInput>
  }

  export type couponsaleUpdateWithWhereUniqueWithoutCouponInput = {
    where: couponsaleWhereUniqueInput
    data: XOR<couponsaleUpdateWithoutCouponInput, couponsaleUncheckedUpdateWithoutCouponInput>
  }

  export type couponsaleUpdateManyWithWhereWithoutCouponInput = {
    where: couponsaleScalarWhereInput
    data: XOR<couponsaleUpdateManyMutationInput, couponsaleUncheckedUpdateManyWithoutCouponInput>
  }

  export type saleCreateWithoutCouponsalesInput = {
    cod_sale1?: string | null
    cod_sale2?: string | null
    created_at: Date | string
    customer_name?: string | null
    sale_status_desc: string
    total_amount_items: Decimal | DecimalJsLike | number | string
    total_discount?: Decimal | DecimalJsLike | number | string | null
    total_increase?: Decimal | DecimalJsLike | number | string | null
    delivery_fee?: Decimal | DecimalJsLike | number | string | null
    service_tax_fee?: Decimal | DecimalJsLike | number | string | null
    total_amount: Decimal | DecimalJsLike | number | string
    value_paid?: Decimal | DecimalJsLike | number | string | null
    production_seconds?: number | null
    delivery_seconds?: number | null
    people_quantity?: number | null
    discount_reason?: string | null
    increase_reason?: string | null
    origin?: string | null
    store: storeCreateNestedOneWithoutSalesInput
    subbrand?: subbrandCreateNestedOneWithoutSalesInput
    customer?: customerCreateNestedOneWithoutSalesInput
    channel: channelCreateNestedOneWithoutSalesInput
    productsales?: productsaleCreateNestedManyWithoutSaleInput
    deliverysales?: deliverysaleCreateNestedManyWithoutSaleInput
    deliveryaddress?: deliveryaddressCreateNestedManyWithoutSaleInput
    payments?: paymentCreateNestedManyWithoutSaleInput
  }

  export type saleUncheckedCreateWithoutCouponsalesInput = {
    id?: number
    store_id: number
    sub_brand_id?: number | null
    customer_id?: number | null
    channel_id: number
    cod_sale1?: string | null
    cod_sale2?: string | null
    created_at: Date | string
    customer_name?: string | null
    sale_status_desc: string
    total_amount_items: Decimal | DecimalJsLike | number | string
    total_discount?: Decimal | DecimalJsLike | number | string | null
    total_increase?: Decimal | DecimalJsLike | number | string | null
    delivery_fee?: Decimal | DecimalJsLike | number | string | null
    service_tax_fee?: Decimal | DecimalJsLike | number | string | null
    total_amount: Decimal | DecimalJsLike | number | string
    value_paid?: Decimal | DecimalJsLike | number | string | null
    production_seconds?: number | null
    delivery_seconds?: number | null
    people_quantity?: number | null
    discount_reason?: string | null
    increase_reason?: string | null
    origin?: string | null
    productsales?: productsaleUncheckedCreateNestedManyWithoutSaleInput
    deliverysales?: deliverysaleUncheckedCreateNestedManyWithoutSaleInput
    deliveryaddress?: deliveryaddressUncheckedCreateNestedManyWithoutSaleInput
    payments?: paymentUncheckedCreateNestedManyWithoutSaleInput
  }

  export type saleCreateOrConnectWithoutCouponsalesInput = {
    where: saleWhereUniqueInput
    create: XOR<saleCreateWithoutCouponsalesInput, saleUncheckedCreateWithoutCouponsalesInput>
  }

  export type couponCreateWithoutCouponsalesInput = {
    code: string
    discount_type?: string | null
    discount_value?: Decimal | DecimalJsLike | number | string | null
    is_active?: boolean | null
    valid_from?: Date | string | null
    valid_until?: Date | string | null
    brand?: brandCreateNestedOneWithoutCouponsInput
  }

  export type couponUncheckedCreateWithoutCouponsalesInput = {
    id?: number
    brand_id?: number | null
    code: string
    discount_type?: string | null
    discount_value?: Decimal | DecimalJsLike | number | string | null
    is_active?: boolean | null
    valid_from?: Date | string | null
    valid_until?: Date | string | null
  }

  export type couponCreateOrConnectWithoutCouponsalesInput = {
    where: couponWhereUniqueInput
    create: XOR<couponCreateWithoutCouponsalesInput, couponUncheckedCreateWithoutCouponsalesInput>
  }

  export type saleUpsertWithoutCouponsalesInput = {
    update: XOR<saleUpdateWithoutCouponsalesInput, saleUncheckedUpdateWithoutCouponsalesInput>
    create: XOR<saleCreateWithoutCouponsalesInput, saleUncheckedCreateWithoutCouponsalesInput>
    where?: saleWhereInput
  }

  export type saleUpdateToOneWithWhereWithoutCouponsalesInput = {
    where?: saleWhereInput
    data: XOR<saleUpdateWithoutCouponsalesInput, saleUncheckedUpdateWithoutCouponsalesInput>
  }

  export type saleUpdateWithoutCouponsalesInput = {
    cod_sale1?: NullableStringFieldUpdateOperationsInput | string | null
    cod_sale2?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    customer_name?: NullableStringFieldUpdateOperationsInput | string | null
    sale_status_desc?: StringFieldUpdateOperationsInput | string
    total_amount_items?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total_discount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    total_increase?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    delivery_fee?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    service_tax_fee?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    total_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    value_paid?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    production_seconds?: NullableIntFieldUpdateOperationsInput | number | null
    delivery_seconds?: NullableIntFieldUpdateOperationsInput | number | null
    people_quantity?: NullableIntFieldUpdateOperationsInput | number | null
    discount_reason?: NullableStringFieldUpdateOperationsInput | string | null
    increase_reason?: NullableStringFieldUpdateOperationsInput | string | null
    origin?: NullableStringFieldUpdateOperationsInput | string | null
    store?: storeUpdateOneRequiredWithoutSalesNestedInput
    subbrand?: subbrandUpdateOneWithoutSalesNestedInput
    customer?: customerUpdateOneWithoutSalesNestedInput
    channel?: channelUpdateOneRequiredWithoutSalesNestedInput
    productsales?: productsaleUpdateManyWithoutSaleNestedInput
    deliverysales?: deliverysaleUpdateManyWithoutSaleNestedInput
    deliveryaddress?: deliveryaddressUpdateManyWithoutSaleNestedInput
    payments?: paymentUpdateManyWithoutSaleNestedInput
  }

  export type saleUncheckedUpdateWithoutCouponsalesInput = {
    id?: IntFieldUpdateOperationsInput | number
    store_id?: IntFieldUpdateOperationsInput | number
    sub_brand_id?: NullableIntFieldUpdateOperationsInput | number | null
    customer_id?: NullableIntFieldUpdateOperationsInput | number | null
    channel_id?: IntFieldUpdateOperationsInput | number
    cod_sale1?: NullableStringFieldUpdateOperationsInput | string | null
    cod_sale2?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    customer_name?: NullableStringFieldUpdateOperationsInput | string | null
    sale_status_desc?: StringFieldUpdateOperationsInput | string
    total_amount_items?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total_discount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    total_increase?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    delivery_fee?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    service_tax_fee?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    total_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    value_paid?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    production_seconds?: NullableIntFieldUpdateOperationsInput | number | null
    delivery_seconds?: NullableIntFieldUpdateOperationsInput | number | null
    people_quantity?: NullableIntFieldUpdateOperationsInput | number | null
    discount_reason?: NullableStringFieldUpdateOperationsInput | string | null
    increase_reason?: NullableStringFieldUpdateOperationsInput | string | null
    origin?: NullableStringFieldUpdateOperationsInput | string | null
    productsales?: productsaleUncheckedUpdateManyWithoutSaleNestedInput
    deliverysales?: deliverysaleUncheckedUpdateManyWithoutSaleNestedInput
    deliveryaddress?: deliveryaddressUncheckedUpdateManyWithoutSaleNestedInput
    payments?: paymentUncheckedUpdateManyWithoutSaleNestedInput
  }

  export type couponUpsertWithoutCouponsalesInput = {
    update: XOR<couponUpdateWithoutCouponsalesInput, couponUncheckedUpdateWithoutCouponsalesInput>
    create: XOR<couponCreateWithoutCouponsalesInput, couponUncheckedCreateWithoutCouponsalesInput>
    where?: couponWhereInput
  }

  export type couponUpdateToOneWithWhereWithoutCouponsalesInput = {
    where?: couponWhereInput
    data: XOR<couponUpdateWithoutCouponsalesInput, couponUncheckedUpdateWithoutCouponsalesInput>
  }

  export type couponUpdateWithoutCouponsalesInput = {
    code?: StringFieldUpdateOperationsInput | string
    discount_type?: NullableStringFieldUpdateOperationsInput | string | null
    discount_value?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    valid_from?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    valid_until?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    brand?: brandUpdateOneWithoutCouponsNestedInput
  }

  export type couponUncheckedUpdateWithoutCouponsalesInput = {
    id?: IntFieldUpdateOperationsInput | number
    brand_id?: NullableIntFieldUpdateOperationsInput | number | null
    code?: StringFieldUpdateOperationsInput | string
    discount_type?: NullableStringFieldUpdateOperationsInput | string | null
    discount_value?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    valid_from?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    valid_until?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type subbrandCreateManyBrandInput = {
    id?: number
    name: string
    created_at?: Date | string | null
  }

  export type storeCreateManyBrandInput = {
    id?: number
    sub_brand_id?: number | null
    name: string
    city?: string | null
    state?: string | null
    district?: string | null
    address_street?: string | null
    address_number?: number | null
    zipcode?: string | null
    latitude?: Decimal | DecimalJsLike | number | string | null
    longitude?: Decimal | DecimalJsLike | number | string | null
    is_active?: boolean | null
    is_own?: boolean | null
    is_holding?: boolean | null
    creation_date?: Date | string | null
    created_at?: Date | string | null
  }

  export type channelCreateManyBrandInput = {
    id?: number
    name: string
    description?: string | null
    type?: string | null
    created_at?: Date | string | null
  }

  export type categoryCreateManyBrandInput = {
    id?: number
    sub_brand_id?: number | null
    name: string
    type?: string | null
    pos_uuid?: string | null
    deleted_at?: Date | string | null
  }

  export type productCreateManyBrandInput = {
    id?: number
    sub_brand_id?: number | null
    category_id?: number | null
    name: string
    pos_uuid?: string | null
    deleted_at?: Date | string | null
  }

  export type optiongroupCreateManyBrandInput = {
    id?: number
    sub_brand_id?: number | null
    category_id?: number | null
    name: string
    pos_uuid?: string | null
    deleted_at?: Date | string | null
  }

  export type itemCreateManyBrandInput = {
    id?: number
    sub_brand_id?: number | null
    category_id?: number | null
    name: string
    pos_uuid?: string | null
    deleted_at?: Date | string | null
  }

  export type paymenttypeCreateManyBrandInput = {
    id?: number
    description: string
  }

  export type couponCreateManyBrandInput = {
    id?: number
    code: string
    discount_type?: string | null
    discount_value?: Decimal | DecimalJsLike | number | string | null
    is_active?: boolean | null
    valid_from?: Date | string | null
    valid_until?: Date | string | null
  }

  export type subbrandUpdateWithoutBrandInput = {
    name?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stores?: storeUpdateManyWithoutSubbrandNestedInput
    categories?: categoryUpdateManyWithoutSubbrandNestedInput
    products?: productUpdateManyWithoutSubbrandNestedInput
    optiongroups?: optiongroupUpdateManyWithoutSubbrandNestedInput
    items?: itemUpdateManyWithoutSubbrandNestedInput
    customers?: customerUpdateManyWithoutSubbrandNestedInput
    sales?: saleUpdateManyWithoutSubbrandNestedInput
  }

  export type subbrandUncheckedUpdateWithoutBrandInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stores?: storeUncheckedUpdateManyWithoutSubbrandNestedInput
    categories?: categoryUncheckedUpdateManyWithoutSubbrandNestedInput
    products?: productUncheckedUpdateManyWithoutSubbrandNestedInput
    optiongroups?: optiongroupUncheckedUpdateManyWithoutSubbrandNestedInput
    items?: itemUncheckedUpdateManyWithoutSubbrandNestedInput
    customers?: customerUncheckedUpdateManyWithoutSubbrandNestedInput
    sales?: saleUncheckedUpdateManyWithoutSubbrandNestedInput
  }

  export type subbrandUncheckedUpdateManyWithoutBrandInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type storeUpdateWithoutBrandInput = {
    name?: StringFieldUpdateOperationsInput | string
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    district?: NullableStringFieldUpdateOperationsInput | string | null
    address_street?: NullableStringFieldUpdateOperationsInput | string | null
    address_number?: NullableIntFieldUpdateOperationsInput | number | null
    zipcode?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    longitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_own?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_holding?: NullableBoolFieldUpdateOperationsInput | boolean | null
    creation_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subbrand?: subbrandUpdateOneWithoutStoresNestedInput
    customers?: customerUpdateManyWithoutStoreNestedInput
    sales?: saleUpdateManyWithoutStoreNestedInput
  }

  export type storeUncheckedUpdateWithoutBrandInput = {
    id?: IntFieldUpdateOperationsInput | number
    sub_brand_id?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    district?: NullableStringFieldUpdateOperationsInput | string | null
    address_street?: NullableStringFieldUpdateOperationsInput | string | null
    address_number?: NullableIntFieldUpdateOperationsInput | number | null
    zipcode?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    longitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_own?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_holding?: NullableBoolFieldUpdateOperationsInput | boolean | null
    creation_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    customers?: customerUncheckedUpdateManyWithoutStoreNestedInput
    sales?: saleUncheckedUpdateManyWithoutStoreNestedInput
  }

  export type storeUncheckedUpdateManyWithoutBrandInput = {
    id?: IntFieldUpdateOperationsInput | number
    sub_brand_id?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    district?: NullableStringFieldUpdateOperationsInput | string | null
    address_street?: NullableStringFieldUpdateOperationsInput | string | null
    address_number?: NullableIntFieldUpdateOperationsInput | number | null
    zipcode?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    longitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_own?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_holding?: NullableBoolFieldUpdateOperationsInput | boolean | null
    creation_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type channelUpdateWithoutBrandInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sales?: saleUpdateManyWithoutChannelNestedInput
  }

  export type channelUncheckedUpdateWithoutBrandInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sales?: saleUncheckedUpdateManyWithoutChannelNestedInput
  }

  export type channelUncheckedUpdateManyWithoutBrandInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type categoryUpdateWithoutBrandInput = {
    name?: StringFieldUpdateOperationsInput | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    pos_uuid?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subbrand?: subbrandUpdateOneWithoutCategoriesNestedInput
    products?: productUpdateManyWithoutCategoryNestedInput
    optiongroups?: optiongroupUpdateManyWithoutCategoryNestedInput
    items?: itemUpdateManyWithoutCategoryNestedInput
  }

  export type categoryUncheckedUpdateWithoutBrandInput = {
    id?: IntFieldUpdateOperationsInput | number
    sub_brand_id?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    pos_uuid?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    products?: productUncheckedUpdateManyWithoutCategoryNestedInput
    optiongroups?: optiongroupUncheckedUpdateManyWithoutCategoryNestedInput
    items?: itemUncheckedUpdateManyWithoutCategoryNestedInput
  }

  export type categoryUncheckedUpdateManyWithoutBrandInput = {
    id?: IntFieldUpdateOperationsInput | number
    sub_brand_id?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    pos_uuid?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type productUpdateWithoutBrandInput = {
    name?: StringFieldUpdateOperationsInput | string
    pos_uuid?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subbrand?: subbrandUpdateOneWithoutProductsNestedInput
    category?: categoryUpdateOneWithoutProductsNestedInput
    productsales?: productsaleUpdateManyWithoutProductNestedInput
  }

  export type productUncheckedUpdateWithoutBrandInput = {
    id?: IntFieldUpdateOperationsInput | number
    sub_brand_id?: NullableIntFieldUpdateOperationsInput | number | null
    category_id?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    pos_uuid?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    productsales?: productsaleUncheckedUpdateManyWithoutProductNestedInput
  }

  export type productUncheckedUpdateManyWithoutBrandInput = {
    id?: IntFieldUpdateOperationsInput | number
    sub_brand_id?: NullableIntFieldUpdateOperationsInput | number | null
    category_id?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    pos_uuid?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type optiongroupUpdateWithoutBrandInput = {
    name?: StringFieldUpdateOperationsInput | string
    pos_uuid?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subbrand?: subbrandUpdateOneWithoutOptiongroupsNestedInput
    category?: categoryUpdateOneWithoutOptiongroupsNestedInput
    itemproductsales?: itemproductsaleUpdateManyWithoutOptiongroupNestedInput
    itemitemproductsales?: itemitemproductsaleUpdateManyWithoutOptiongroupNestedInput
  }

  export type optiongroupUncheckedUpdateWithoutBrandInput = {
    id?: IntFieldUpdateOperationsInput | number
    sub_brand_id?: NullableIntFieldUpdateOperationsInput | number | null
    category_id?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    pos_uuid?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    itemproductsales?: itemproductsaleUncheckedUpdateManyWithoutOptiongroupNestedInput
    itemitemproductsales?: itemitemproductsaleUncheckedUpdateManyWithoutOptiongroupNestedInput
  }

  export type optiongroupUncheckedUpdateManyWithoutBrandInput = {
    id?: IntFieldUpdateOperationsInput | number
    sub_brand_id?: NullableIntFieldUpdateOperationsInput | number | null
    category_id?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    pos_uuid?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type itemUpdateWithoutBrandInput = {
    name?: StringFieldUpdateOperationsInput | string
    pos_uuid?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subbrand?: subbrandUpdateOneWithoutItemsNestedInput
    category?: categoryUpdateOneWithoutItemsNestedInput
    itemproductsales?: itemproductsaleUpdateManyWithoutItemNestedInput
    itemitemproductsales?: itemitemproductsaleUpdateManyWithoutItemNestedInput
  }

  export type itemUncheckedUpdateWithoutBrandInput = {
    id?: IntFieldUpdateOperationsInput | number
    sub_brand_id?: NullableIntFieldUpdateOperationsInput | number | null
    category_id?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    pos_uuid?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    itemproductsales?: itemproductsaleUncheckedUpdateManyWithoutItemNestedInput
    itemitemproductsales?: itemitemproductsaleUncheckedUpdateManyWithoutItemNestedInput
  }

  export type itemUncheckedUpdateManyWithoutBrandInput = {
    id?: IntFieldUpdateOperationsInput | number
    sub_brand_id?: NullableIntFieldUpdateOperationsInput | number | null
    category_id?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    pos_uuid?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type paymenttypeUpdateWithoutBrandInput = {
    description?: StringFieldUpdateOperationsInput | string
    payments?: paymentUpdateManyWithoutPaymenttypeNestedInput
  }

  export type paymenttypeUncheckedUpdateWithoutBrandInput = {
    id?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    payments?: paymentUncheckedUpdateManyWithoutPaymenttypeNestedInput
  }

  export type paymenttypeUncheckedUpdateManyWithoutBrandInput = {
    id?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
  }

  export type couponUpdateWithoutBrandInput = {
    code?: StringFieldUpdateOperationsInput | string
    discount_type?: NullableStringFieldUpdateOperationsInput | string | null
    discount_value?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    valid_from?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    valid_until?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    couponsales?: couponsaleUpdateManyWithoutCouponNestedInput
  }

  export type couponUncheckedUpdateWithoutBrandInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    discount_type?: NullableStringFieldUpdateOperationsInput | string | null
    discount_value?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    valid_from?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    valid_until?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    couponsales?: couponsaleUncheckedUpdateManyWithoutCouponNestedInput
  }

  export type couponUncheckedUpdateManyWithoutBrandInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    discount_type?: NullableStringFieldUpdateOperationsInput | string | null
    discount_value?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    valid_from?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    valid_until?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type storeCreateManySubbrandInput = {
    id?: number
    brand_id: number
    name: string
    city?: string | null
    state?: string | null
    district?: string | null
    address_street?: string | null
    address_number?: number | null
    zipcode?: string | null
    latitude?: Decimal | DecimalJsLike | number | string | null
    longitude?: Decimal | DecimalJsLike | number | string | null
    is_active?: boolean | null
    is_own?: boolean | null
    is_holding?: boolean | null
    creation_date?: Date | string | null
    created_at?: Date | string | null
  }

  export type categoryCreateManySubbrandInput = {
    id?: number
    brand_id: number
    name: string
    type?: string | null
    pos_uuid?: string | null
    deleted_at?: Date | string | null
  }

  export type productCreateManySubbrandInput = {
    id?: number
    brand_id: number
    category_id?: number | null
    name: string
    pos_uuid?: string | null
    deleted_at?: Date | string | null
  }

  export type optiongroupCreateManySubbrandInput = {
    id?: number
    brand_id: number
    category_id?: number | null
    name: string
    pos_uuid?: string | null
    deleted_at?: Date | string | null
  }

  export type itemCreateManySubbrandInput = {
    id?: number
    brand_id: number
    category_id?: number | null
    name: string
    pos_uuid?: string | null
    deleted_at?: Date | string | null
  }

  export type customerCreateManySubbrandInput = {
    id?: number
    customer_name?: string | null
    email?: string | null
    phone_number?: string | null
    cpf?: string | null
    birth_date?: Date | string | null
    gender?: string | null
    store_id?: number | null
    registration_origin?: string | null
    agree_terms?: boolean | null
    receive_promotions_email?: boolean | null
    receive_promotions_sms?: boolean | null
    created_at?: Date | string | null
  }

  export type saleCreateManySubbrandInput = {
    id?: number
    store_id: number
    customer_id?: number | null
    channel_id: number
    cod_sale1?: string | null
    cod_sale2?: string | null
    created_at: Date | string
    customer_name?: string | null
    sale_status_desc: string
    total_amount_items: Decimal | DecimalJsLike | number | string
    total_discount?: Decimal | DecimalJsLike | number | string | null
    total_increase?: Decimal | DecimalJsLike | number | string | null
    delivery_fee?: Decimal | DecimalJsLike | number | string | null
    service_tax_fee?: Decimal | DecimalJsLike | number | string | null
    total_amount: Decimal | DecimalJsLike | number | string
    value_paid?: Decimal | DecimalJsLike | number | string | null
    production_seconds?: number | null
    delivery_seconds?: number | null
    people_quantity?: number | null
    discount_reason?: string | null
    increase_reason?: string | null
    origin?: string | null
  }

  export type storeUpdateWithoutSubbrandInput = {
    name?: StringFieldUpdateOperationsInput | string
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    district?: NullableStringFieldUpdateOperationsInput | string | null
    address_street?: NullableStringFieldUpdateOperationsInput | string | null
    address_number?: NullableIntFieldUpdateOperationsInput | number | null
    zipcode?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    longitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_own?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_holding?: NullableBoolFieldUpdateOperationsInput | boolean | null
    creation_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    brand?: brandUpdateOneRequiredWithoutStoresNestedInput
    customers?: customerUpdateManyWithoutStoreNestedInput
    sales?: saleUpdateManyWithoutStoreNestedInput
  }

  export type storeUncheckedUpdateWithoutSubbrandInput = {
    id?: IntFieldUpdateOperationsInput | number
    brand_id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    district?: NullableStringFieldUpdateOperationsInput | string | null
    address_street?: NullableStringFieldUpdateOperationsInput | string | null
    address_number?: NullableIntFieldUpdateOperationsInput | number | null
    zipcode?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    longitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_own?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_holding?: NullableBoolFieldUpdateOperationsInput | boolean | null
    creation_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    customers?: customerUncheckedUpdateManyWithoutStoreNestedInput
    sales?: saleUncheckedUpdateManyWithoutStoreNestedInput
  }

  export type storeUncheckedUpdateManyWithoutSubbrandInput = {
    id?: IntFieldUpdateOperationsInput | number
    brand_id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    district?: NullableStringFieldUpdateOperationsInput | string | null
    address_street?: NullableStringFieldUpdateOperationsInput | string | null
    address_number?: NullableIntFieldUpdateOperationsInput | number | null
    zipcode?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    longitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_own?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_holding?: NullableBoolFieldUpdateOperationsInput | boolean | null
    creation_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type categoryUpdateWithoutSubbrandInput = {
    name?: StringFieldUpdateOperationsInput | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    pos_uuid?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    brand?: brandUpdateOneRequiredWithoutCategoriesNestedInput
    products?: productUpdateManyWithoutCategoryNestedInput
    optiongroups?: optiongroupUpdateManyWithoutCategoryNestedInput
    items?: itemUpdateManyWithoutCategoryNestedInput
  }

  export type categoryUncheckedUpdateWithoutSubbrandInput = {
    id?: IntFieldUpdateOperationsInput | number
    brand_id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    pos_uuid?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    products?: productUncheckedUpdateManyWithoutCategoryNestedInput
    optiongroups?: optiongroupUncheckedUpdateManyWithoutCategoryNestedInput
    items?: itemUncheckedUpdateManyWithoutCategoryNestedInput
  }

  export type categoryUncheckedUpdateManyWithoutSubbrandInput = {
    id?: IntFieldUpdateOperationsInput | number
    brand_id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    pos_uuid?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type productUpdateWithoutSubbrandInput = {
    name?: StringFieldUpdateOperationsInput | string
    pos_uuid?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    brand?: brandUpdateOneRequiredWithoutProductsNestedInput
    category?: categoryUpdateOneWithoutProductsNestedInput
    productsales?: productsaleUpdateManyWithoutProductNestedInput
  }

  export type productUncheckedUpdateWithoutSubbrandInput = {
    id?: IntFieldUpdateOperationsInput | number
    brand_id?: IntFieldUpdateOperationsInput | number
    category_id?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    pos_uuid?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    productsales?: productsaleUncheckedUpdateManyWithoutProductNestedInput
  }

  export type productUncheckedUpdateManyWithoutSubbrandInput = {
    id?: IntFieldUpdateOperationsInput | number
    brand_id?: IntFieldUpdateOperationsInput | number
    category_id?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    pos_uuid?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type optiongroupUpdateWithoutSubbrandInput = {
    name?: StringFieldUpdateOperationsInput | string
    pos_uuid?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    brand?: brandUpdateOneRequiredWithoutOptiongroupsNestedInput
    category?: categoryUpdateOneWithoutOptiongroupsNestedInput
    itemproductsales?: itemproductsaleUpdateManyWithoutOptiongroupNestedInput
    itemitemproductsales?: itemitemproductsaleUpdateManyWithoutOptiongroupNestedInput
  }

  export type optiongroupUncheckedUpdateWithoutSubbrandInput = {
    id?: IntFieldUpdateOperationsInput | number
    brand_id?: IntFieldUpdateOperationsInput | number
    category_id?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    pos_uuid?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    itemproductsales?: itemproductsaleUncheckedUpdateManyWithoutOptiongroupNestedInput
    itemitemproductsales?: itemitemproductsaleUncheckedUpdateManyWithoutOptiongroupNestedInput
  }

  export type optiongroupUncheckedUpdateManyWithoutSubbrandInput = {
    id?: IntFieldUpdateOperationsInput | number
    brand_id?: IntFieldUpdateOperationsInput | number
    category_id?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    pos_uuid?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type itemUpdateWithoutSubbrandInput = {
    name?: StringFieldUpdateOperationsInput | string
    pos_uuid?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    brand?: brandUpdateOneRequiredWithoutItemsNestedInput
    category?: categoryUpdateOneWithoutItemsNestedInput
    itemproductsales?: itemproductsaleUpdateManyWithoutItemNestedInput
    itemitemproductsales?: itemitemproductsaleUpdateManyWithoutItemNestedInput
  }

  export type itemUncheckedUpdateWithoutSubbrandInput = {
    id?: IntFieldUpdateOperationsInput | number
    brand_id?: IntFieldUpdateOperationsInput | number
    category_id?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    pos_uuid?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    itemproductsales?: itemproductsaleUncheckedUpdateManyWithoutItemNestedInput
    itemitemproductsales?: itemitemproductsaleUncheckedUpdateManyWithoutItemNestedInput
  }

  export type itemUncheckedUpdateManyWithoutSubbrandInput = {
    id?: IntFieldUpdateOperationsInput | number
    brand_id?: IntFieldUpdateOperationsInput | number
    category_id?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    pos_uuid?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type customerUpdateWithoutSubbrandInput = {
    customer_name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    cpf?: NullableStringFieldUpdateOperationsInput | string | null
    birth_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    registration_origin?: NullableStringFieldUpdateOperationsInput | string | null
    agree_terms?: NullableBoolFieldUpdateOperationsInput | boolean | null
    receive_promotions_email?: NullableBoolFieldUpdateOperationsInput | boolean | null
    receive_promotions_sms?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    store?: storeUpdateOneWithoutCustomersNestedInput
    sales?: saleUpdateManyWithoutCustomerNestedInput
  }

  export type customerUncheckedUpdateWithoutSubbrandInput = {
    id?: IntFieldUpdateOperationsInput | number
    customer_name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    cpf?: NullableStringFieldUpdateOperationsInput | string | null
    birth_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    store_id?: NullableIntFieldUpdateOperationsInput | number | null
    registration_origin?: NullableStringFieldUpdateOperationsInput | string | null
    agree_terms?: NullableBoolFieldUpdateOperationsInput | boolean | null
    receive_promotions_email?: NullableBoolFieldUpdateOperationsInput | boolean | null
    receive_promotions_sms?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sales?: saleUncheckedUpdateManyWithoutCustomerNestedInput
  }

  export type customerUncheckedUpdateManyWithoutSubbrandInput = {
    id?: IntFieldUpdateOperationsInput | number
    customer_name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    cpf?: NullableStringFieldUpdateOperationsInput | string | null
    birth_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    store_id?: NullableIntFieldUpdateOperationsInput | number | null
    registration_origin?: NullableStringFieldUpdateOperationsInput | string | null
    agree_terms?: NullableBoolFieldUpdateOperationsInput | boolean | null
    receive_promotions_email?: NullableBoolFieldUpdateOperationsInput | boolean | null
    receive_promotions_sms?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type saleUpdateWithoutSubbrandInput = {
    cod_sale1?: NullableStringFieldUpdateOperationsInput | string | null
    cod_sale2?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    customer_name?: NullableStringFieldUpdateOperationsInput | string | null
    sale_status_desc?: StringFieldUpdateOperationsInput | string
    total_amount_items?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total_discount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    total_increase?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    delivery_fee?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    service_tax_fee?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    total_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    value_paid?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    production_seconds?: NullableIntFieldUpdateOperationsInput | number | null
    delivery_seconds?: NullableIntFieldUpdateOperationsInput | number | null
    people_quantity?: NullableIntFieldUpdateOperationsInput | number | null
    discount_reason?: NullableStringFieldUpdateOperationsInput | string | null
    increase_reason?: NullableStringFieldUpdateOperationsInput | string | null
    origin?: NullableStringFieldUpdateOperationsInput | string | null
    store?: storeUpdateOneRequiredWithoutSalesNestedInput
    customer?: customerUpdateOneWithoutSalesNestedInput
    channel?: channelUpdateOneRequiredWithoutSalesNestedInput
    productsales?: productsaleUpdateManyWithoutSaleNestedInput
    deliverysales?: deliverysaleUpdateManyWithoutSaleNestedInput
    deliveryaddress?: deliveryaddressUpdateManyWithoutSaleNestedInput
    payments?: paymentUpdateManyWithoutSaleNestedInput
    couponsales?: couponsaleUpdateManyWithoutSaleNestedInput
  }

  export type saleUncheckedUpdateWithoutSubbrandInput = {
    id?: IntFieldUpdateOperationsInput | number
    store_id?: IntFieldUpdateOperationsInput | number
    customer_id?: NullableIntFieldUpdateOperationsInput | number | null
    channel_id?: IntFieldUpdateOperationsInput | number
    cod_sale1?: NullableStringFieldUpdateOperationsInput | string | null
    cod_sale2?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    customer_name?: NullableStringFieldUpdateOperationsInput | string | null
    sale_status_desc?: StringFieldUpdateOperationsInput | string
    total_amount_items?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total_discount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    total_increase?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    delivery_fee?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    service_tax_fee?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    total_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    value_paid?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    production_seconds?: NullableIntFieldUpdateOperationsInput | number | null
    delivery_seconds?: NullableIntFieldUpdateOperationsInput | number | null
    people_quantity?: NullableIntFieldUpdateOperationsInput | number | null
    discount_reason?: NullableStringFieldUpdateOperationsInput | string | null
    increase_reason?: NullableStringFieldUpdateOperationsInput | string | null
    origin?: NullableStringFieldUpdateOperationsInput | string | null
    productsales?: productsaleUncheckedUpdateManyWithoutSaleNestedInput
    deliverysales?: deliverysaleUncheckedUpdateManyWithoutSaleNestedInput
    deliveryaddress?: deliveryaddressUncheckedUpdateManyWithoutSaleNestedInput
    payments?: paymentUncheckedUpdateManyWithoutSaleNestedInput
    couponsales?: couponsaleUncheckedUpdateManyWithoutSaleNestedInput
  }

  export type saleUncheckedUpdateManyWithoutSubbrandInput = {
    id?: IntFieldUpdateOperationsInput | number
    store_id?: IntFieldUpdateOperationsInput | number
    customer_id?: NullableIntFieldUpdateOperationsInput | number | null
    channel_id?: IntFieldUpdateOperationsInput | number
    cod_sale1?: NullableStringFieldUpdateOperationsInput | string | null
    cod_sale2?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    customer_name?: NullableStringFieldUpdateOperationsInput | string | null
    sale_status_desc?: StringFieldUpdateOperationsInput | string
    total_amount_items?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total_discount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    total_increase?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    delivery_fee?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    service_tax_fee?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    total_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    value_paid?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    production_seconds?: NullableIntFieldUpdateOperationsInput | number | null
    delivery_seconds?: NullableIntFieldUpdateOperationsInput | number | null
    people_quantity?: NullableIntFieldUpdateOperationsInput | number | null
    discount_reason?: NullableStringFieldUpdateOperationsInput | string | null
    increase_reason?: NullableStringFieldUpdateOperationsInput | string | null
    origin?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type customerCreateManyStoreInput = {
    id?: number
    customer_name?: string | null
    email?: string | null
    phone_number?: string | null
    cpf?: string | null
    birth_date?: Date | string | null
    gender?: string | null
    sub_brand_id?: number | null
    registration_origin?: string | null
    agree_terms?: boolean | null
    receive_promotions_email?: boolean | null
    receive_promotions_sms?: boolean | null
    created_at?: Date | string | null
  }

  export type saleCreateManyStoreInput = {
    id?: number
    sub_brand_id?: number | null
    customer_id?: number | null
    channel_id: number
    cod_sale1?: string | null
    cod_sale2?: string | null
    created_at: Date | string
    customer_name?: string | null
    sale_status_desc: string
    total_amount_items: Decimal | DecimalJsLike | number | string
    total_discount?: Decimal | DecimalJsLike | number | string | null
    total_increase?: Decimal | DecimalJsLike | number | string | null
    delivery_fee?: Decimal | DecimalJsLike | number | string | null
    service_tax_fee?: Decimal | DecimalJsLike | number | string | null
    total_amount: Decimal | DecimalJsLike | number | string
    value_paid?: Decimal | DecimalJsLike | number | string | null
    production_seconds?: number | null
    delivery_seconds?: number | null
    people_quantity?: number | null
    discount_reason?: string | null
    increase_reason?: string | null
    origin?: string | null
  }

  export type customerUpdateWithoutStoreInput = {
    customer_name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    cpf?: NullableStringFieldUpdateOperationsInput | string | null
    birth_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    registration_origin?: NullableStringFieldUpdateOperationsInput | string | null
    agree_terms?: NullableBoolFieldUpdateOperationsInput | boolean | null
    receive_promotions_email?: NullableBoolFieldUpdateOperationsInput | boolean | null
    receive_promotions_sms?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subbrand?: subbrandUpdateOneWithoutCustomersNestedInput
    sales?: saleUpdateManyWithoutCustomerNestedInput
  }

  export type customerUncheckedUpdateWithoutStoreInput = {
    id?: IntFieldUpdateOperationsInput | number
    customer_name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    cpf?: NullableStringFieldUpdateOperationsInput | string | null
    birth_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    sub_brand_id?: NullableIntFieldUpdateOperationsInput | number | null
    registration_origin?: NullableStringFieldUpdateOperationsInput | string | null
    agree_terms?: NullableBoolFieldUpdateOperationsInput | boolean | null
    receive_promotions_email?: NullableBoolFieldUpdateOperationsInput | boolean | null
    receive_promotions_sms?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sales?: saleUncheckedUpdateManyWithoutCustomerNestedInput
  }

  export type customerUncheckedUpdateManyWithoutStoreInput = {
    id?: IntFieldUpdateOperationsInput | number
    customer_name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    cpf?: NullableStringFieldUpdateOperationsInput | string | null
    birth_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    sub_brand_id?: NullableIntFieldUpdateOperationsInput | number | null
    registration_origin?: NullableStringFieldUpdateOperationsInput | string | null
    agree_terms?: NullableBoolFieldUpdateOperationsInput | boolean | null
    receive_promotions_email?: NullableBoolFieldUpdateOperationsInput | boolean | null
    receive_promotions_sms?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type saleUpdateWithoutStoreInput = {
    cod_sale1?: NullableStringFieldUpdateOperationsInput | string | null
    cod_sale2?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    customer_name?: NullableStringFieldUpdateOperationsInput | string | null
    sale_status_desc?: StringFieldUpdateOperationsInput | string
    total_amount_items?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total_discount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    total_increase?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    delivery_fee?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    service_tax_fee?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    total_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    value_paid?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    production_seconds?: NullableIntFieldUpdateOperationsInput | number | null
    delivery_seconds?: NullableIntFieldUpdateOperationsInput | number | null
    people_quantity?: NullableIntFieldUpdateOperationsInput | number | null
    discount_reason?: NullableStringFieldUpdateOperationsInput | string | null
    increase_reason?: NullableStringFieldUpdateOperationsInput | string | null
    origin?: NullableStringFieldUpdateOperationsInput | string | null
    subbrand?: subbrandUpdateOneWithoutSalesNestedInput
    customer?: customerUpdateOneWithoutSalesNestedInput
    channel?: channelUpdateOneRequiredWithoutSalesNestedInput
    productsales?: productsaleUpdateManyWithoutSaleNestedInput
    deliverysales?: deliverysaleUpdateManyWithoutSaleNestedInput
    deliveryaddress?: deliveryaddressUpdateManyWithoutSaleNestedInput
    payments?: paymentUpdateManyWithoutSaleNestedInput
    couponsales?: couponsaleUpdateManyWithoutSaleNestedInput
  }

  export type saleUncheckedUpdateWithoutStoreInput = {
    id?: IntFieldUpdateOperationsInput | number
    sub_brand_id?: NullableIntFieldUpdateOperationsInput | number | null
    customer_id?: NullableIntFieldUpdateOperationsInput | number | null
    channel_id?: IntFieldUpdateOperationsInput | number
    cod_sale1?: NullableStringFieldUpdateOperationsInput | string | null
    cod_sale2?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    customer_name?: NullableStringFieldUpdateOperationsInput | string | null
    sale_status_desc?: StringFieldUpdateOperationsInput | string
    total_amount_items?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total_discount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    total_increase?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    delivery_fee?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    service_tax_fee?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    total_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    value_paid?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    production_seconds?: NullableIntFieldUpdateOperationsInput | number | null
    delivery_seconds?: NullableIntFieldUpdateOperationsInput | number | null
    people_quantity?: NullableIntFieldUpdateOperationsInput | number | null
    discount_reason?: NullableStringFieldUpdateOperationsInput | string | null
    increase_reason?: NullableStringFieldUpdateOperationsInput | string | null
    origin?: NullableStringFieldUpdateOperationsInput | string | null
    productsales?: productsaleUncheckedUpdateManyWithoutSaleNestedInput
    deliverysales?: deliverysaleUncheckedUpdateManyWithoutSaleNestedInput
    deliveryaddress?: deliveryaddressUncheckedUpdateManyWithoutSaleNestedInput
    payments?: paymentUncheckedUpdateManyWithoutSaleNestedInput
    couponsales?: couponsaleUncheckedUpdateManyWithoutSaleNestedInput
  }

  export type saleUncheckedUpdateManyWithoutStoreInput = {
    id?: IntFieldUpdateOperationsInput | number
    sub_brand_id?: NullableIntFieldUpdateOperationsInput | number | null
    customer_id?: NullableIntFieldUpdateOperationsInput | number | null
    channel_id?: IntFieldUpdateOperationsInput | number
    cod_sale1?: NullableStringFieldUpdateOperationsInput | string | null
    cod_sale2?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    customer_name?: NullableStringFieldUpdateOperationsInput | string | null
    sale_status_desc?: StringFieldUpdateOperationsInput | string
    total_amount_items?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total_discount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    total_increase?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    delivery_fee?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    service_tax_fee?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    total_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    value_paid?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    production_seconds?: NullableIntFieldUpdateOperationsInput | number | null
    delivery_seconds?: NullableIntFieldUpdateOperationsInput | number | null
    people_quantity?: NullableIntFieldUpdateOperationsInput | number | null
    discount_reason?: NullableStringFieldUpdateOperationsInput | string | null
    increase_reason?: NullableStringFieldUpdateOperationsInput | string | null
    origin?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type saleCreateManyChannelInput = {
    id?: number
    store_id: number
    sub_brand_id?: number | null
    customer_id?: number | null
    cod_sale1?: string | null
    cod_sale2?: string | null
    created_at: Date | string
    customer_name?: string | null
    sale_status_desc: string
    total_amount_items: Decimal | DecimalJsLike | number | string
    total_discount?: Decimal | DecimalJsLike | number | string | null
    total_increase?: Decimal | DecimalJsLike | number | string | null
    delivery_fee?: Decimal | DecimalJsLike | number | string | null
    service_tax_fee?: Decimal | DecimalJsLike | number | string | null
    total_amount: Decimal | DecimalJsLike | number | string
    value_paid?: Decimal | DecimalJsLike | number | string | null
    production_seconds?: number | null
    delivery_seconds?: number | null
    people_quantity?: number | null
    discount_reason?: string | null
    increase_reason?: string | null
    origin?: string | null
  }

  export type saleUpdateWithoutChannelInput = {
    cod_sale1?: NullableStringFieldUpdateOperationsInput | string | null
    cod_sale2?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    customer_name?: NullableStringFieldUpdateOperationsInput | string | null
    sale_status_desc?: StringFieldUpdateOperationsInput | string
    total_amount_items?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total_discount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    total_increase?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    delivery_fee?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    service_tax_fee?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    total_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    value_paid?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    production_seconds?: NullableIntFieldUpdateOperationsInput | number | null
    delivery_seconds?: NullableIntFieldUpdateOperationsInput | number | null
    people_quantity?: NullableIntFieldUpdateOperationsInput | number | null
    discount_reason?: NullableStringFieldUpdateOperationsInput | string | null
    increase_reason?: NullableStringFieldUpdateOperationsInput | string | null
    origin?: NullableStringFieldUpdateOperationsInput | string | null
    store?: storeUpdateOneRequiredWithoutSalesNestedInput
    subbrand?: subbrandUpdateOneWithoutSalesNestedInput
    customer?: customerUpdateOneWithoutSalesNestedInput
    productsales?: productsaleUpdateManyWithoutSaleNestedInput
    deliverysales?: deliverysaleUpdateManyWithoutSaleNestedInput
    deliveryaddress?: deliveryaddressUpdateManyWithoutSaleNestedInput
    payments?: paymentUpdateManyWithoutSaleNestedInput
    couponsales?: couponsaleUpdateManyWithoutSaleNestedInput
  }

  export type saleUncheckedUpdateWithoutChannelInput = {
    id?: IntFieldUpdateOperationsInput | number
    store_id?: IntFieldUpdateOperationsInput | number
    sub_brand_id?: NullableIntFieldUpdateOperationsInput | number | null
    customer_id?: NullableIntFieldUpdateOperationsInput | number | null
    cod_sale1?: NullableStringFieldUpdateOperationsInput | string | null
    cod_sale2?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    customer_name?: NullableStringFieldUpdateOperationsInput | string | null
    sale_status_desc?: StringFieldUpdateOperationsInput | string
    total_amount_items?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total_discount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    total_increase?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    delivery_fee?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    service_tax_fee?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    total_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    value_paid?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    production_seconds?: NullableIntFieldUpdateOperationsInput | number | null
    delivery_seconds?: NullableIntFieldUpdateOperationsInput | number | null
    people_quantity?: NullableIntFieldUpdateOperationsInput | number | null
    discount_reason?: NullableStringFieldUpdateOperationsInput | string | null
    increase_reason?: NullableStringFieldUpdateOperationsInput | string | null
    origin?: NullableStringFieldUpdateOperationsInput | string | null
    productsales?: productsaleUncheckedUpdateManyWithoutSaleNestedInput
    deliverysales?: deliverysaleUncheckedUpdateManyWithoutSaleNestedInput
    deliveryaddress?: deliveryaddressUncheckedUpdateManyWithoutSaleNestedInput
    payments?: paymentUncheckedUpdateManyWithoutSaleNestedInput
    couponsales?: couponsaleUncheckedUpdateManyWithoutSaleNestedInput
  }

  export type saleUncheckedUpdateManyWithoutChannelInput = {
    id?: IntFieldUpdateOperationsInput | number
    store_id?: IntFieldUpdateOperationsInput | number
    sub_brand_id?: NullableIntFieldUpdateOperationsInput | number | null
    customer_id?: NullableIntFieldUpdateOperationsInput | number | null
    cod_sale1?: NullableStringFieldUpdateOperationsInput | string | null
    cod_sale2?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    customer_name?: NullableStringFieldUpdateOperationsInput | string | null
    sale_status_desc?: StringFieldUpdateOperationsInput | string
    total_amount_items?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total_discount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    total_increase?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    delivery_fee?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    service_tax_fee?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    total_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    value_paid?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    production_seconds?: NullableIntFieldUpdateOperationsInput | number | null
    delivery_seconds?: NullableIntFieldUpdateOperationsInput | number | null
    people_quantity?: NullableIntFieldUpdateOperationsInput | number | null
    discount_reason?: NullableStringFieldUpdateOperationsInput | string | null
    increase_reason?: NullableStringFieldUpdateOperationsInput | string | null
    origin?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type productCreateManyCategoryInput = {
    id?: number
    brand_id: number
    sub_brand_id?: number | null
    name: string
    pos_uuid?: string | null
    deleted_at?: Date | string | null
  }

  export type optiongroupCreateManyCategoryInput = {
    id?: number
    brand_id: number
    sub_brand_id?: number | null
    name: string
    pos_uuid?: string | null
    deleted_at?: Date | string | null
  }

  export type itemCreateManyCategoryInput = {
    id?: number
    brand_id: number
    sub_brand_id?: number | null
    name: string
    pos_uuid?: string | null
    deleted_at?: Date | string | null
  }

  export type productUpdateWithoutCategoryInput = {
    name?: StringFieldUpdateOperationsInput | string
    pos_uuid?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    brand?: brandUpdateOneRequiredWithoutProductsNestedInput
    subbrand?: subbrandUpdateOneWithoutProductsNestedInput
    productsales?: productsaleUpdateManyWithoutProductNestedInput
  }

  export type productUncheckedUpdateWithoutCategoryInput = {
    id?: IntFieldUpdateOperationsInput | number
    brand_id?: IntFieldUpdateOperationsInput | number
    sub_brand_id?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    pos_uuid?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    productsales?: productsaleUncheckedUpdateManyWithoutProductNestedInput
  }

  export type productUncheckedUpdateManyWithoutCategoryInput = {
    id?: IntFieldUpdateOperationsInput | number
    brand_id?: IntFieldUpdateOperationsInput | number
    sub_brand_id?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    pos_uuid?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type optiongroupUpdateWithoutCategoryInput = {
    name?: StringFieldUpdateOperationsInput | string
    pos_uuid?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    brand?: brandUpdateOneRequiredWithoutOptiongroupsNestedInput
    subbrand?: subbrandUpdateOneWithoutOptiongroupsNestedInput
    itemproductsales?: itemproductsaleUpdateManyWithoutOptiongroupNestedInput
    itemitemproductsales?: itemitemproductsaleUpdateManyWithoutOptiongroupNestedInput
  }

  export type optiongroupUncheckedUpdateWithoutCategoryInput = {
    id?: IntFieldUpdateOperationsInput | number
    brand_id?: IntFieldUpdateOperationsInput | number
    sub_brand_id?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    pos_uuid?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    itemproductsales?: itemproductsaleUncheckedUpdateManyWithoutOptiongroupNestedInput
    itemitemproductsales?: itemitemproductsaleUncheckedUpdateManyWithoutOptiongroupNestedInput
  }

  export type optiongroupUncheckedUpdateManyWithoutCategoryInput = {
    id?: IntFieldUpdateOperationsInput | number
    brand_id?: IntFieldUpdateOperationsInput | number
    sub_brand_id?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    pos_uuid?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type itemUpdateWithoutCategoryInput = {
    name?: StringFieldUpdateOperationsInput | string
    pos_uuid?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    brand?: brandUpdateOneRequiredWithoutItemsNestedInput
    subbrand?: subbrandUpdateOneWithoutItemsNestedInput
    itemproductsales?: itemproductsaleUpdateManyWithoutItemNestedInput
    itemitemproductsales?: itemitemproductsaleUpdateManyWithoutItemNestedInput
  }

  export type itemUncheckedUpdateWithoutCategoryInput = {
    id?: IntFieldUpdateOperationsInput | number
    brand_id?: IntFieldUpdateOperationsInput | number
    sub_brand_id?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    pos_uuid?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    itemproductsales?: itemproductsaleUncheckedUpdateManyWithoutItemNestedInput
    itemitemproductsales?: itemitemproductsaleUncheckedUpdateManyWithoutItemNestedInput
  }

  export type itemUncheckedUpdateManyWithoutCategoryInput = {
    id?: IntFieldUpdateOperationsInput | number
    brand_id?: IntFieldUpdateOperationsInput | number
    sub_brand_id?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    pos_uuid?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type productsaleCreateManyProductInput = {
    id?: number
    sale_id: number
    quantity: number
    base_price: number
    total_price: number
    observations?: string | null
  }

  export type productsaleUpdateWithoutProductInput = {
    quantity?: FloatFieldUpdateOperationsInput | number
    base_price?: FloatFieldUpdateOperationsInput | number
    total_price?: FloatFieldUpdateOperationsInput | number
    observations?: NullableStringFieldUpdateOperationsInput | string | null
    sale?: saleUpdateOneRequiredWithoutProductsalesNestedInput
    itemproductsales?: itemproductsaleUpdateManyWithoutProductsaleNestedInput
  }

  export type productsaleUncheckedUpdateWithoutProductInput = {
    id?: IntFieldUpdateOperationsInput | number
    sale_id?: IntFieldUpdateOperationsInput | number
    quantity?: FloatFieldUpdateOperationsInput | number
    base_price?: FloatFieldUpdateOperationsInput | number
    total_price?: FloatFieldUpdateOperationsInput | number
    observations?: NullableStringFieldUpdateOperationsInput | string | null
    itemproductsales?: itemproductsaleUncheckedUpdateManyWithoutProductsaleNestedInput
  }

  export type productsaleUncheckedUpdateManyWithoutProductInput = {
    id?: IntFieldUpdateOperationsInput | number
    sale_id?: IntFieldUpdateOperationsInput | number
    quantity?: FloatFieldUpdateOperationsInput | number
    base_price?: FloatFieldUpdateOperationsInput | number
    total_price?: FloatFieldUpdateOperationsInput | number
    observations?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type itemproductsaleCreateManyOptiongroupInput = {
    id?: number
    product_sale_id: number
    item_id: number
    quantity: number
    additional_price: number
    price: number
    amount?: number | null
    observations?: string | null
  }

  export type itemitemproductsaleCreateManyOptiongroupInput = {
    id?: number
    item_product_sale_id: number
    item_id: number
    quantity: number
    additional_price: number
    price: number
    amount?: number | null
  }

  export type itemproductsaleUpdateWithoutOptiongroupInput = {
    quantity?: FloatFieldUpdateOperationsInput | number
    additional_price?: FloatFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    observations?: NullableStringFieldUpdateOperationsInput | string | null
    productsale?: productsaleUpdateOneRequiredWithoutItemproductsalesNestedInput
    item?: itemUpdateOneRequiredWithoutItemproductsalesNestedInput
    itemitemproductsales?: itemitemproductsaleUpdateManyWithoutItemproductsaleNestedInput
  }

  export type itemproductsaleUncheckedUpdateWithoutOptiongroupInput = {
    id?: IntFieldUpdateOperationsInput | number
    product_sale_id?: IntFieldUpdateOperationsInput | number
    item_id?: IntFieldUpdateOperationsInput | number
    quantity?: FloatFieldUpdateOperationsInput | number
    additional_price?: FloatFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    observations?: NullableStringFieldUpdateOperationsInput | string | null
    itemitemproductsales?: itemitemproductsaleUncheckedUpdateManyWithoutItemproductsaleNestedInput
  }

  export type itemproductsaleUncheckedUpdateManyWithoutOptiongroupInput = {
    id?: IntFieldUpdateOperationsInput | number
    product_sale_id?: IntFieldUpdateOperationsInput | number
    item_id?: IntFieldUpdateOperationsInput | number
    quantity?: FloatFieldUpdateOperationsInput | number
    additional_price?: FloatFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    observations?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type itemitemproductsaleUpdateWithoutOptiongroupInput = {
    quantity?: FloatFieldUpdateOperationsInput | number
    additional_price?: FloatFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    itemproductsale?: itemproductsaleUpdateOneRequiredWithoutItemitemproductsalesNestedInput
    item?: itemUpdateOneRequiredWithoutItemitemproductsalesNestedInput
  }

  export type itemitemproductsaleUncheckedUpdateWithoutOptiongroupInput = {
    id?: IntFieldUpdateOperationsInput | number
    item_product_sale_id?: IntFieldUpdateOperationsInput | number
    item_id?: IntFieldUpdateOperationsInput | number
    quantity?: FloatFieldUpdateOperationsInput | number
    additional_price?: FloatFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type itemitemproductsaleUncheckedUpdateManyWithoutOptiongroupInput = {
    id?: IntFieldUpdateOperationsInput | number
    item_product_sale_id?: IntFieldUpdateOperationsInput | number
    item_id?: IntFieldUpdateOperationsInput | number
    quantity?: FloatFieldUpdateOperationsInput | number
    additional_price?: FloatFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type itemproductsaleCreateManyItemInput = {
    id?: number
    product_sale_id: number
    option_group_id?: number | null
    quantity: number
    additional_price: number
    price: number
    amount?: number | null
    observations?: string | null
  }

  export type itemitemproductsaleCreateManyItemInput = {
    id?: number
    item_product_sale_id: number
    option_group_id?: number | null
    quantity: number
    additional_price: number
    price: number
    amount?: number | null
  }

  export type itemproductsaleUpdateWithoutItemInput = {
    quantity?: FloatFieldUpdateOperationsInput | number
    additional_price?: FloatFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    observations?: NullableStringFieldUpdateOperationsInput | string | null
    productsale?: productsaleUpdateOneRequiredWithoutItemproductsalesNestedInput
    optiongroup?: optiongroupUpdateOneWithoutItemproductsalesNestedInput
    itemitemproductsales?: itemitemproductsaleUpdateManyWithoutItemproductsaleNestedInput
  }

  export type itemproductsaleUncheckedUpdateWithoutItemInput = {
    id?: IntFieldUpdateOperationsInput | number
    product_sale_id?: IntFieldUpdateOperationsInput | number
    option_group_id?: NullableIntFieldUpdateOperationsInput | number | null
    quantity?: FloatFieldUpdateOperationsInput | number
    additional_price?: FloatFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    observations?: NullableStringFieldUpdateOperationsInput | string | null
    itemitemproductsales?: itemitemproductsaleUncheckedUpdateManyWithoutItemproductsaleNestedInput
  }

  export type itemproductsaleUncheckedUpdateManyWithoutItemInput = {
    id?: IntFieldUpdateOperationsInput | number
    product_sale_id?: IntFieldUpdateOperationsInput | number
    option_group_id?: NullableIntFieldUpdateOperationsInput | number | null
    quantity?: FloatFieldUpdateOperationsInput | number
    additional_price?: FloatFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    observations?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type itemitemproductsaleUpdateWithoutItemInput = {
    quantity?: FloatFieldUpdateOperationsInput | number
    additional_price?: FloatFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    itemproductsale?: itemproductsaleUpdateOneRequiredWithoutItemitemproductsalesNestedInput
    optiongroup?: optiongroupUpdateOneWithoutItemitemproductsalesNestedInput
  }

  export type itemitemproductsaleUncheckedUpdateWithoutItemInput = {
    id?: IntFieldUpdateOperationsInput | number
    item_product_sale_id?: IntFieldUpdateOperationsInput | number
    option_group_id?: NullableIntFieldUpdateOperationsInput | number | null
    quantity?: FloatFieldUpdateOperationsInput | number
    additional_price?: FloatFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type itemitemproductsaleUncheckedUpdateManyWithoutItemInput = {
    id?: IntFieldUpdateOperationsInput | number
    item_product_sale_id?: IntFieldUpdateOperationsInput | number
    option_group_id?: NullableIntFieldUpdateOperationsInput | number | null
    quantity?: FloatFieldUpdateOperationsInput | number
    additional_price?: FloatFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type saleCreateManyCustomerInput = {
    id?: number
    store_id: number
    sub_brand_id?: number | null
    channel_id: number
    cod_sale1?: string | null
    cod_sale2?: string | null
    created_at: Date | string
    customer_name?: string | null
    sale_status_desc: string
    total_amount_items: Decimal | DecimalJsLike | number | string
    total_discount?: Decimal | DecimalJsLike | number | string | null
    total_increase?: Decimal | DecimalJsLike | number | string | null
    delivery_fee?: Decimal | DecimalJsLike | number | string | null
    service_tax_fee?: Decimal | DecimalJsLike | number | string | null
    total_amount: Decimal | DecimalJsLike | number | string
    value_paid?: Decimal | DecimalJsLike | number | string | null
    production_seconds?: number | null
    delivery_seconds?: number | null
    people_quantity?: number | null
    discount_reason?: string | null
    increase_reason?: string | null
    origin?: string | null
  }

  export type saleUpdateWithoutCustomerInput = {
    cod_sale1?: NullableStringFieldUpdateOperationsInput | string | null
    cod_sale2?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    customer_name?: NullableStringFieldUpdateOperationsInput | string | null
    sale_status_desc?: StringFieldUpdateOperationsInput | string
    total_amount_items?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total_discount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    total_increase?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    delivery_fee?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    service_tax_fee?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    total_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    value_paid?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    production_seconds?: NullableIntFieldUpdateOperationsInput | number | null
    delivery_seconds?: NullableIntFieldUpdateOperationsInput | number | null
    people_quantity?: NullableIntFieldUpdateOperationsInput | number | null
    discount_reason?: NullableStringFieldUpdateOperationsInput | string | null
    increase_reason?: NullableStringFieldUpdateOperationsInput | string | null
    origin?: NullableStringFieldUpdateOperationsInput | string | null
    store?: storeUpdateOneRequiredWithoutSalesNestedInput
    subbrand?: subbrandUpdateOneWithoutSalesNestedInput
    channel?: channelUpdateOneRequiredWithoutSalesNestedInput
    productsales?: productsaleUpdateManyWithoutSaleNestedInput
    deliverysales?: deliverysaleUpdateManyWithoutSaleNestedInput
    deliveryaddress?: deliveryaddressUpdateManyWithoutSaleNestedInput
    payments?: paymentUpdateManyWithoutSaleNestedInput
    couponsales?: couponsaleUpdateManyWithoutSaleNestedInput
  }

  export type saleUncheckedUpdateWithoutCustomerInput = {
    id?: IntFieldUpdateOperationsInput | number
    store_id?: IntFieldUpdateOperationsInput | number
    sub_brand_id?: NullableIntFieldUpdateOperationsInput | number | null
    channel_id?: IntFieldUpdateOperationsInput | number
    cod_sale1?: NullableStringFieldUpdateOperationsInput | string | null
    cod_sale2?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    customer_name?: NullableStringFieldUpdateOperationsInput | string | null
    sale_status_desc?: StringFieldUpdateOperationsInput | string
    total_amount_items?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total_discount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    total_increase?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    delivery_fee?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    service_tax_fee?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    total_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    value_paid?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    production_seconds?: NullableIntFieldUpdateOperationsInput | number | null
    delivery_seconds?: NullableIntFieldUpdateOperationsInput | number | null
    people_quantity?: NullableIntFieldUpdateOperationsInput | number | null
    discount_reason?: NullableStringFieldUpdateOperationsInput | string | null
    increase_reason?: NullableStringFieldUpdateOperationsInput | string | null
    origin?: NullableStringFieldUpdateOperationsInput | string | null
    productsales?: productsaleUncheckedUpdateManyWithoutSaleNestedInput
    deliverysales?: deliverysaleUncheckedUpdateManyWithoutSaleNestedInput
    deliveryaddress?: deliveryaddressUncheckedUpdateManyWithoutSaleNestedInput
    payments?: paymentUncheckedUpdateManyWithoutSaleNestedInput
    couponsales?: couponsaleUncheckedUpdateManyWithoutSaleNestedInput
  }

  export type saleUncheckedUpdateManyWithoutCustomerInput = {
    id?: IntFieldUpdateOperationsInput | number
    store_id?: IntFieldUpdateOperationsInput | number
    sub_brand_id?: NullableIntFieldUpdateOperationsInput | number | null
    channel_id?: IntFieldUpdateOperationsInput | number
    cod_sale1?: NullableStringFieldUpdateOperationsInput | string | null
    cod_sale2?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    customer_name?: NullableStringFieldUpdateOperationsInput | string | null
    sale_status_desc?: StringFieldUpdateOperationsInput | string
    total_amount_items?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total_discount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    total_increase?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    delivery_fee?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    service_tax_fee?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    total_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    value_paid?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    production_seconds?: NullableIntFieldUpdateOperationsInput | number | null
    delivery_seconds?: NullableIntFieldUpdateOperationsInput | number | null
    people_quantity?: NullableIntFieldUpdateOperationsInput | number | null
    discount_reason?: NullableStringFieldUpdateOperationsInput | string | null
    increase_reason?: NullableStringFieldUpdateOperationsInput | string | null
    origin?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type productsaleCreateManySaleInput = {
    id?: number
    product_id: number
    quantity: number
    base_price: number
    total_price: number
    observations?: string | null
  }

  export type deliverysaleCreateManySaleInput = {
    id?: number
    courier_id?: string | null
    courier_name?: string | null
    courier_phone?: string | null
    courier_type?: string | null
    delivered_by?: string | null
    delivery_type?: string | null
    status?: string | null
    delivery_fee?: number | null
    courier_fee?: number | null
    timing?: string | null
    mode?: string | null
  }

  export type deliveryaddressCreateManySaleInput = {
    id?: number
    delivery_sale_id?: number | null
    street?: string | null
    number?: string | null
    complement?: string | null
    formatted_address?: string | null
    neighborhood?: string | null
    city?: string | null
    state?: string | null
    country?: string | null
    postal_code?: string | null
    reference?: string | null
    latitude?: number | null
    longitude?: number | null
  }

  export type paymentCreateManySaleInput = {
    id?: number
    payment_type_id?: number | null
    value: Decimal | DecimalJsLike | number | string
    is_online?: boolean | null
    description?: string | null
    currency?: string | null
  }

  export type couponsaleCreateManySaleInput = {
    id?: number
    coupon_id?: number | null
    value?: number | null
    target?: string | null
    sponsorship?: string | null
  }

  export type productsaleUpdateWithoutSaleInput = {
    quantity?: FloatFieldUpdateOperationsInput | number
    base_price?: FloatFieldUpdateOperationsInput | number
    total_price?: FloatFieldUpdateOperationsInput | number
    observations?: NullableStringFieldUpdateOperationsInput | string | null
    product?: productUpdateOneRequiredWithoutProductsalesNestedInput
    itemproductsales?: itemproductsaleUpdateManyWithoutProductsaleNestedInput
  }

  export type productsaleUncheckedUpdateWithoutSaleInput = {
    id?: IntFieldUpdateOperationsInput | number
    product_id?: IntFieldUpdateOperationsInput | number
    quantity?: FloatFieldUpdateOperationsInput | number
    base_price?: FloatFieldUpdateOperationsInput | number
    total_price?: FloatFieldUpdateOperationsInput | number
    observations?: NullableStringFieldUpdateOperationsInput | string | null
    itemproductsales?: itemproductsaleUncheckedUpdateManyWithoutProductsaleNestedInput
  }

  export type productsaleUncheckedUpdateManyWithoutSaleInput = {
    id?: IntFieldUpdateOperationsInput | number
    product_id?: IntFieldUpdateOperationsInput | number
    quantity?: FloatFieldUpdateOperationsInput | number
    base_price?: FloatFieldUpdateOperationsInput | number
    total_price?: FloatFieldUpdateOperationsInput | number
    observations?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type deliverysaleUpdateWithoutSaleInput = {
    courier_id?: NullableStringFieldUpdateOperationsInput | string | null
    courier_name?: NullableStringFieldUpdateOperationsInput | string | null
    courier_phone?: NullableStringFieldUpdateOperationsInput | string | null
    courier_type?: NullableStringFieldUpdateOperationsInput | string | null
    delivered_by?: NullableStringFieldUpdateOperationsInput | string | null
    delivery_type?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    delivery_fee?: NullableFloatFieldUpdateOperationsInput | number | null
    courier_fee?: NullableFloatFieldUpdateOperationsInput | number | null
    timing?: NullableStringFieldUpdateOperationsInput | string | null
    mode?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryaddresses?: deliveryaddressUpdateManyWithoutDeliverysaleNestedInput
  }

  export type deliverysaleUncheckedUpdateWithoutSaleInput = {
    id?: IntFieldUpdateOperationsInput | number
    courier_id?: NullableStringFieldUpdateOperationsInput | string | null
    courier_name?: NullableStringFieldUpdateOperationsInput | string | null
    courier_phone?: NullableStringFieldUpdateOperationsInput | string | null
    courier_type?: NullableStringFieldUpdateOperationsInput | string | null
    delivered_by?: NullableStringFieldUpdateOperationsInput | string | null
    delivery_type?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    delivery_fee?: NullableFloatFieldUpdateOperationsInput | number | null
    courier_fee?: NullableFloatFieldUpdateOperationsInput | number | null
    timing?: NullableStringFieldUpdateOperationsInput | string | null
    mode?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryaddresses?: deliveryaddressUncheckedUpdateManyWithoutDeliverysaleNestedInput
  }

  export type deliverysaleUncheckedUpdateManyWithoutSaleInput = {
    id?: IntFieldUpdateOperationsInput | number
    courier_id?: NullableStringFieldUpdateOperationsInput | string | null
    courier_name?: NullableStringFieldUpdateOperationsInput | string | null
    courier_phone?: NullableStringFieldUpdateOperationsInput | string | null
    courier_type?: NullableStringFieldUpdateOperationsInput | string | null
    delivered_by?: NullableStringFieldUpdateOperationsInput | string | null
    delivery_type?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    delivery_fee?: NullableFloatFieldUpdateOperationsInput | number | null
    courier_fee?: NullableFloatFieldUpdateOperationsInput | number | null
    timing?: NullableStringFieldUpdateOperationsInput | string | null
    mode?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type deliveryaddressUpdateWithoutSaleInput = {
    street?: NullableStringFieldUpdateOperationsInput | string | null
    number?: NullableStringFieldUpdateOperationsInput | string | null
    complement?: NullableStringFieldUpdateOperationsInput | string | null
    formatted_address?: NullableStringFieldUpdateOperationsInput | string | null
    neighborhood?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    postal_code?: NullableStringFieldUpdateOperationsInput | string | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    deliverysale?: deliverysaleUpdateOneWithoutDeliveryaddressesNestedInput
  }

  export type deliveryaddressUncheckedUpdateWithoutSaleInput = {
    id?: IntFieldUpdateOperationsInput | number
    delivery_sale_id?: NullableIntFieldUpdateOperationsInput | number | null
    street?: NullableStringFieldUpdateOperationsInput | string | null
    number?: NullableStringFieldUpdateOperationsInput | string | null
    complement?: NullableStringFieldUpdateOperationsInput | string | null
    formatted_address?: NullableStringFieldUpdateOperationsInput | string | null
    neighborhood?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    postal_code?: NullableStringFieldUpdateOperationsInput | string | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type deliveryaddressUncheckedUpdateManyWithoutSaleInput = {
    id?: IntFieldUpdateOperationsInput | number
    delivery_sale_id?: NullableIntFieldUpdateOperationsInput | number | null
    street?: NullableStringFieldUpdateOperationsInput | string | null
    number?: NullableStringFieldUpdateOperationsInput | string | null
    complement?: NullableStringFieldUpdateOperationsInput | string | null
    formatted_address?: NullableStringFieldUpdateOperationsInput | string | null
    neighborhood?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    postal_code?: NullableStringFieldUpdateOperationsInput | string | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type paymentUpdateWithoutSaleInput = {
    value?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    is_online?: NullableBoolFieldUpdateOperationsInput | boolean | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    paymenttype?: paymenttypeUpdateOneWithoutPaymentsNestedInput
  }

  export type paymentUncheckedUpdateWithoutSaleInput = {
    id?: IntFieldUpdateOperationsInput | number
    payment_type_id?: NullableIntFieldUpdateOperationsInput | number | null
    value?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    is_online?: NullableBoolFieldUpdateOperationsInput | boolean | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type paymentUncheckedUpdateManyWithoutSaleInput = {
    id?: IntFieldUpdateOperationsInput | number
    payment_type_id?: NullableIntFieldUpdateOperationsInput | number | null
    value?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    is_online?: NullableBoolFieldUpdateOperationsInput | boolean | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type couponsaleUpdateWithoutSaleInput = {
    value?: NullableFloatFieldUpdateOperationsInput | number | null
    target?: NullableStringFieldUpdateOperationsInput | string | null
    sponsorship?: NullableStringFieldUpdateOperationsInput | string | null
    coupon?: couponUpdateOneWithoutCouponsalesNestedInput
  }

  export type couponsaleUncheckedUpdateWithoutSaleInput = {
    id?: IntFieldUpdateOperationsInput | number
    coupon_id?: NullableIntFieldUpdateOperationsInput | number | null
    value?: NullableFloatFieldUpdateOperationsInput | number | null
    target?: NullableStringFieldUpdateOperationsInput | string | null
    sponsorship?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type couponsaleUncheckedUpdateManyWithoutSaleInput = {
    id?: IntFieldUpdateOperationsInput | number
    coupon_id?: NullableIntFieldUpdateOperationsInput | number | null
    value?: NullableFloatFieldUpdateOperationsInput | number | null
    target?: NullableStringFieldUpdateOperationsInput | string | null
    sponsorship?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type itemproductsaleCreateManyProductsaleInput = {
    id?: number
    item_id: number
    option_group_id?: number | null
    quantity: number
    additional_price: number
    price: number
    amount?: number | null
    observations?: string | null
  }

  export type itemproductsaleUpdateWithoutProductsaleInput = {
    quantity?: FloatFieldUpdateOperationsInput | number
    additional_price?: FloatFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    observations?: NullableStringFieldUpdateOperationsInput | string | null
    item?: itemUpdateOneRequiredWithoutItemproductsalesNestedInput
    optiongroup?: optiongroupUpdateOneWithoutItemproductsalesNestedInput
    itemitemproductsales?: itemitemproductsaleUpdateManyWithoutItemproductsaleNestedInput
  }

  export type itemproductsaleUncheckedUpdateWithoutProductsaleInput = {
    id?: IntFieldUpdateOperationsInput | number
    item_id?: IntFieldUpdateOperationsInput | number
    option_group_id?: NullableIntFieldUpdateOperationsInput | number | null
    quantity?: FloatFieldUpdateOperationsInput | number
    additional_price?: FloatFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    observations?: NullableStringFieldUpdateOperationsInput | string | null
    itemitemproductsales?: itemitemproductsaleUncheckedUpdateManyWithoutItemproductsaleNestedInput
  }

  export type itemproductsaleUncheckedUpdateManyWithoutProductsaleInput = {
    id?: IntFieldUpdateOperationsInput | number
    item_id?: IntFieldUpdateOperationsInput | number
    option_group_id?: NullableIntFieldUpdateOperationsInput | number | null
    quantity?: FloatFieldUpdateOperationsInput | number
    additional_price?: FloatFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    observations?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type itemitemproductsaleCreateManyItemproductsaleInput = {
    id?: number
    item_id: number
    option_group_id?: number | null
    quantity: number
    additional_price: number
    price: number
    amount?: number | null
  }

  export type itemitemproductsaleUpdateWithoutItemproductsaleInput = {
    quantity?: FloatFieldUpdateOperationsInput | number
    additional_price?: FloatFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    item?: itemUpdateOneRequiredWithoutItemitemproductsalesNestedInput
    optiongroup?: optiongroupUpdateOneWithoutItemitemproductsalesNestedInput
  }

  export type itemitemproductsaleUncheckedUpdateWithoutItemproductsaleInput = {
    id?: IntFieldUpdateOperationsInput | number
    item_id?: IntFieldUpdateOperationsInput | number
    option_group_id?: NullableIntFieldUpdateOperationsInput | number | null
    quantity?: FloatFieldUpdateOperationsInput | number
    additional_price?: FloatFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type itemitemproductsaleUncheckedUpdateManyWithoutItemproductsaleInput = {
    id?: IntFieldUpdateOperationsInput | number
    item_id?: IntFieldUpdateOperationsInput | number
    option_group_id?: NullableIntFieldUpdateOperationsInput | number | null
    quantity?: FloatFieldUpdateOperationsInput | number
    additional_price?: FloatFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type deliveryaddressCreateManyDeliverysaleInput = {
    id?: number
    sale_id: number
    street?: string | null
    number?: string | null
    complement?: string | null
    formatted_address?: string | null
    neighborhood?: string | null
    city?: string | null
    state?: string | null
    country?: string | null
    postal_code?: string | null
    reference?: string | null
    latitude?: number | null
    longitude?: number | null
  }

  export type deliveryaddressUpdateWithoutDeliverysaleInput = {
    street?: NullableStringFieldUpdateOperationsInput | string | null
    number?: NullableStringFieldUpdateOperationsInput | string | null
    complement?: NullableStringFieldUpdateOperationsInput | string | null
    formatted_address?: NullableStringFieldUpdateOperationsInput | string | null
    neighborhood?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    postal_code?: NullableStringFieldUpdateOperationsInput | string | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    sale?: saleUpdateOneRequiredWithoutDeliveryaddressNestedInput
  }

  export type deliveryaddressUncheckedUpdateWithoutDeliverysaleInput = {
    id?: IntFieldUpdateOperationsInput | number
    sale_id?: IntFieldUpdateOperationsInput | number
    street?: NullableStringFieldUpdateOperationsInput | string | null
    number?: NullableStringFieldUpdateOperationsInput | string | null
    complement?: NullableStringFieldUpdateOperationsInput | string | null
    formatted_address?: NullableStringFieldUpdateOperationsInput | string | null
    neighborhood?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    postal_code?: NullableStringFieldUpdateOperationsInput | string | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type deliveryaddressUncheckedUpdateManyWithoutDeliverysaleInput = {
    id?: IntFieldUpdateOperationsInput | number
    sale_id?: IntFieldUpdateOperationsInput | number
    street?: NullableStringFieldUpdateOperationsInput | string | null
    number?: NullableStringFieldUpdateOperationsInput | string | null
    complement?: NullableStringFieldUpdateOperationsInput | string | null
    formatted_address?: NullableStringFieldUpdateOperationsInput | string | null
    neighborhood?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    postal_code?: NullableStringFieldUpdateOperationsInput | string | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type paymentCreateManyPaymenttypeInput = {
    id?: number
    sale_id: number
    value: Decimal | DecimalJsLike | number | string
    is_online?: boolean | null
    description?: string | null
    currency?: string | null
  }

  export type paymentUpdateWithoutPaymenttypeInput = {
    value?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    is_online?: NullableBoolFieldUpdateOperationsInput | boolean | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    sale?: saleUpdateOneRequiredWithoutPaymentsNestedInput
  }

  export type paymentUncheckedUpdateWithoutPaymenttypeInput = {
    id?: IntFieldUpdateOperationsInput | number
    sale_id?: IntFieldUpdateOperationsInput | number
    value?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    is_online?: NullableBoolFieldUpdateOperationsInput | boolean | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type paymentUncheckedUpdateManyWithoutPaymenttypeInput = {
    id?: IntFieldUpdateOperationsInput | number
    sale_id?: IntFieldUpdateOperationsInput | number
    value?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    is_online?: NullableBoolFieldUpdateOperationsInput | boolean | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type couponsaleCreateManyCouponInput = {
    id?: number
    sale_id?: number | null
    value?: number | null
    target?: string | null
    sponsorship?: string | null
  }

  export type couponsaleUpdateWithoutCouponInput = {
    value?: NullableFloatFieldUpdateOperationsInput | number | null
    target?: NullableStringFieldUpdateOperationsInput | string | null
    sponsorship?: NullableStringFieldUpdateOperationsInput | string | null
    sale?: saleUpdateOneWithoutCouponsalesNestedInput
  }

  export type couponsaleUncheckedUpdateWithoutCouponInput = {
    id?: IntFieldUpdateOperationsInput | number
    sale_id?: NullableIntFieldUpdateOperationsInput | number | null
    value?: NullableFloatFieldUpdateOperationsInput | number | null
    target?: NullableStringFieldUpdateOperationsInput | string | null
    sponsorship?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type couponsaleUncheckedUpdateManyWithoutCouponInput = {
    id?: IntFieldUpdateOperationsInput | number
    sale_id?: NullableIntFieldUpdateOperationsInput | number | null
    value?: NullableFloatFieldUpdateOperationsInput | number | null
    target?: NullableStringFieldUpdateOperationsInput | string | null
    sponsorship?: NullableStringFieldUpdateOperationsInput | string | null
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}